   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB28:
  14               		.file 1 "keyboards/lily58/rev1/matrix.c"
   1:keyboards/lily58/rev1/matrix.c **** /*
   2:keyboards/lily58/rev1/matrix.c **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:keyboards/lily58/rev1/matrix.c **** 
   4:keyboards/lily58/rev1/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:keyboards/lily58/rev1/matrix.c **** it under the terms of the GNU General Public License as published by
   6:keyboards/lily58/rev1/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:keyboards/lily58/rev1/matrix.c **** (at your option) any later version.
   8:keyboards/lily58/rev1/matrix.c **** 
   9:keyboards/lily58/rev1/matrix.c **** This program is distributed in the hope that it will be useful,
  10:keyboards/lily58/rev1/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:keyboards/lily58/rev1/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:keyboards/lily58/rev1/matrix.c **** GNU General Public License for more details.
  13:keyboards/lily58/rev1/matrix.c **** 
  14:keyboards/lily58/rev1/matrix.c **** You should have received a copy of the GNU General Public License
  15:keyboards/lily58/rev1/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:keyboards/lily58/rev1/matrix.c **** */
  17:keyboards/lily58/rev1/matrix.c **** 
  18:keyboards/lily58/rev1/matrix.c **** /*
  19:keyboards/lily58/rev1/matrix.c ****  * scan matrix
  20:keyboards/lily58/rev1/matrix.c ****  */
  21:keyboards/lily58/rev1/matrix.c **** #include <stdint.h>
  22:keyboards/lily58/rev1/matrix.c **** #include <stdbool.h>
  23:keyboards/lily58/rev1/matrix.c **** #include <string.h>
  24:keyboards/lily58/rev1/matrix.c **** #include <avr/io.h>
  25:keyboards/lily58/rev1/matrix.c **** #include <avr/wdt.h>
  26:keyboards/lily58/rev1/matrix.c **** #include <avr/interrupt.h>
  27:keyboards/lily58/rev1/matrix.c **** #include <util/delay.h>
  28:keyboards/lily58/rev1/matrix.c **** #include "print.h"
  29:keyboards/lily58/rev1/matrix.c **** #include "debug.h"
  30:keyboards/lily58/rev1/matrix.c **** #include "util.h"
  31:keyboards/lily58/rev1/matrix.c **** #include "matrix.h"
  32:keyboards/lily58/rev1/matrix.c **** #include "split_util.h"
  33:keyboards/lily58/rev1/matrix.c **** #include "pro_micro.h"
  34:keyboards/lily58/rev1/matrix.c **** 
  35:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
  36:keyboards/lily58/rev1/matrix.c **** #  include "i2c.h"
  37:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
  38:keyboards/lily58/rev1/matrix.c **** #  include "split_scomm.h"
  39:keyboards/lily58/rev1/matrix.c **** #endif
  40:keyboards/lily58/rev1/matrix.c **** 
  41:keyboards/lily58/rev1/matrix.c **** #ifndef DEBOUNCE
  42:keyboards/lily58/rev1/matrix.c **** #  define DEBOUNCE	5
  43:keyboards/lily58/rev1/matrix.c **** #endif
  44:keyboards/lily58/rev1/matrix.c **** 
  45:keyboards/lily58/rev1/matrix.c **** #define ERROR_DISCONNECT_COUNT 5
  46:keyboards/lily58/rev1/matrix.c **** 
  47:keyboards/lily58/rev1/matrix.c **** static uint8_t debouncing = DEBOUNCE;
  48:keyboards/lily58/rev1/matrix.c **** static const int ROWS_PER_HAND = MATRIX_ROWS/2;
  49:keyboards/lily58/rev1/matrix.c **** static uint8_t error_count = 0;
  50:keyboards/lily58/rev1/matrix.c **** uint8_t is_master = 0 ;
  51:keyboards/lily58/rev1/matrix.c **** 
  52:keyboards/lily58/rev1/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  53:keyboards/lily58/rev1/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  54:keyboards/lily58/rev1/matrix.c **** 
  55:keyboards/lily58/rev1/matrix.c **** /* matrix state(1:on, 0:off) */
  56:keyboards/lily58/rev1/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  57:keyboards/lily58/rev1/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  58:keyboards/lily58/rev1/matrix.c **** 
  59:keyboards/lily58/rev1/matrix.c **** static matrix_row_t read_cols(void);
  60:keyboards/lily58/rev1/matrix.c **** static void init_cols(void);
  61:keyboards/lily58/rev1/matrix.c **** static void unselect_rows(void);
  62:keyboards/lily58/rev1/matrix.c **** static void select_row(uint8_t row);
  63:keyboards/lily58/rev1/matrix.c **** static uint8_t matrix_master_scan(void);
  64:keyboards/lily58/rev1/matrix.c **** 
  65:keyboards/lily58/rev1/matrix.c **** 
  66:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  67:keyboards/lily58/rev1/matrix.c **** void matrix_init_kb(void) {
  68:keyboards/lily58/rev1/matrix.c ****     matrix_init_user();
  69:keyboards/lily58/rev1/matrix.c **** }
  70:keyboards/lily58/rev1/matrix.c **** 
  71:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  72:keyboards/lily58/rev1/matrix.c **** void matrix_scan_kb(void) {
  73:keyboards/lily58/rev1/matrix.c ****     matrix_scan_user();
  74:keyboards/lily58/rev1/matrix.c **** }
  75:keyboards/lily58/rev1/matrix.c **** 
  76:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  77:keyboards/lily58/rev1/matrix.c **** void matrix_init_user(void) {
  78:keyboards/lily58/rev1/matrix.c **** }
  79:keyboards/lily58/rev1/matrix.c **** 
  80:keyboards/lily58/rev1/matrix.c **** __attribute__ ((weak))
  81:keyboards/lily58/rev1/matrix.c **** void matrix_scan_user(void) {
  82:keyboards/lily58/rev1/matrix.c **** }
  83:keyboards/lily58/rev1/matrix.c **** 
  84:keyboards/lily58/rev1/matrix.c **** inline
  85:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_rows(void)
  86:keyboards/lily58/rev1/matrix.c **** {
  87:keyboards/lily58/rev1/matrix.c ****     return MATRIX_ROWS;
  88:keyboards/lily58/rev1/matrix.c **** }
  89:keyboards/lily58/rev1/matrix.c **** 
  90:keyboards/lily58/rev1/matrix.c **** inline
  91:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_cols(void)
  92:keyboards/lily58/rev1/matrix.c **** {
  93:keyboards/lily58/rev1/matrix.c ****     return MATRIX_COLS;
  94:keyboards/lily58/rev1/matrix.c **** }
  95:keyboards/lily58/rev1/matrix.c **** 
  96:keyboards/lily58/rev1/matrix.c **** void matrix_init(void)
  97:keyboards/lily58/rev1/matrix.c **** {
  98:keyboards/lily58/rev1/matrix.c ****     debug_enable = true;
  99:keyboards/lily58/rev1/matrix.c ****     debug_matrix = true;
 100:keyboards/lily58/rev1/matrix.c ****     debug_mouse = true;
 101:keyboards/lily58/rev1/matrix.c ****     // initialize row and col
 102:keyboards/lily58/rev1/matrix.c ****     unselect_rows();
 103:keyboards/lily58/rev1/matrix.c ****     init_cols();
 104:keyboards/lily58/rev1/matrix.c **** 
 105:keyboards/lily58/rev1/matrix.c ****     TX_RX_LED_INIT;
 106:keyboards/lily58/rev1/matrix.c ****     TXLED0;
 107:keyboards/lily58/rev1/matrix.c ****     RXLED0;
 108:keyboards/lily58/rev1/matrix.c **** 
 109:keyboards/lily58/rev1/matrix.c ****     // initialize matrix state: all keys off
 110:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 111:keyboards/lily58/rev1/matrix.c ****         matrix[i] = 0;
 112:keyboards/lily58/rev1/matrix.c ****         matrix_debouncing[i] = 0;
 113:keyboards/lily58/rev1/matrix.c ****     }
 114:keyboards/lily58/rev1/matrix.c **** 
 115:keyboards/lily58/rev1/matrix.c ****     is_master = has_usb();
 116:keyboards/lily58/rev1/matrix.c **** 
 117:keyboards/lily58/rev1/matrix.c ****     matrix_init_quantum();
 118:keyboards/lily58/rev1/matrix.c **** }
 119:keyboards/lily58/rev1/matrix.c **** 
 120:keyboards/lily58/rev1/matrix.c **** uint8_t _matrix_scan(void)
 121:keyboards/lily58/rev1/matrix.c **** {
 122:keyboards/lily58/rev1/matrix.c ****     // Right hand is stored after the left in the matirx so, we need to offset it
 123:keyboards/lily58/rev1/matrix.c ****     int offset = isLeftHand ? 0 : (ROWS_PER_HAND);
 124:keyboards/lily58/rev1/matrix.c **** 
 125:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 126:keyboards/lily58/rev1/matrix.c ****         select_row(i);
 127:keyboards/lily58/rev1/matrix.c ****         _delay_us(30);  // without this wait read unstable value.
 128:keyboards/lily58/rev1/matrix.c ****         matrix_row_t cols = read_cols();
 129:keyboards/lily58/rev1/matrix.c ****         if (matrix_debouncing[i+offset] != cols) {
 130:keyboards/lily58/rev1/matrix.c ****             matrix_debouncing[i+offset] = cols;
 131:keyboards/lily58/rev1/matrix.c ****             debouncing = DEBOUNCE;
 132:keyboards/lily58/rev1/matrix.c ****         }
 133:keyboards/lily58/rev1/matrix.c ****         unselect_rows();
 134:keyboards/lily58/rev1/matrix.c ****     }
 135:keyboards/lily58/rev1/matrix.c **** 
 136:keyboards/lily58/rev1/matrix.c ****     if (debouncing) {
 137:keyboards/lily58/rev1/matrix.c ****         if (--debouncing) {
 138:keyboards/lily58/rev1/matrix.c ****             _delay_ms(1);
 139:keyboards/lily58/rev1/matrix.c ****         } else {
 140:keyboards/lily58/rev1/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 141:keyboards/lily58/rev1/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 142:keyboards/lily58/rev1/matrix.c ****             }
 143:keyboards/lily58/rev1/matrix.c ****         }
 144:keyboards/lily58/rev1/matrix.c ****     }
 145:keyboards/lily58/rev1/matrix.c **** 
 146:keyboards/lily58/rev1/matrix.c ****     return 1;
 147:keyboards/lily58/rev1/matrix.c **** }
 148:keyboards/lily58/rev1/matrix.c **** 
 149:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 150:keyboards/lily58/rev1/matrix.c **** 
 151:keyboards/lily58/rev1/matrix.c **** // Get rows from other half over i2c
 152:keyboards/lily58/rev1/matrix.c **** int i2c_transaction(void) {
 153:keyboards/lily58/rev1/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 154:keyboards/lily58/rev1/matrix.c **** 
 155:keyboards/lily58/rev1/matrix.c ****     int err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_WRITE);
 156:keyboards/lily58/rev1/matrix.c ****     if (err) goto i2c_error;
 157:keyboards/lily58/rev1/matrix.c **** 
 158:keyboards/lily58/rev1/matrix.c ****     // start of matrix stored at 0x00
 159:keyboards/lily58/rev1/matrix.c ****     err = i2c_master_write(0x00);
 160:keyboards/lily58/rev1/matrix.c ****     if (err) goto i2c_error;
 161:keyboards/lily58/rev1/matrix.c **** 
 162:keyboards/lily58/rev1/matrix.c ****     // Start read
 163:keyboards/lily58/rev1/matrix.c ****     err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_READ);
 164:keyboards/lily58/rev1/matrix.c ****     if (err) goto i2c_error;
 165:keyboards/lily58/rev1/matrix.c **** 
 166:keyboards/lily58/rev1/matrix.c ****     if (!err) {
 167:keyboards/lily58/rev1/matrix.c ****         int i;
 168:keyboards/lily58/rev1/matrix.c ****         for (i = 0; i < ROWS_PER_HAND-1; ++i) {
 169:keyboards/lily58/rev1/matrix.c ****             matrix[slaveOffset+i] = i2c_master_read(I2C_ACK);
 170:keyboards/lily58/rev1/matrix.c ****         }
 171:keyboards/lily58/rev1/matrix.c ****         matrix[slaveOffset+i] = i2c_master_read(I2C_NACK);
 172:keyboards/lily58/rev1/matrix.c ****         i2c_master_stop();
 173:keyboards/lily58/rev1/matrix.c ****     } else {
 174:keyboards/lily58/rev1/matrix.c **** i2c_error: // the cable is disconnceted, or something else went wrong
 175:keyboards/lily58/rev1/matrix.c ****         i2c_reset_state();
 176:keyboards/lily58/rev1/matrix.c ****         return err;
 177:keyboards/lily58/rev1/matrix.c ****     }
 178:keyboards/lily58/rev1/matrix.c **** 
 179:keyboards/lily58/rev1/matrix.c ****     return 0;
 180:keyboards/lily58/rev1/matrix.c **** }
 181:keyboards/lily58/rev1/matrix.c **** 
 182:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 183:keyboards/lily58/rev1/matrix.c **** 
 184:keyboards/lily58/rev1/matrix.c **** int serial_transaction(int master_changed) {
 185:keyboards/lily58/rev1/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 186:keyboards/lily58/rev1/matrix.c **** #ifdef SERIAL_USE_MULTI_TRANSACTION
 187:keyboards/lily58/rev1/matrix.c ****     int ret=serial_update_buffers(master_changed);
 188:keyboards/lily58/rev1/matrix.c **** #else
 189:keyboards/lily58/rev1/matrix.c ****     int ret=serial_update_buffers();
 190:keyboards/lily58/rev1/matrix.c **** #endif
 191:keyboards/lily58/rev1/matrix.c ****     if (ret ) {
 192:keyboards/lily58/rev1/matrix.c ****         if(ret==2) RXLED1;
 193:keyboards/lily58/rev1/matrix.c ****         return 1;
 194:keyboards/lily58/rev1/matrix.c ****     }
 195:keyboards/lily58/rev1/matrix.c ****     RXLED0;
 196:keyboards/lily58/rev1/matrix.c ****     memcpy(&matrix[slaveOffset],
 197:keyboards/lily58/rev1/matrix.c ****         (void *)serial_slave_buffer, SERIAL_SLAVE_BUFFER_LENGTH);
 198:keyboards/lily58/rev1/matrix.c ****     return 0;
 199:keyboards/lily58/rev1/matrix.c **** }
 200:keyboards/lily58/rev1/matrix.c **** #endif
 201:keyboards/lily58/rev1/matrix.c **** 
 202:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_scan(void)
 203:keyboards/lily58/rev1/matrix.c **** {
 204:keyboards/lily58/rev1/matrix.c ****     if (is_master) {
 205:keyboards/lily58/rev1/matrix.c ****         matrix_master_scan();
 206:keyboards/lily58/rev1/matrix.c ****     }else{
 207:keyboards/lily58/rev1/matrix.c ****         matrix_slave_scan();
 208:keyboards/lily58/rev1/matrix.c ****         int offset = (isLeftHand) ? ROWS_PER_HAND : 0;
 209:keyboards/lily58/rev1/matrix.c ****         memcpy(&matrix[offset],
 210:keyboards/lily58/rev1/matrix.c ****                (void *)serial_master_buffer, SERIAL_MASTER_BUFFER_LENGTH);
 211:keyboards/lily58/rev1/matrix.c ****         matrix_scan_quantum();
 212:keyboards/lily58/rev1/matrix.c ****     }
 213:keyboards/lily58/rev1/matrix.c ****     return 1;
 214:keyboards/lily58/rev1/matrix.c **** }
 215:keyboards/lily58/rev1/matrix.c **** 
 216:keyboards/lily58/rev1/matrix.c **** 
 217:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_master_scan(void) {
 218:keyboards/lily58/rev1/matrix.c **** 
 219:keyboards/lily58/rev1/matrix.c ****     int ret = _matrix_scan();
 220:keyboards/lily58/rev1/matrix.c ****     int mchanged = 1;
 221:keyboards/lily58/rev1/matrix.c **** 
 222:keyboards/lily58/rev1/matrix.c ****     int offset = (isLeftHand) ? 0 : ROWS_PER_HAND;
 223:keyboards/lily58/rev1/matrix.c **** 
 224:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 225:keyboards/lily58/rev1/matrix.c **** //    for (int i = 0; i < ROWS_PER_HAND; ++i) {
 226:keyboards/lily58/rev1/matrix.c ****         /* i2c_slave_buffer[i] = matrix[offset+i]; */
 227:keyboards/lily58/rev1/matrix.c **** //        i2c_slave_buffer[i] = matrix[offset+i];
 228:keyboards/lily58/rev1/matrix.c **** //    }
 229:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 230:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 231:keyboards/lily58/rev1/matrix.c ****     mchanged = memcmp((void *)serial_master_buffer,
 232:keyboards/lily58/rev1/matrix.c **** 		      &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 233:keyboards/lily58/rev1/matrix.c ****   #endif
 234:keyboards/lily58/rev1/matrix.c ****     memcpy((void *)serial_master_buffer,
 235:keyboards/lily58/rev1/matrix.c **** 	   &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 236:keyboards/lily58/rev1/matrix.c **** #endif
 237:keyboards/lily58/rev1/matrix.c **** 
 238:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 239:keyboards/lily58/rev1/matrix.c ****     if( i2c_transaction() ) {
 240:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 241:keyboards/lily58/rev1/matrix.c ****     if( serial_transaction(mchanged) ) {
 242:keyboards/lily58/rev1/matrix.c **** #endif
 243:keyboards/lily58/rev1/matrix.c ****         // turn on the indicator led when halves are disconnected
 244:keyboards/lily58/rev1/matrix.c ****         TXLED1;
 245:keyboards/lily58/rev1/matrix.c **** 
 246:keyboards/lily58/rev1/matrix.c ****         error_count++;
 247:keyboards/lily58/rev1/matrix.c **** 
 248:keyboards/lily58/rev1/matrix.c ****         if (error_count > ERROR_DISCONNECT_COUNT) {
 249:keyboards/lily58/rev1/matrix.c ****             // reset other half if disconnected
 250:keyboards/lily58/rev1/matrix.c ****             int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 251:keyboards/lily58/rev1/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 252:keyboards/lily58/rev1/matrix.c ****                 matrix[slaveOffset+i] = 0;
 253:keyboards/lily58/rev1/matrix.c ****             }
 254:keyboards/lily58/rev1/matrix.c ****         }
 255:keyboards/lily58/rev1/matrix.c ****     } else {
 256:keyboards/lily58/rev1/matrix.c ****         // turn off the indicator led on no error
 257:keyboards/lily58/rev1/matrix.c ****         TXLED0;
 258:keyboards/lily58/rev1/matrix.c ****         error_count = 0;
 259:keyboards/lily58/rev1/matrix.c ****     }
 260:keyboards/lily58/rev1/matrix.c ****     matrix_scan_quantum();
 261:keyboards/lily58/rev1/matrix.c ****     return ret;
 262:keyboards/lily58/rev1/matrix.c **** }
 263:keyboards/lily58/rev1/matrix.c **** 
 264:keyboards/lily58/rev1/matrix.c **** void matrix_slave_scan(void) {
 265:keyboards/lily58/rev1/matrix.c ****     _matrix_scan();
 266:keyboards/lily58/rev1/matrix.c **** 
 267:keyboards/lily58/rev1/matrix.c ****     int offset = (isLeftHand) ? 0 : ROWS_PER_HAND;
 268:keyboards/lily58/rev1/matrix.c **** 
 269:keyboards/lily58/rev1/matrix.c **** #ifdef USE_MATRIX_I2C
 270:keyboards/lily58/rev1/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 271:keyboards/lily58/rev1/matrix.c ****         /* i2c_slave_buffer[i] = matrix[offset+i]; */
 272:keyboards/lily58/rev1/matrix.c ****         i2c_slave_buffer[i] = matrix[offset+i];
 273:keyboards/lily58/rev1/matrix.c ****     }
 274:keyboards/lily58/rev1/matrix.c **** #else // USE_SERIAL
 275:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 276:keyboards/lily58/rev1/matrix.c ****     int change = 0;
 277:keyboards/lily58/rev1/matrix.c ****   #endif
 278:keyboards/lily58/rev1/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 279:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 280:keyboards/lily58/rev1/matrix.c ****         if( serial_slave_buffer[i] != matrix[offset+i] )
 281:keyboards/lily58/rev1/matrix.c **** 	    change = 1;
 282:keyboards/lily58/rev1/matrix.c ****   #endif
 283:keyboards/lily58/rev1/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 284:keyboards/lily58/rev1/matrix.c ****     }
 285:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 286:keyboards/lily58/rev1/matrix.c ****     slave_buffer_change_count += change;
 287:keyboards/lily58/rev1/matrix.c ****   #endif
 288:keyboards/lily58/rev1/matrix.c **** #endif
 289:keyboards/lily58/rev1/matrix.c **** }
 290:keyboards/lily58/rev1/matrix.c **** 
 291:keyboards/lily58/rev1/matrix.c **** bool matrix_is_modified(void)
 292:keyboards/lily58/rev1/matrix.c **** {
 293:keyboards/lily58/rev1/matrix.c ****     if (debouncing) return false;
 294:keyboards/lily58/rev1/matrix.c ****     return true;
 295:keyboards/lily58/rev1/matrix.c **** }
 296:keyboards/lily58/rev1/matrix.c **** 
 297:keyboards/lily58/rev1/matrix.c **** inline
 298:keyboards/lily58/rev1/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 299:keyboards/lily58/rev1/matrix.c **** {
 300:keyboards/lily58/rev1/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 301:keyboards/lily58/rev1/matrix.c **** }
 302:keyboards/lily58/rev1/matrix.c **** 
 303:keyboards/lily58/rev1/matrix.c **** inline
 304:keyboards/lily58/rev1/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 305:keyboards/lily58/rev1/matrix.c **** {
 306:keyboards/lily58/rev1/matrix.c ****     return matrix[row];
 307:keyboards/lily58/rev1/matrix.c **** }
 308:keyboards/lily58/rev1/matrix.c **** 
 309:keyboards/lily58/rev1/matrix.c **** void matrix_print(void)
 310:keyboards/lily58/rev1/matrix.c **** {
 311:keyboards/lily58/rev1/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 312:keyboards/lily58/rev1/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 313:keyboards/lily58/rev1/matrix.c ****         phex(row); print(": ");
 314:keyboards/lily58/rev1/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 315:keyboards/lily58/rev1/matrix.c ****         print("\n");
 316:keyboards/lily58/rev1/matrix.c ****     }
 317:keyboards/lily58/rev1/matrix.c **** }
 318:keyboards/lily58/rev1/matrix.c **** 
 319:keyboards/lily58/rev1/matrix.c **** uint8_t matrix_key_count(void)
 320:keyboards/lily58/rev1/matrix.c **** {
 321:keyboards/lily58/rev1/matrix.c ****     uint8_t count = 0;
 322:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 323:keyboards/lily58/rev1/matrix.c ****         count += bitpop16(matrix[i]);
 324:keyboards/lily58/rev1/matrix.c ****     }
 325:keyboards/lily58/rev1/matrix.c ****     return count;
 326:keyboards/lily58/rev1/matrix.c **** }
 327:keyboards/lily58/rev1/matrix.c **** 
 328:keyboards/lily58/rev1/matrix.c **** static void  init_cols(void)
 329:keyboards/lily58/rev1/matrix.c **** {
 330:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 331:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 1) &=  ~_BV(col_pins[x] & 0xF);
 332:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 2) |= _BV(col_pins[x] & 0xF);
 333:keyboards/lily58/rev1/matrix.c ****     }
 334:keyboards/lily58/rev1/matrix.c **** }
 335:keyboards/lily58/rev1/matrix.c **** 
 336:keyboards/lily58/rev1/matrix.c **** static matrix_row_t read_cols(void)
 337:keyboards/lily58/rev1/matrix.c **** {
 338:keyboards/lily58/rev1/matrix.c ****     matrix_row_t result = 0;
 339:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 340:keyboards/lily58/rev1/matrix.c ****         result |= (_SFR_IO8(col_pins[x] >> 4) & _BV(col_pins[x] & 0xF)) ? 0 : (1 << x);
 341:keyboards/lily58/rev1/matrix.c ****     }
 342:keyboards/lily58/rev1/matrix.c ****     return result;
 343:keyboards/lily58/rev1/matrix.c **** }
 344:keyboards/lily58/rev1/matrix.c **** 
 345:keyboards/lily58/rev1/matrix.c **** static void unselect_rows(void)
 346:keyboards/lily58/rev1/matrix.c **** {
  15               		.loc 1 346 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22 0000 A0E0      		ldi r26,lo8(row_pins)
  23 0002 B0E0      		ldi r27,hi8(row_pins)
  24               	.LBB9:
 347:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < ROWS_PER_HAND; x++) {
 348:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((row_pins[x] >> 4) + 1) &=  ~_BV(row_pins[x] & 0xF);
  25               		.loc 1 348 0
  26 0004 41E0      		ldi r20,lo8(1)
  27 0006 50E0      		ldi r21,0
  28               	.LVL1:
  29               	.L2:
  30               		.loc 1 348 0 is_stmt 0 discriminator 3
  31 0008 8D91      		ld r24,X+
  32               	.LVL2:
  33 000a E82F      		mov r30,r24
  34 000c E295      		swap r30
  35 000e EF70      		andi r30,lo8(15)
  36 0010 F0E0      		ldi r31,0
  37 0012 21A1      		ldd r18,Z+33
  38 0014 8F70      		andi r24,lo8(15)
  39 0016 BA01      		movw r22,r20
  40 0018 00C0      		rjmp 2f
  41               		1:
  42 001a 660F      		lsl r22
  43 001c 771F      		rol r23
  44               		2:
  45 001e 8A95      		dec r24
  46 0020 02F4      		brpl 1b
  47 0022 CB01      		movw r24,r22
  48 0024 962F      		mov r25,r22
  49 0026 9095      		com r25
  50 0028 9223      		and r25,r18
  51 002a 91A3      		std Z+33,r25
 349:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((row_pins[x] >> 4) + 2) |= _BV(row_pins[x] & 0xF);
  52               		.loc 1 349 0 is_stmt 1 discriminator 3
  53 002c 92A1      		ldd r25,Z+34
  54 002e 892B      		or r24,r25
  55 0030 82A3      		std Z+34,r24
  56               	.LVL3:
 347:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < ROWS_PER_HAND; x++) {
  57               		.loc 1 347 0 discriminator 3
  58 0032 70E0      		ldi r23,hi8(row_pins+5)
  59 0034 A030      		cpi r26,lo8(row_pins+5)
  60 0036 B707      		cpc r27,r23
  61 0038 01F4      		brne .L2
  62               	/* epilogue start */
  63               	.LBE9:
 350:keyboards/lily58/rev1/matrix.c ****     }
 351:keyboards/lily58/rev1/matrix.c **** }
  64               		.loc 1 351 0
  65 003a 0895      		ret
  66               		.cfi_endproc
  67               	.LFE28:
  69               		.section	.text.matrix_init_user,"ax",@progbits
  70               		.weak	matrix_init_user
  72               	matrix_init_user:
  73               	.LFB11:
  77:keyboards/lily58/rev1/matrix.c **** }
  74               		.loc 1 77 0
  75               		.cfi_startproc
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 0 */
  79               	.L__stack_usage = 0
  80 0000 0895      		ret
  81               		.cfi_endproc
  82               	.LFE11:
  84               		.section	.text.matrix_init_kb,"ax",@progbits
  85               		.weak	matrix_init_kb
  87               	matrix_init_kb:
  88               	.LFB9:
  67:keyboards/lily58/rev1/matrix.c ****     matrix_init_user();
  89               		.loc 1 67 0
  90               		.cfi_startproc
  91               	/* prologue: function */
  92               	/* frame size = 0 */
  93               	/* stack size = 0 */
  94               	.L__stack_usage = 0
  68:keyboards/lily58/rev1/matrix.c **** }
  95               		.loc 1 68 0
  96 0000 0C94 0000 		jmp matrix_init_user
  97               	.LVL4:
  98               		.cfi_endproc
  99               	.LFE9:
 101               		.section	.text.matrix_scan_user,"ax",@progbits
 102               		.weak	matrix_scan_user
 104               	matrix_scan_user:
 105               	.LFB12:
  81:keyboards/lily58/rev1/matrix.c **** }
 106               		.loc 1 81 0
 107               		.cfi_startproc
 108               	/* prologue: function */
 109               	/* frame size = 0 */
 110               	/* stack size = 0 */
 111               	.L__stack_usage = 0
 112 0000 0895      		ret
 113               		.cfi_endproc
 114               	.LFE12:
 116               		.section	.text.matrix_scan_kb,"ax",@progbits
 117               		.weak	matrix_scan_kb
 119               	matrix_scan_kb:
 120               	.LFB10:
  72:keyboards/lily58/rev1/matrix.c ****     matrix_scan_user();
 121               		.loc 1 72 0
 122               		.cfi_startproc
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
  73:keyboards/lily58/rev1/matrix.c **** }
 127               		.loc 1 73 0
 128 0000 0C94 0000 		jmp matrix_scan_user
 129               	.LVL5:
 130               		.cfi_endproc
 131               	.LFE10:
 133               		.section	.text.matrix_rows,"ax",@progbits
 134               	.global	matrix_rows
 136               	matrix_rows:
 137               	.LFB13:
  86:keyboards/lily58/rev1/matrix.c ****     return MATRIX_ROWS;
 138               		.loc 1 86 0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
  88:keyboards/lily58/rev1/matrix.c **** 
 144               		.loc 1 88 0
 145 0000 8AE0      		ldi r24,lo8(10)
 146 0002 0895      		ret
 147               		.cfi_endproc
 148               	.LFE13:
 150               		.section	.text.matrix_cols,"ax",@progbits
 151               	.global	matrix_cols
 153               	matrix_cols:
 154               	.LFB14:
  92:keyboards/lily58/rev1/matrix.c ****     return MATRIX_COLS;
 155               		.loc 1 92 0
 156               		.cfi_startproc
 157               	/* prologue: function */
 158               	/* frame size = 0 */
 159               	/* stack size = 0 */
 160               	.L__stack_usage = 0
  94:keyboards/lily58/rev1/matrix.c **** 
 161               		.loc 1 94 0
 162 0000 86E0      		ldi r24,lo8(6)
 163 0002 0895      		ret
 164               		.cfi_endproc
 165               	.LFE14:
 167               		.section	.text.matrix_init,"ax",@progbits
 168               	.global	matrix_init
 170               	matrix_init:
 171               	.LFB15:
  97:keyboards/lily58/rev1/matrix.c ****     debug_enable = true;
 172               		.loc 1 97 0
 173               		.cfi_startproc
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176               	/* stack size = 0 */
 177               	.L__stack_usage = 0
  98:keyboards/lily58/rev1/matrix.c ****     debug_matrix = true;
 178               		.loc 1 98 0
 179 0000 8091 0000 		lds r24,debug_config
 100:keyboards/lily58/rev1/matrix.c ****     // initialize row and col
 180               		.loc 1 100 0
 181 0004 8360      		ori r24,lo8(3)
 182 0006 8860      		ori r24,lo8(1<<3)
 183 0008 8093 0000 		sts debug_config,r24
 102:keyboards/lily58/rev1/matrix.c ****     init_cols();
 184               		.loc 1 102 0
 185 000c 0E94 0000 		call unselect_rows
 186               	.LVL6:
 187 0010 A0E0      		ldi r26,lo8(col_pins)
 188 0012 B0E0      		ldi r27,hi8(col_pins)
 189               	.LBB14:
 190               	.LBB15:
 331:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 2) |= _BV(col_pins[x] & 0xF);
 191               		.loc 1 331 0
 192 0014 41E0      		ldi r20,lo8(1)
 193 0016 50E0      		ldi r21,0
 194               	.LVL7:
 195               	.L12:
 196 0018 8D91      		ld r24,X+
 197               	.LVL8:
 198 001a E82F      		mov r30,r24
 199 001c E295      		swap r30
 200 001e EF70      		andi r30,lo8(15)
 201 0020 F0E0      		ldi r31,0
 202 0022 21A1      		ldd r18,Z+33
 203 0024 8F70      		andi r24,lo8(15)
 204 0026 BA01      		movw r22,r20
 205 0028 00C0      		rjmp 2f
 206               		1:
 207 002a 660F      		lsl r22
 208 002c 771F      		rol r23
 209               		2:
 210 002e 8A95      		dec r24
 211 0030 02F4      		brpl 1b
 212 0032 CB01      		movw r24,r22
 213 0034 962F      		mov r25,r22
 214 0036 9095      		com r25
 215 0038 9223      		and r25,r18
 216 003a 91A3      		std Z+33,r25
 332:keyboards/lily58/rev1/matrix.c ****     }
 217               		.loc 1 332 0
 218 003c 92A1      		ldd r25,Z+34
 219 003e 892B      		or r24,r25
 220 0040 82A3      		std Z+34,r24
 221               	.LVL9:
 330:keyboards/lily58/rev1/matrix.c ****         _SFR_IO8((col_pins[x] >> 4) + 1) &=  ~_BV(col_pins[x] & 0xF);
 222               		.loc 1 330 0
 223 0042 70E0      		ldi r23,hi8(col_pins+6)
 224 0044 A030      		cpi r26,lo8(col_pins+6)
 225 0046 B707      		cpc r27,r23
 226 0048 01F4      		brne .L12
 227               	.LBE15:
 228               	.LBE14:
 105:keyboards/lily58/rev1/matrix.c ****     TXLED0;
 229               		.loc 1 105 0
 230 004a 559A      		sbi 0xa,5
 231 004c 209A      		sbi 0x4,0
 106:keyboards/lily58/rev1/matrix.c ****     RXLED0;
 232               		.loc 1 106 0
 233 004e 5D9A      		sbi 0xb,5
 107:keyboards/lily58/rev1/matrix.c **** 
 234               		.loc 1 107 0
 235 0050 289A      		sbi 0x5,0
 236               	.LVL10:
 237 0052 A0E0      		ldi r26,lo8(matrix_debouncing)
 238 0054 B0E0      		ldi r27,hi8(matrix_debouncing)
 239               	.LVL11:
 240 0056 E0E0      		ldi r30,lo8(matrix)
 241 0058 F0E0      		ldi r31,hi8(matrix)
 242 005a 8AE0      		ldi r24,lo8(10)
 243 005c 8E0F      		add r24,r30
 244               	.LVL12:
 245               	.L13:
 246               	.LBB16:
 111:keyboards/lily58/rev1/matrix.c ****         matrix_debouncing[i] = 0;
 247               		.loc 1 111 0 discriminator 3
 248 005e 1192      		st Z+,__zero_reg__
 249               	.LVL13:
 112:keyboards/lily58/rev1/matrix.c ****     }
 250               		.loc 1 112 0 discriminator 3
 251 0060 1D92      		st X+,__zero_reg__
 252               	.LVL14:
 110:keyboards/lily58/rev1/matrix.c ****         matrix[i] = 0;
 253               		.loc 1 110 0 discriminator 3
 254 0062 8E13      		cpse r24,r30
 255 0064 00C0      		rjmp .L13
 256               	.LBE16:
 115:keyboards/lily58/rev1/matrix.c **** 
 257               		.loc 1 115 0
 258 0066 0E94 0000 		call has_usb
 259               	.LVL15:
 260 006a 8093 0000 		sts is_master,r24
 117:keyboards/lily58/rev1/matrix.c **** }
 261               		.loc 1 117 0
 262 006e 0C94 0000 		jmp matrix_init_quantum
 263               	.LVL16:
 264               		.cfi_endproc
 265               	.LFE15:
 267               		.section	.text._matrix_scan,"ax",@progbits
 268               	.global	_matrix_scan
 270               	_matrix_scan:
 271               	.LFB16:
 121:keyboards/lily58/rev1/matrix.c ****     // Right hand is stored after the left in the matirx so, we need to offset it
 272               		.loc 1 121 0
 273               		.cfi_startproc
 274 0000 9F92      		push r9
 275               	.LCFI0:
 276               		.cfi_def_cfa_offset 3
 277               		.cfi_offset 9, -2
 278 0002 AF92      		push r10
 279               	.LCFI1:
 280               		.cfi_def_cfa_offset 4
 281               		.cfi_offset 10, -3
 282 0004 BF92      		push r11
 283               	.LCFI2:
 284               		.cfi_def_cfa_offset 5
 285               		.cfi_offset 11, -4
 286 0006 CF92      		push r12
 287               	.LCFI3:
 288               		.cfi_def_cfa_offset 6
 289               		.cfi_offset 12, -5
 290 0008 DF92      		push r13
 291               	.LCFI4:
 292               		.cfi_def_cfa_offset 7
 293               		.cfi_offset 13, -6
 294 000a EF92      		push r14
 295               	.LCFI5:
 296               		.cfi_def_cfa_offset 8
 297               		.cfi_offset 14, -7
 298 000c FF92      		push r15
 299               	.LCFI6:
 300               		.cfi_def_cfa_offset 9
 301               		.cfi_offset 15, -8
 302 000e 0F93      		push r16
 303               	.LCFI7:
 304               		.cfi_def_cfa_offset 10
 305               		.cfi_offset 16, -9
 306 0010 1F93      		push r17
 307               	.LCFI8:
 308               		.cfi_def_cfa_offset 11
 309               		.cfi_offset 17, -10
 310 0012 CF93      		push r28
 311               	.LCFI9:
 312               		.cfi_def_cfa_offset 12
 313               		.cfi_offset 28, -11
 314 0014 DF93      		push r29
 315               	.LCFI10:
 316               		.cfi_def_cfa_offset 13
 317               		.cfi_offset 29, -12
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 11 */
 321               	.L__stack_usage = 11
 123:keyboards/lily58/rev1/matrix.c **** 
 322               		.loc 1 123 0
 323 0016 8091 0000 		lds r24,isLeftHand
 324 001a 8111      		cpse r24,__zero_reg__
 325 001c 00C0      		rjmp .L27
 326 001e 05E0      		ldi r16,lo8(5)
 327 0020 10E0      		ldi r17,0
 328 0022 00C0      		rjmp .L17
 329               	.L27:
 330 0024 00E0      		ldi r16,0
 331 0026 10E0      		ldi r17,0
 332               	.L17:
 333               	.LVL17:
 334 0028 A801      		movw r20,r16
 335 002a 4050      		subi r20,lo8(-(matrix_debouncing))
 336 002c 5040      		sbci r21,hi8(-(matrix_debouncing))
 337 002e 7A01      		movw r14,r20
 338 0030 EA01      		movw r28,r20
 339 0032 80E0      		ldi r24,lo8(row_pins)
 340 0034 C82E      		mov r12,r24
 341 0036 80E0      		ldi r24,hi8(row_pins)
 342 0038 D82E      		mov r13,r24
 343               	.LBB29:
 344               	.LBB30:
 345               	.LBB31:
 346               	.LBB32:
 352:keyboards/lily58/rev1/matrix.c **** 
 353:keyboards/lily58/rev1/matrix.c **** static void select_row(uint8_t row)
 354:keyboards/lily58/rev1/matrix.c **** {
 355:keyboards/lily58/rev1/matrix.c ****     _SFR_IO8((row_pins[row] >> 4) + 1) |=  _BV(row_pins[row] & 0xF);
 347               		.loc 1 355 0 discriminator 4
 348 003a AA24      		clr r10
 349 003c A394      		inc r10
 350 003e B12C      		mov r11,__zero_reg__
 351               	.LBE32:
 352               	.LBE31:
 131:keyboards/lily58/rev1/matrix.c ****         }
 353               		.loc 1 131 0 discriminator 4
 354 0040 25E0      		ldi r18,lo8(5)
 355 0042 922E      		mov r9,r18
 356               	.LVL18:
 357               	.L18:
 358               	.LBE30:
 125:keyboards/lily58/rev1/matrix.c ****         select_row(i);
 359               		.loc 1 125 0 discriminator 1
 360 0044 80E0      		ldi r24,lo8(row_pins+5)
 361 0046 C816      		cp r12,r24
 362 0048 80E0      		ldi r24,hi8(row_pins+5)
 363 004a D806      		cpc r13,r24
 364 004c 01F4      		brne .+2
 365 004e 00C0      		rjmp .L32
 366               	.LVL19:
 367               	.LBB40:
 368               	.LBB34:
 369               	.LBB33:
 370               		.loc 1 355 0
 371 0050 F601      		movw r30,r12
 372 0052 8191      		ld r24,Z+
 373 0054 6F01      		movw r12,r30
 374               	.LVL20:
 375 0056 E82F      		mov r30,r24
 376 0058 E295      		swap r30
 377 005a EF70      		andi r30,lo8(15)
 378 005c F0E0      		ldi r31,0
 379 005e 21A1      		ldd r18,Z+33
 380 0060 8F70      		andi r24,lo8(15)
 381 0062 A501      		movw r20,r10
 382 0064 00C0      		rjmp 2f
 383               		1:
 384 0066 440F      		lsl r20
 385 0068 551F      		rol r21
 386               		2:
 387 006a 8A95      		dec r24
 388 006c 02F4      		brpl 1b
 389 006e CA01      		movw r24,r20
 390 0070 922F      		mov r25,r18
 391 0072 982B      		or r25,r24
 392 0074 91A3      		std Z+33,r25
 356:keyboards/lily58/rev1/matrix.c ****     _SFR_IO8((row_pins[row] >> 4) + 2) &= ~_BV(row_pins[row] & 0xF);
 393               		.loc 1 356 0
 394 0076 92A1      		ldd r25,Z+34
 395 0078 8095      		com r24
 396 007a 8923      		and r24,r25
 397 007c 82A3      		std Z+34,r24
 398               	.LVL21:
 399               	.LBE33:
 400               	.LBE34:
 401               	.LBB35:
 402               	.LBB36:
 403               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 404               		.loc 2 245 0
 405 007e 50EA      		ldi r21,lo8(-96)
 406 0080 5A95      	1:	dec r21
 407 0082 01F4      		brne 1b
 408               	.LVL22:
 409 0084 E0E0      		ldi r30,lo8(col_pins)
 410 0086 F0E0      		ldi r31,hi8(col_pins)
 411               	.LBE36:
 412               	.LBE35:
 413               	.LBB37:
 414               	.LBB38:
 338:keyboards/lily58/rev1/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 415               		.loc 1 338 0
 416 0088 20E0      		ldi r18,0
 417               	.LBB39:
 339:keyboards/lily58/rev1/matrix.c ****         result |= (_SFR_IO8(col_pins[x] >> 4) & _BV(col_pins[x] & 0xF)) ? 0 : (1 << x);
 418               		.loc 1 339 0
 419 008a 40E0      		ldi r20,0
 420 008c 50E0      		ldi r21,0
 421               	.LVL23:
 422               	.L20:
 340:keyboards/lily58/rev1/matrix.c ****     }
 423               		.loc 1 340 0
 424 008e 3191      		ld r19,Z+
 425 0090 A32F      		mov r26,r19
 426 0092 A295      		swap r26
 427 0094 AF70      		andi r26,lo8(15)
 428 0096 B0E0      		ldi r27,0
 429 0098 9096      		adiw r26,32
 430 009a 8C91      		ld r24,X
 431 009c 90E0      		ldi r25,0
 432 009e 3F70      		andi r19,lo8(15)
 433 00a0 00C0      		rjmp 2f
 434               		1:
 435 00a2 9595      		asr r25
 436 00a4 8795      		ror r24
 437               		2:
 438 00a6 3A95      		dec r19
 439 00a8 02F4      		brpl 1b
 440 00aa 80FD      		sbrc r24,0
 441 00ac 00C0      		rjmp .L28
 442 00ae C501      		movw r24,r10
 443 00b0 042E      		mov r0,r20
 444 00b2 00C0      		rjmp 2f
 445               		1:
 446 00b4 880F      		lsl r24
 447               		2:
 448 00b6 0A94      		dec r0
 449 00b8 02F4      		brpl 1b
 450 00ba 00C0      		rjmp .L19
 451               	.L28:
 452 00bc 80E0      		ldi r24,0
 453 00be 90E0      		ldi r25,0
 454               	.L19:
 455 00c0 282B      		or r18,r24
 456               	.LVL24:
 339:keyboards/lily58/rev1/matrix.c ****         result |= (_SFR_IO8(col_pins[x] >> 4) & _BV(col_pins[x] & 0xF)) ? 0 : (1 << x);
 457               		.loc 1 339 0
 458 00c2 4F5F      		subi r20,-1
 459 00c4 5F4F      		sbci r21,-1
 460               	.LVL25:
 461 00c6 4630      		cpi r20,6
 462 00c8 5105      		cpc r21,__zero_reg__
 463 00ca 01F4      		brne .L20
 464               	.LBE39:
 465               	.LBE38:
 466               	.LBE37:
 129:keyboards/lily58/rev1/matrix.c ****             matrix_debouncing[i+offset] = cols;
 467               		.loc 1 129 0
 468 00cc 8881      		ld r24,Y
 469 00ce 8217      		cp r24,r18
 470 00d0 01F0      		breq .L21
 130:keyboards/lily58/rev1/matrix.c ****             debouncing = DEBOUNCE;
 471               		.loc 1 130 0
 472 00d2 2883      		st Y,r18
 131:keyboards/lily58/rev1/matrix.c ****         }
 473               		.loc 1 131 0
 474 00d4 9092 0000 		sts debouncing,r9
 475               	.L21:
 133:keyboards/lily58/rev1/matrix.c ****     }
 476               		.loc 1 133 0 discriminator 2
 477 00d8 0E94 0000 		call unselect_rows
 478               	.LVL26:
 479 00dc 2196      		adiw r28,1
 480 00de 00C0      		rjmp .L18
 481               	.LVL27:
 482               	.L32:
 483               	.LBE40:
 484               	.LBE29:
 136:keyboards/lily58/rev1/matrix.c ****         if (--debouncing) {
 485               		.loc 1 136 0
 486 00e0 8091 0000 		lds r24,debouncing
 487 00e4 8823      		tst r24
 488 00e6 01F0      		breq .L24
 137:keyboards/lily58/rev1/matrix.c ****             _delay_ms(1);
 489               		.loc 1 137 0
 490 00e8 8150      		subi r24,lo8(-(-1))
 491 00ea 8093 0000 		sts debouncing,r24
 492 00ee 8823      		tst r24
 493 00f0 01F0      		breq .L29
 494               	.LVL28:
 495               	.LBB41:
 496               	.LBB42:
 163:/usr/lib/avr/include/util/delay.h **** 
 497               		.loc 2 163 0
 498 00f2 EFE9      		ldi r30,lo8(3999)
 499 00f4 FFE0      		ldi r31,hi8(3999)
 500 00f6 3197      	1:	sbiw r30,1
 501 00f8 01F4      		brne 1b
 502 00fa 00C0      		rjmp .
 503 00fc 0000      		nop
 504 00fe 00C0      		rjmp .L24
 505               	.LVL29:
 506               	.L29:
 507               	.LBE42:
 508               	.LBE41:
 509 0100 80E0      		ldi r24,0
 510 0102 90E0      		ldi r25,0
 511               	.L25:
 512               	.LVL30:
 513 0104 FC01      		movw r30,r24
 514 0106 E00F      		add r30,r16
 515 0108 F11F      		adc r31,r17
 516 010a E050      		subi r30,lo8(-(matrix))
 517 010c F040      		sbci r31,hi8(-(matrix))
 518 010e D701      		movw r26,r14
 519 0110 A80F      		add r26,r24
 520 0112 B91F      		adc r27,r25
 521               	.LBB43:
 141:keyboards/lily58/rev1/matrix.c ****             }
 522               		.loc 1 141 0 discriminator 3
 523 0114 2C91      		ld r18,X
 524 0116 2083      		st Z,r18
 525               	.LVL31:
 526 0118 0196      		adiw r24,1
 527               	.LVL32:
 140:keyboards/lily58/rev1/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 528               		.loc 1 140 0 discriminator 3
 529 011a 8530      		cpi r24,5
 530 011c 9105      		cpc r25,__zero_reg__
 531 011e 01F4      		brne .L25
 532               	.LVL33:
 533               	.L24:
 534               	.LBE43:
 147:keyboards/lily58/rev1/matrix.c **** 
 535               		.loc 1 147 0
 536 0120 81E0      		ldi r24,lo8(1)
 537               	/* epilogue start */
 538 0122 DF91      		pop r29
 539 0124 CF91      		pop r28
 540 0126 1F91      		pop r17
 541 0128 0F91      		pop r16
 542               	.LVL34:
 543 012a FF90      		pop r15
 544 012c EF90      		pop r14
 545               	.LVL35:
 546 012e DF90      		pop r13
 547 0130 CF90      		pop r12
 548               	.LVL36:
 549 0132 BF90      		pop r11
 550 0134 AF90      		pop r10
 551 0136 9F90      		pop r9
 552 0138 0895      		ret
 553               		.cfi_endproc
 554               	.LFE16:
 556               		.section	.text.serial_transaction,"ax",@progbits
 557               	.global	serial_transaction
 559               	serial_transaction:
 560               	.LFB17:
 184:keyboards/lily58/rev1/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 561               		.loc 1 184 0
 562               		.cfi_startproc
 563               	.LVL37:
 564 0000 CF93      		push r28
 565               	.LCFI11:
 566               		.cfi_def_cfa_offset 3
 567               		.cfi_offset 28, -2
 568 0002 DF93      		push r29
 569               	.LCFI12:
 570               		.cfi_def_cfa_offset 4
 571               		.cfi_offset 29, -3
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 2 */
 575               	.L__stack_usage = 2
 185:keyboards/lily58/rev1/matrix.c **** #ifdef SERIAL_USE_MULTI_TRANSACTION
 576               		.loc 1 185 0
 577 0004 2091 0000 		lds r18,isLeftHand
 578 0008 2111      		cpse r18,__zero_reg__
 579 000a 00C0      		rjmp .L37
 580 000c C0E0      		ldi r28,0
 581 000e D0E0      		ldi r29,0
 582 0010 00C0      		rjmp .L34
 583               	.L37:
 584 0012 C5E0      		ldi r28,lo8(5)
 585 0014 D0E0      		ldi r29,0
 586               	.L34:
 587               	.LVL38:
 187:keyboards/lily58/rev1/matrix.c **** #else
 588               		.loc 1 187 0 discriminator 4
 589 0016 0E94 0000 		call serial_update_buffers
 590               	.LVL39:
 191:keyboards/lily58/rev1/matrix.c ****         if(ret==2) RXLED1;
 591               		.loc 1 191 0 discriminator 4
 592 001a 0097      		sbiw r24,0
 593 001c 01F0      		breq .L35
 192:keyboards/lily58/rev1/matrix.c ****         return 1;
 594               		.loc 1 192 0
 595 001e 0297      		sbiw r24,2
 596 0020 01F4      		brne .L38
 192:keyboards/lily58/rev1/matrix.c ****         return 1;
 597               		.loc 1 192 0 is_stmt 0 discriminator 1
 598 0022 2898      		cbi 0x5,0
 599 0024 00C0      		rjmp .L38
 600               	.L35:
 195:keyboards/lily58/rev1/matrix.c ****     memcpy(&matrix[slaveOffset],
 601               		.loc 1 195 0 is_stmt 1
 602 0026 289A      		sbi 0x5,0
 196:keyboards/lily58/rev1/matrix.c ****         (void *)serial_slave_buffer, SERIAL_SLAVE_BUFFER_LENGTH);
 603               		.loc 1 196 0
 604 0028 DE01      		movw r26,r28
 605 002a A050      		subi r26,lo8(-(matrix))
 606 002c B040      		sbci r27,hi8(-(matrix))
 607 002e 85E0      		ldi r24,lo8(5)
 608               	.LVL40:
 609 0030 E0E0      		ldi r30,lo8(serial_slave_buffer)
 610 0032 F0E0      		ldi r31,hi8(serial_slave_buffer)
 611               		0:
 612 0034 0190      		ld r0,Z+
 613 0036 0D92      		st X+,r0
 614 0038 8A95      		dec r24
 615 003a 01F4      		brne 0b
 198:keyboards/lily58/rev1/matrix.c **** }
 616               		.loc 1 198 0
 617 003c 80E0      		ldi r24,0
 618 003e 90E0      		ldi r25,0
 619 0040 00C0      		rjmp .L36
 620               	.LVL41:
 621               	.L38:
 193:keyboards/lily58/rev1/matrix.c ****     }
 622               		.loc 1 193 0
 623 0042 81E0      		ldi r24,lo8(1)
 624 0044 90E0      		ldi r25,0
 625               	.LVL42:
 626               	.L36:
 627               	/* epilogue start */
 199:keyboards/lily58/rev1/matrix.c **** #endif
 628               		.loc 1 199 0
 629 0046 DF91      		pop r29
 630 0048 CF91      		pop r28
 631               	.LVL43:
 632 004a 0895      		ret
 633               		.cfi_endproc
 634               	.LFE17:
 636               		.section	.text.matrix_slave_scan,"ax",@progbits
 637               	.global	matrix_slave_scan
 639               	matrix_slave_scan:
 640               	.LFB20:
 264:keyboards/lily58/rev1/matrix.c ****     _matrix_scan();
 641               		.loc 1 264 0
 642               		.cfi_startproc
 643               	/* prologue: function */
 644               	/* frame size = 0 */
 645               	/* stack size = 0 */
 646               	.L__stack_usage = 0
 265:keyboards/lily58/rev1/matrix.c **** 
 647               		.loc 1 265 0
 648 0000 0E94 0000 		call _matrix_scan
 649               	.LVL44:
 267:keyboards/lily58/rev1/matrix.c **** 
 650               		.loc 1 267 0
 651 0004 8091 0000 		lds r24,isLeftHand
 652 0008 8111      		cpse r24,__zero_reg__
 653 000a 00C0      		rjmp .L43
 654 000c 45E0      		ldi r20,lo8(5)
 655 000e 50E0      		ldi r21,0
 656 0010 00C0      		rjmp .L40
 657               	.L43:
 658 0012 40E0      		ldi r20,0
 659 0014 50E0      		ldi r21,0
 660               	.L40:
 661               	.LVL45:
 662               	.LBB44:
 278:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 663               		.loc 1 278 0 discriminator 4
 664 0016 80E0      		ldi r24,0
 665 0018 90E0      		ldi r25,0
 666               	.LBE44:
 276:keyboards/lily58/rev1/matrix.c ****   #endif
 667               		.loc 1 276 0 discriminator 4
 668 001a 20E0      		ldi r18,0
 669               	.LVL46:
 670               	.L42:
 671               	.LBB45:
 280:keyboards/lily58/rev1/matrix.c **** 	    change = 1;
 672               		.loc 1 280 0
 673 001c DC01      		movw r26,r24
 674 001e A050      		subi r26,lo8(-(serial_slave_buffer))
 675 0020 B040      		sbci r27,hi8(-(serial_slave_buffer))
 676 0022 6C91      		ld r22,X
 677 0024 FC01      		movw r30,r24
 678 0026 E40F      		add r30,r20
 679 0028 F51F      		adc r31,r21
 680 002a E050      		subi r30,lo8(-(matrix))
 681 002c F040      		sbci r31,hi8(-(matrix))
 682 002e 3081      		ld r19,Z
 683 0030 6313      		cpse r22,r19
 281:keyboards/lily58/rev1/matrix.c ****   #endif
 684               		.loc 1 281 0
 685 0032 21E0      		ldi r18,lo8(1)
 686               	.LVL47:
 687               	.L41:
 283:keyboards/lily58/rev1/matrix.c ****     }
 688               		.loc 1 283 0 discriminator 2
 689 0034 3C93      		st X,r19
 278:keyboards/lily58/rev1/matrix.c ****   #ifdef SERIAL_USE_MULTI_TRANSACTION
 690               		.loc 1 278 0 discriminator 2
 691 0036 0196      		adiw r24,1
 692               	.LVL48:
 693 0038 8530      		cpi r24,5
 694 003a 9105      		cpc r25,__zero_reg__
 695 003c 01F4      		brne .L42
 696               	.LBE45:
 286:keyboards/lily58/rev1/matrix.c ****   #endif
 697               		.loc 1 286 0
 698 003e 8091 0000 		lds r24,slave_buffer_change_count
 699               	.LVL49:
 700 0042 280F      		add r18,r24
 701               	.LVL50:
 702 0044 2093 0000 		sts slave_buffer_change_count,r18
 703 0048 0895      		ret
 704               		.cfi_endproc
 705               	.LFE20:
 707               		.section	.text.matrix_scan,"ax",@progbits
 708               	.global	matrix_scan
 710               	matrix_scan:
 711               	.LFB18:
 203:keyboards/lily58/rev1/matrix.c ****     if (is_master) {
 712               		.loc 1 203 0
 713               		.cfi_startproc
 714 0000 CF93      		push r28
 715               	.LCFI13:
 716               		.cfi_def_cfa_offset 3
 717               		.cfi_offset 28, -2
 718 0002 DF93      		push r29
 719               	.LCFI14:
 720               		.cfi_def_cfa_offset 4
 721               		.cfi_offset 29, -3
 722               	/* prologue: function */
 723               	/* frame size = 0 */
 724               	/* stack size = 2 */
 725               	.L__stack_usage = 2
 204:keyboards/lily58/rev1/matrix.c ****         matrix_master_scan();
 726               		.loc 1 204 0
 727 0004 8091 0000 		lds r24,is_master
 728 0008 8823      		tst r24
 729 000a 01F4      		brne .+2
 730 000c 00C0      		rjmp .L46
 731               	.LBB51:
 732               	.LBB52:
 219:keyboards/lily58/rev1/matrix.c ****     int mchanged = 1;
 733               		.loc 1 219 0
 734 000e 0E94 0000 		call _matrix_scan
 735               	.LVL51:
 222:keyboards/lily58/rev1/matrix.c **** 
 736               		.loc 1 222 0
 737 0012 8091 0000 		lds r24,isLeftHand
 738 0016 8111      		cpse r24,__zero_reg__
 739 0018 00C0      		rjmp .L56
 740 001a C5E0      		ldi r28,lo8(5)
 741 001c D0E0      		ldi r29,0
 742 001e 00C0      		rjmp .L47
 743               	.L56:
 744 0020 C0E0      		ldi r28,0
 745 0022 D0E0      		ldi r29,0
 746               	.L47:
 747               	.LVL52:
 232:keyboards/lily58/rev1/matrix.c ****   #endif
 748               		.loc 1 232 0
 749 0024 C050      		subi r28,lo8(-(matrix))
 750 0026 D040      		sbci r29,hi8(-(matrix))
 751               	.LVL53:
 231:keyboards/lily58/rev1/matrix.c **** 		      &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 752               		.loc 1 231 0
 753 0028 45E0      		ldi r20,lo8(5)
 754 002a 50E0      		ldi r21,0
 755 002c BE01      		movw r22,r28
 756 002e 80E0      		ldi r24,lo8(serial_master_buffer)
 757 0030 90E0      		ldi r25,hi8(serial_master_buffer)
 758 0032 0E94 0000 		call memcmp
 759               	.LVL54:
 234:keyboards/lily58/rev1/matrix.c **** 	   &matrix[offset], SERIAL_MASTER_BUFFER_LENGTH);
 760               		.loc 1 234 0
 761 0036 25E0      		ldi r18,lo8(5)
 762 0038 FE01      		movw r30,r28
 763 003a A0E0      		ldi r26,lo8(serial_master_buffer)
 764 003c B0E0      		ldi r27,hi8(serial_master_buffer)
 765               		0:
 766 003e 0190      		ld r0,Z+
 767 0040 0D92      		st X+,r0
 768 0042 2A95      		dec r18
 769 0044 01F4      		brne 0b
 241:keyboards/lily58/rev1/matrix.c **** #endif
 770               		.loc 1 241 0
 771 0046 0E94 0000 		call serial_transaction
 772               	.LVL55:
 773 004a 892B      		or r24,r25
 774 004c 01F0      		breq .L48
 244:keyboards/lily58/rev1/matrix.c **** 
 775               		.loc 1 244 0
 776 004e 5D98      		cbi 0xb,5
 246:keyboards/lily58/rev1/matrix.c **** 
 777               		.loc 1 246 0
 778 0050 8091 0000 		lds r24,error_count
 779 0054 8F5F      		subi r24,lo8(-(1))
 780 0056 8093 0000 		sts error_count,r24
 248:keyboards/lily58/rev1/matrix.c ****             // reset other half if disconnected
 781               		.loc 1 248 0
 782 005a 8630      		cpi r24,lo8(6)
 783 005c 00F0      		brlo .L60
 784               	.LBB53:
 250:keyboards/lily58/rev1/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 785               		.loc 1 250 0
 786 005e 8091 0000 		lds r24,isLeftHand
 787 0062 8111      		cpse r24,__zero_reg__
 788 0064 00C0      		rjmp .L57
 789 0066 20E0      		ldi r18,0
 790 0068 30E0      		ldi r19,0
 791 006a 00C0      		rjmp .L51
 792               	.L57:
 793 006c 25E0      		ldi r18,lo8(5)
 794 006e 30E0      		ldi r19,0
 795               	.L51:
 796               	.LVL56:
 797               	.LBB54:
 251:keyboards/lily58/rev1/matrix.c ****                 matrix[slaveOffset+i] = 0;
 798               		.loc 1 251 0
 799 0070 80E0      		ldi r24,0
 800 0072 90E0      		ldi r25,0
 801               	.LVL57:
 802               	.L52:
 803 0074 FC01      		movw r30,r24
 804 0076 E20F      		add r30,r18
 805 0078 F31F      		adc r31,r19
 806 007a E050      		subi r30,lo8(-(matrix))
 807 007c F040      		sbci r31,hi8(-(matrix))
 252:keyboards/lily58/rev1/matrix.c ****             }
 808               		.loc 1 252 0
 809 007e 1082      		st Z,__zero_reg__
 251:keyboards/lily58/rev1/matrix.c ****                 matrix[slaveOffset+i] = 0;
 810               		.loc 1 251 0
 811 0080 0196      		adiw r24,1
 812               	.LVL58:
 813 0082 8530      		cpi r24,5
 814 0084 9105      		cpc r25,__zero_reg__
 815 0086 01F4      		brne .L52
 816 0088 00C0      		rjmp .L60
 817               	.LVL59:
 818               	.L48:
 819               	.LBE54:
 820               	.LBE53:
 257:keyboards/lily58/rev1/matrix.c ****         error_count = 0;
 821               		.loc 1 257 0
 822 008a 5D9A      		sbi 0xb,5
 258:keyboards/lily58/rev1/matrix.c ****     }
 823               		.loc 1 258 0
 824 008c 1092 0000 		sts error_count,__zero_reg__
 825 0090 00C0      		rjmp .L60
 826               	.LVL60:
 827               	.L46:
 828               	.LBE52:
 829               	.LBE51:
 830               	.LBB55:
 207:keyboards/lily58/rev1/matrix.c ****         int offset = (isLeftHand) ? ROWS_PER_HAND : 0;
 831               		.loc 1 207 0
 832 0092 0E94 0000 		call matrix_slave_scan
 833               	.LVL61:
 208:keyboards/lily58/rev1/matrix.c ****         memcpy(&matrix[offset],
 834               		.loc 1 208 0
 835 0096 8091 0000 		lds r24,isLeftHand
 836 009a 8111      		cpse r24,__zero_reg__
 837 009c 00C0      		rjmp .L58
 838 009e A0E0      		ldi r26,0
 839 00a0 B0E0      		ldi r27,0
 840 00a2 00C0      		rjmp .L55
 841               	.L58:
 842 00a4 A5E0      		ldi r26,lo8(5)
 843 00a6 B0E0      		ldi r27,0
 844               	.L55:
 845               	.LVL62:
 209:keyboards/lily58/rev1/matrix.c ****                (void *)serial_master_buffer, SERIAL_MASTER_BUFFER_LENGTH);
 846               		.loc 1 209 0 discriminator 4
 847 00a8 A050      		subi r26,lo8(-(matrix))
 848 00aa B040      		sbci r27,hi8(-(matrix))
 849               	.LVL63:
 850 00ac 85E0      		ldi r24,lo8(5)
 851 00ae E0E0      		ldi r30,lo8(serial_master_buffer)
 852 00b0 F0E0      		ldi r31,hi8(serial_master_buffer)
 853               		0:
 854 00b2 0190      		ld r0,Z+
 855 00b4 0D92      		st X+,r0
 856 00b6 8A95      		dec r24
 857 00b8 01F4      		brne 0b
 858               	.LVL64:
 859               	.L60:
 211:keyboards/lily58/rev1/matrix.c ****     }
 860               		.loc 1 211 0 discriminator 4
 861 00ba 0E94 0000 		call matrix_scan_quantum
 862               	.LVL65:
 863               	.LBE55:
 214:keyboards/lily58/rev1/matrix.c **** 
 864               		.loc 1 214 0 discriminator 4
 865 00be 81E0      		ldi r24,lo8(1)
 866               	/* epilogue start */
 867 00c0 DF91      		pop r29
 868 00c2 CF91      		pop r28
 869 00c4 0895      		ret
 870               		.cfi_endproc
 871               	.LFE18:
 873               		.section	.text.matrix_is_modified,"ax",@progbits
 874               	.global	matrix_is_modified
 876               	matrix_is_modified:
 877               	.LFB21:
 292:keyboards/lily58/rev1/matrix.c ****     if (debouncing) return false;
 878               		.loc 1 292 0
 879               		.cfi_startproc
 880               	/* prologue: function */
 881               	/* frame size = 0 */
 882               	/* stack size = 0 */
 883               	.L__stack_usage = 0
 293:keyboards/lily58/rev1/matrix.c ****     return true;
 884               		.loc 1 293 0
 885 0000 81E0      		ldi r24,lo8(1)
 886 0002 9091 0000 		lds r25,debouncing
 887 0006 9111      		cpse r25,__zero_reg__
 888 0008 80E0      		ldi r24,0
 889               	.L62:
 295:keyboards/lily58/rev1/matrix.c **** 
 890               		.loc 1 295 0
 891 000a 0895      		ret
 892               		.cfi_endproc
 893               	.LFE21:
 895               		.section	.text.matrix_is_on,"ax",@progbits
 896               	.global	matrix_is_on
 898               	matrix_is_on:
 899               	.LFB22:
 299:keyboards/lily58/rev1/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 900               		.loc 1 299 0
 901               		.cfi_startproc
 902               	.LVL66:
 903               	/* prologue: function */
 904               	/* frame size = 0 */
 905               	/* stack size = 0 */
 906               	.L__stack_usage = 0
 300:keyboards/lily58/rev1/matrix.c **** }
 907               		.loc 1 300 0
 908 0000 E82F      		mov r30,r24
 909 0002 F0E0      		ldi r31,0
 910 0004 E050      		subi r30,lo8(-(matrix))
 911 0006 F040      		sbci r31,hi8(-(matrix))
 912 0008 2081      		ld r18,Z
 913 000a 822F      		mov r24,r18
 914               	.LVL67:
 915 000c 90E0      		ldi r25,0
 916 000e 21E0      		ldi r18,lo8(1)
 917 0010 30E0      		ldi r19,0
 918 0012 00C0      		rjmp 2f
 919               		1:
 920 0014 220F      		lsl r18
 921 0016 331F      		rol r19
 922               		2:
 923 0018 6A95      		dec r22
 924 001a 02F4      		brpl 1b
 925 001c 2823      		and r18,r24
 926 001e 3923      		and r19,r25
 927 0020 81E0      		ldi r24,lo8(1)
 928 0022 232B      		or r18,r19
 929 0024 01F4      		brne .L67
 930 0026 80E0      		ldi r24,0
 931               	.L67:
 301:keyboards/lily58/rev1/matrix.c **** 
 932               		.loc 1 301 0
 933 0028 0895      		ret
 934               		.cfi_endproc
 935               	.LFE22:
 937               		.section	.text.matrix_get_row,"ax",@progbits
 938               	.global	matrix_get_row
 940               	matrix_get_row:
 941               	.LFB23:
 305:keyboards/lily58/rev1/matrix.c ****     return matrix[row];
 942               		.loc 1 305 0
 943               		.cfi_startproc
 944               	.LVL68:
 945               	/* prologue: function */
 946               	/* frame size = 0 */
 947               	/* stack size = 0 */
 948               	.L__stack_usage = 0
 306:keyboards/lily58/rev1/matrix.c **** }
 949               		.loc 1 306 0
 950 0000 E82F      		mov r30,r24
 951 0002 F0E0      		ldi r31,0
 952 0004 E050      		subi r30,lo8(-(matrix))
 953 0006 F040      		sbci r31,hi8(-(matrix))
 307:keyboards/lily58/rev1/matrix.c **** 
 954               		.loc 1 307 0
 955 0008 8081      		ld r24,Z
 956               	.LVL69:
 957 000a 0895      		ret
 958               		.cfi_endproc
 959               	.LFE23:
 961               		.section	.text.matrix_print,"ax",@progbits
 962               	.global	matrix_print
 964               	matrix_print:
 965               	.LFB24:
 310:keyboards/lily58/rev1/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 966               		.loc 1 310 0
 967               		.cfi_startproc
 968               	/* prologue: function */
 969               	/* frame size = 0 */
 970               	/* stack size = 0 */
 971               	.L__stack_usage = 0
 972               	.LVL70:
 973 0000 0895      		ret
 974               		.cfi_endproc
 975               	.LFE24:
 977               		.section	.text.matrix_key_count,"ax",@progbits
 978               	.global	matrix_key_count
 980               	matrix_key_count:
 981               	.LFB25:
 320:keyboards/lily58/rev1/matrix.c ****     uint8_t count = 0;
 982               		.loc 1 320 0
 983               		.cfi_startproc
 320:keyboards/lily58/rev1/matrix.c ****     uint8_t count = 0;
 984               		.loc 1 320 0
 985 0000 0F93      		push r16
 986               	.LCFI15:
 987               		.cfi_def_cfa_offset 3
 988               		.cfi_offset 16, -2
 989 0002 1F93      		push r17
 990               	.LCFI16:
 991               		.cfi_def_cfa_offset 4
 992               		.cfi_offset 17, -3
 993 0004 CF93      		push r28
 994               	.LCFI17:
 995               		.cfi_def_cfa_offset 5
 996               		.cfi_offset 28, -4
 997 0006 DF93      		push r29
 998               	.LCFI18:
 999               		.cfi_def_cfa_offset 6
 1000               		.cfi_offset 29, -5
 1001               	/* prologue: function */
 1002               	/* frame size = 0 */
 1003               	/* stack size = 4 */
 1004               	.L__stack_usage = 4
 1005               	.LVL71:
 320:keyboards/lily58/rev1/matrix.c ****     uint8_t count = 0;
 1006               		.loc 1 320 0
 1007 0008 C0E0      		ldi r28,lo8(matrix)
 1008 000a D0E0      		ldi r29,hi8(matrix)
 321:keyboards/lily58/rev1/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 1009               		.loc 1 321 0
 1010 000c 10E0      		ldi r17,0
 1011 000e 0C2F      		mov r16,r28
 1012 0010 065F      		subi r16,lo8(-(10))
 1013               	.LVL72:
 1014               	.L71:
 1015               	.LBB56:
 323:keyboards/lily58/rev1/matrix.c ****     }
 1016               		.loc 1 323 0 discriminator 3
 1017 0012 8991      		ld r24,Y+
 1018               	.LVL73:
 1019 0014 90E0      		ldi r25,0
 1020 0016 0E94 0000 		call bitpop16
 1021               	.LVL74:
 1022 001a 180F      		add r17,r24
 1023               	.LVL75:
 322:keyboards/lily58/rev1/matrix.c ****         count += bitpop16(matrix[i]);
 1024               		.loc 1 322 0 discriminator 3
 1025 001c 0C13      		cpse r16,r28
 1026 001e 00C0      		rjmp .L71
 1027               	.LBE56:
 326:keyboards/lily58/rev1/matrix.c **** 
 1028               		.loc 1 326 0
 1029 0020 812F      		mov r24,r17
 1030               	/* epilogue start */
 1031 0022 DF91      		pop r29
 1032 0024 CF91      		pop r28
 1033               	.LVL76:
 1034 0026 1F91      		pop r17
 1035               	.LVL77:
 1036 0028 0F91      		pop r16
 1037 002a 0895      		ret
 1038               		.cfi_endproc
 1039               	.LFE25:
 1041               		.section	.bss.matrix_debouncing,"aw",@nobits
 1044               	matrix_debouncing:
 1045 0000 0000 0000 		.zero	10
 1045      0000 0000 
 1045      0000 
 1046               		.section	.bss.matrix,"aw",@nobits
 1049               	matrix:
 1050 0000 0000 0000 		.zero	10
 1050      0000 0000 
 1050      0000 
 1051               		.section	.rodata.col_pins,"a",@progbits
 1054               	col_pins:
 1055 0000 F6        		.byte	-10
 1056 0001 F7        		.byte	-9
 1057 0002 31        		.byte	49
 1058 0003 33        		.byte	51
 1059 0004 32        		.byte	50
 1060 0005 36        		.byte	54
 1061               		.section	.rodata.row_pins,"a",@progbits
 1064               	row_pins:
 1065 0000 66        		.byte	102
 1066 0001 97        		.byte	-105
 1067 0002 C6        		.byte	-58
 1068 0003 34        		.byte	52
 1069 0004 35        		.byte	53
 1070 0005 0000 0000 		.zero	5
 1070      00
 1071               	.global	is_master
 1072               		.section	.bss.is_master,"aw",@nobits
 1075               	is_master:
 1076 0000 00        		.zero	1
 1077               		.section	.bss.error_count,"aw",@nobits
 1080               	error_count:
 1081 0000 00        		.zero	1
 1082               		.section	.data.debouncing,"aw",@progbits
 1085               	debouncing:
 1086 0000 05        		.byte	5
 1087               		.text
 1088               	.Letext0:
 1089               		.file 3 "/usr/lib/avr/include/stdint.h"
 1090               		.file 4 "/usr/lib/gcc/avr/4.9.2/include/stddef.h"
 1091               		.file 5 "tmk_core/common/debug.h"
 1092               		.file 6 "tmk_core/common/matrix.h"
 1093               		.file 7 "drivers/avr/pro_micro.h"
 1094               		.file 8 "keyboards/lily58/rev1/split_util.h"
 1095               		.file 9 "keyboards/lily58/rev1/split_scomm.h"
 1096               		.file 10 "/usr/lib/avr/include/string.h"
 1097               		.file 11 "tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc6fQ5Gm.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc6fQ5Gm.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc6fQ5Gm.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc6fQ5Gm.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc6fQ5Gm.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc6fQ5Gm.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/cc6fQ5Gm.s:1064   .rodata.row_pins:0000000000000000 row_pins
     /tmp/cc6fQ5Gm.s:72     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/cc6fQ5Gm.s:87     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/cc6fQ5Gm.s:104    .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/cc6fQ5Gm.s:119    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/cc6fQ5Gm.s:136    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc6fQ5Gm.s:153    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc6fQ5Gm.s:170    .text.matrix_init:0000000000000000 matrix_init
     /tmp/cc6fQ5Gm.s:1054   .rodata.col_pins:0000000000000000 col_pins
     /tmp/cc6fQ5Gm.s:1044   .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cc6fQ5Gm.s:1049   .bss.matrix:0000000000000000 matrix
     /tmp/cc6fQ5Gm.s:1075   .bss.is_master:0000000000000000 is_master
     /tmp/cc6fQ5Gm.s:270    .text._matrix_scan:0000000000000000 _matrix_scan
     /tmp/cc6fQ5Gm.s:1085   .data.debouncing:0000000000000000 debouncing
     /tmp/cc6fQ5Gm.s:559    .text.serial_transaction:0000000000000000 serial_transaction
     /tmp/cc6fQ5Gm.s:639    .text.matrix_slave_scan:0000000000000000 matrix_slave_scan
     /tmp/cc6fQ5Gm.s:710    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc6fQ5Gm.s:1080   .bss.error_count:0000000000000000 error_count
     /tmp/cc6fQ5Gm.s:876    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc6fQ5Gm.s:898    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc6fQ5Gm.s:940    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc6fQ5Gm.s:964    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc6fQ5Gm.s:980    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
has_usb
matrix_init_quantum
isLeftHand
serial_update_buffers
serial_slave_buffer
slave_buffer_change_count
serial_master_buffer
memcmp
matrix_scan_quantum
bitpop16
__do_copy_data
__do_clear_bss
