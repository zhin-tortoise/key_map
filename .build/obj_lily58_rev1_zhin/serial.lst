   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sync_recv,"ax",@progbits
  12               	sync_recv:
  13               	.LFB16:
  14               		.file 1 "keyboards/lily58/serial.c"
   1:keyboards/lily58/serial.c **** /*
   2:keyboards/lily58/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:keyboards/lily58/serial.c ****  *
   4:keyboards/lily58/serial.c ****  * 2018-10-28 checked
   5:keyboards/lily58/serial.c ****  *  avr-gcc 4.9.2
   6:keyboards/lily58/serial.c ****  *  avr-gcc 5.4.0
   7:keyboards/lily58/serial.c ****  *  avr-gcc 7.3.0
   8:keyboards/lily58/serial.c ****  */
   9:keyboards/lily58/serial.c **** 
  10:keyboards/lily58/serial.c **** #ifndef F_CPU
  11:keyboards/lily58/serial.c **** #define F_CPU 16000000
  12:keyboards/lily58/serial.c **** #endif
  13:keyboards/lily58/serial.c **** 
  14:keyboards/lily58/serial.c **** #include <avr/io.h>
  15:keyboards/lily58/serial.c **** #include <avr/interrupt.h>
  16:keyboards/lily58/serial.c **** #include <util/delay.h>
  17:keyboards/lily58/serial.c **** #include <stddef.h>
  18:keyboards/lily58/serial.c **** #include <stdbool.h>
  19:keyboards/lily58/serial.c **** #include "serial.h"
  20:keyboards/lily58/serial.c **** //#include <pro_micro.h>
  21:keyboards/lily58/serial.c **** 
  22:keyboards/lily58/serial.c **** #ifdef SOFT_SERIAL_PIN
  23:keyboards/lily58/serial.c **** 
  24:keyboards/lily58/serial.c **** #ifdef __AVR_ATmega32U4__
  25:keyboards/lily58/serial.c ****   // if using ATmega32U4 I2C, can not use PD0 and PD1 in soft serial.
  26:keyboards/lily58/serial.c ****   #ifdef USE_I2C
  27:keyboards/lily58/serial.c ****     #if SOFT_SERIAL_PIN == D0 || SOFT_SERIAL_PIN == D1
  28:keyboards/lily58/serial.c ****       #error Using ATmega32U4 I2C, so can not use PD0, PD1
  29:keyboards/lily58/serial.c ****     #endif
  30:keyboards/lily58/serial.c ****   #endif
  31:keyboards/lily58/serial.c **** 
  32:keyboards/lily58/serial.c ****   #if SOFT_SERIAL_PIN >= D0 && SOFT_SERIAL_PIN <= D3
  33:keyboards/lily58/serial.c ****     #define SERIAL_PIN_DDR   DDRD
  34:keyboards/lily58/serial.c ****     #define SERIAL_PIN_PORT  PORTD
  35:keyboards/lily58/serial.c ****     #define SERIAL_PIN_INPUT PIND
  36:keyboards/lily58/serial.c ****     #if SOFT_SERIAL_PIN == D0
  37:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD0)
  38:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT0)
  39:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC00) | _BV(ISC01)))
  40:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT0_vect
  41:keyboards/lily58/serial.c ****     #elif  SOFT_SERIAL_PIN == D1
  42:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD1)
  43:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT1)
  44:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC10) | _BV(ISC11)))
  45:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT1_vect
  46:keyboards/lily58/serial.c ****     #elif  SOFT_SERIAL_PIN == D2
  47:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD2)
  48:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT2)
  49:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC20) | _BV(ISC21)))
  50:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT2_vect
  51:keyboards/lily58/serial.c ****     #elif  SOFT_SERIAL_PIN == D3
  52:keyboards/lily58/serial.c ****       #define SERIAL_PIN_MASK _BV(PD3)
  53:keyboards/lily58/serial.c ****       #define EIMSK_BIT       _BV(INT3)
  54:keyboards/lily58/serial.c ****       #define EICRx_BIT       (~(_BV(ISC30) | _BV(ISC31)))
  55:keyboards/lily58/serial.c ****       #define SERIAL_PIN_INTERRUPT INT3_vect
  56:keyboards/lily58/serial.c ****     #endif
  57:keyboards/lily58/serial.c ****   #elif  SOFT_SERIAL_PIN == E6
  58:keyboards/lily58/serial.c ****     #define SERIAL_PIN_DDR   DDRE
  59:keyboards/lily58/serial.c ****     #define SERIAL_PIN_PORT  PORTE
  60:keyboards/lily58/serial.c ****     #define SERIAL_PIN_INPUT PINE
  61:keyboards/lily58/serial.c ****     #define SERIAL_PIN_MASK  _BV(PE6)
  62:keyboards/lily58/serial.c ****     #define EIMSK_BIT        _BV(INT6)
  63:keyboards/lily58/serial.c ****     #define EICRx_BIT        (~(_BV(ISC60) | _BV(ISC61)))
  64:keyboards/lily58/serial.c ****     #define SERIAL_PIN_INTERRUPT INT6_vect
  65:keyboards/lily58/serial.c ****   #else
  66:keyboards/lily58/serial.c ****   #error invalid SOFT_SERIAL_PIN value
  67:keyboards/lily58/serial.c ****   #endif
  68:keyboards/lily58/serial.c **** 
  69:keyboards/lily58/serial.c **** #else
  70:keyboards/lily58/serial.c ****  #error serial.c now support ATmega32U4 only
  71:keyboards/lily58/serial.c **** #endif
  72:keyboards/lily58/serial.c **** 
  73:keyboards/lily58/serial.c **** //////////////// for backward compatibility ////////////////////////////////
  74:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
  75:keyboards/lily58/serial.c **** /* --- USE Simple API (OLD API, compatible with let's split serial.c) */
  76:keyboards/lily58/serial.c ****   #if SERIAL_SLAVE_BUFFER_LENGTH > 0
  77:keyboards/lily58/serial.c ****   uint8_t volatile serial_slave_buffer[SERIAL_SLAVE_BUFFER_LENGTH] = {0};
  78:keyboards/lily58/serial.c ****   #endif
  79:keyboards/lily58/serial.c ****   #if SERIAL_MASTER_BUFFER_LENGTH > 0
  80:keyboards/lily58/serial.c ****   uint8_t volatile serial_master_buffer[SERIAL_MASTER_BUFFER_LENGTH] = {0};
  81:keyboards/lily58/serial.c ****   #endif
  82:keyboards/lily58/serial.c ****   uint8_t volatile status0 = 0;
  83:keyboards/lily58/serial.c **** 
  84:keyboards/lily58/serial.c **** SSTD_t transactions[] = {
  85:keyboards/lily58/serial.c ****     { (uint8_t *)&status0,
  86:keyboards/lily58/serial.c ****   #if SERIAL_MASTER_BUFFER_LENGTH > 0
  87:keyboards/lily58/serial.c ****       sizeof(serial_master_buffer), (uint8_t *)serial_master_buffer,
  88:keyboards/lily58/serial.c ****   #else
  89:keyboards/lily58/serial.c ****       0, (uint8_t *)NULL,
  90:keyboards/lily58/serial.c ****   #endif
  91:keyboards/lily58/serial.c ****   #if SERIAL_SLAVE_BUFFER_LENGTH > 0
  92:keyboards/lily58/serial.c ****       sizeof(serial_slave_buffer), (uint8_t *)serial_slave_buffer
  93:keyboards/lily58/serial.c ****   #else
  94:keyboards/lily58/serial.c ****       0, (uint8_t *)NULL,
  95:keyboards/lily58/serial.c ****   #endif
  96:keyboards/lily58/serial.c ****   }
  97:keyboards/lily58/serial.c **** };
  98:keyboards/lily58/serial.c **** 
  99:keyboards/lily58/serial.c **** void serial_master_init(void)
 100:keyboards/lily58/serial.c **** { soft_serial_initiator_init(transactions, TID_LIMIT(transactions)); }
 101:keyboards/lily58/serial.c **** 
 102:keyboards/lily58/serial.c **** void serial_slave_init(void)
 103:keyboards/lily58/serial.c **** { soft_serial_target_init(transactions, TID_LIMIT(transactions)); }
 104:keyboards/lily58/serial.c **** 
 105:keyboards/lily58/serial.c **** // 0 => no error
 106:keyboards/lily58/serial.c **** // 1 => slave did not respond
 107:keyboards/lily58/serial.c **** // 2 => checksum error
 108:keyboards/lily58/serial.c **** int serial_update_buffers()
 109:keyboards/lily58/serial.c **** {
 110:keyboards/lily58/serial.c ****     int result;
 111:keyboards/lily58/serial.c ****     result = soft_serial_transaction();
 112:keyboards/lily58/serial.c ****     return result;
 113:keyboards/lily58/serial.c **** }
 114:keyboards/lily58/serial.c **** 
 115:keyboards/lily58/serial.c **** #endif // end of Simple API (OLD API, compatible with let's split serial.c)
 116:keyboards/lily58/serial.c **** ////////////////////////////////////////////////////////////////////////////
 117:keyboards/lily58/serial.c **** 
 118:keyboards/lily58/serial.c **** #define ALWAYS_INLINE __attribute__((always_inline))
 119:keyboards/lily58/serial.c **** #define NO_INLINE __attribute__((noinline))
 120:keyboards/lily58/serial.c **** #define _delay_sub_us(x)    __builtin_avr_delay_cycles(x)
 121:keyboards/lily58/serial.c **** 
 122:keyboards/lily58/serial.c **** // parity check
 123:keyboards/lily58/serial.c **** #define ODD_PARITY 1
 124:keyboards/lily58/serial.c **** #define EVEN_PARITY 0
 125:keyboards/lily58/serial.c **** #define PARITY EVEN_PARITY
 126:keyboards/lily58/serial.c **** 
 127:keyboards/lily58/serial.c **** #ifdef SERIAL_DELAY
 128:keyboards/lily58/serial.c ****   // custom setup in config.h
 129:keyboards/lily58/serial.c ****   // #define TID_SEND_ADJUST 2
 130:keyboards/lily58/serial.c ****   // #define SERIAL_DELAY 6             // micro sec
 131:keyboards/lily58/serial.c ****   // #define READ_WRITE_START_ADJUST 30 // cycles
 132:keyboards/lily58/serial.c ****   // #define READ_WRITE_WIDTH_ADJUST 8 // cycles
 133:keyboards/lily58/serial.c **** #else
 134:keyboards/lily58/serial.c **** // ============ Standard setups ============
 135:keyboards/lily58/serial.c **** 
 136:keyboards/lily58/serial.c **** #ifndef SELECT_SOFT_SERIAL_SPEED
 137:keyboards/lily58/serial.c **** #define SELECT_SOFT_SERIAL_SPEED 1
 138:keyboards/lily58/serial.c **** //  0: about 189kbps
 139:keyboards/lily58/serial.c **** //  1: about 137kbps (default)
 140:keyboards/lily58/serial.c **** //  2: about 75kbps
 141:keyboards/lily58/serial.c **** //  3: about 39kbps
 142:keyboards/lily58/serial.c **** //  4: about 26kbps
 143:keyboards/lily58/serial.c **** //  5: about 20kbps
 144:keyboards/lily58/serial.c **** #endif
 145:keyboards/lily58/serial.c **** 
 146:keyboards/lily58/serial.c **** #if __GNUC__ < 6
 147:keyboards/lily58/serial.c ****   #define TID_SEND_ADJUST 14
 148:keyboards/lily58/serial.c **** #else
 149:keyboards/lily58/serial.c ****   #define TID_SEND_ADJUST 2
 150:keyboards/lily58/serial.c **** #endif
 151:keyboards/lily58/serial.c **** 
 152:keyboards/lily58/serial.c **** #if SELECT_SOFT_SERIAL_SPEED == 0
 153:keyboards/lily58/serial.c ****   // Very High speed
 154:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 4             // micro sec
 155:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 156:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 33 // cycles
 157:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 158:keyboards/lily58/serial.c ****   #else
 159:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 34 // cycles
 160:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 161:keyboards/lily58/serial.c ****   #endif
 162:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 1
 163:keyboards/lily58/serial.c ****   // High speed
 164:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 6             // micro sec
 165:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 166:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 30 // cycles
 167:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 168:keyboards/lily58/serial.c ****   #else
 169:keyboards/lily58/serial.c ****     #define READ_WRITE_START_ADJUST 33 // cycles
 170:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 171:keyboards/lily58/serial.c ****   #endif
 172:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 2
 173:keyboards/lily58/serial.c ****   // Middle speed
 174:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 12            // micro sec
 175:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 176:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 177:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 178:keyboards/lily58/serial.c ****   #else
 179:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 180:keyboards/lily58/serial.c ****   #endif
 181:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 3
 182:keyboards/lily58/serial.c ****   // Low speed
 183:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 24            // micro sec
 184:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 185:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 186:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 187:keyboards/lily58/serial.c ****   #else
 188:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 189:keyboards/lily58/serial.c ****   #endif
 190:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 4
 191:keyboards/lily58/serial.c ****   // Very Low speed
 192:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 36            // micro sec
 193:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 194:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 195:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 196:keyboards/lily58/serial.c ****   #else
 197:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 198:keyboards/lily58/serial.c ****   #endif
 199:keyboards/lily58/serial.c **** #elif SELECT_SOFT_SERIAL_SPEED == 5
 200:keyboards/lily58/serial.c ****   // Ultra Low speed
 201:keyboards/lily58/serial.c ****   #define SERIAL_DELAY 48            // micro sec
 202:keyboards/lily58/serial.c ****   #define READ_WRITE_START_ADJUST 30 // cycles
 203:keyboards/lily58/serial.c ****   #if __GNUC__ < 6
 204:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 3 // cycles
 205:keyboards/lily58/serial.c ****   #else
 206:keyboards/lily58/serial.c ****     #define READ_WRITE_WIDTH_ADJUST 7 // cycles
 207:keyboards/lily58/serial.c ****   #endif
 208:keyboards/lily58/serial.c **** #else
 209:keyboards/lily58/serial.c **** #error invalid SELECT_SOFT_SERIAL_SPEED value
 210:keyboards/lily58/serial.c **** #endif /* SELECT_SOFT_SERIAL_SPEED */
 211:keyboards/lily58/serial.c **** #endif /* SERIAL_DELAY */
 212:keyboards/lily58/serial.c **** 
 213:keyboards/lily58/serial.c **** #define SERIAL_DELAY_HALF1 (SERIAL_DELAY/2)
 214:keyboards/lily58/serial.c **** #define SERIAL_DELAY_HALF2 (SERIAL_DELAY - SERIAL_DELAY/2)
 215:keyboards/lily58/serial.c **** 
 216:keyboards/lily58/serial.c **** #define SLAVE_INT_WIDTH_US 1
 217:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 218:keyboards/lily58/serial.c ****   #define SLAVE_INT_RESPONSE_TIME SERIAL_DELAY
 219:keyboards/lily58/serial.c **** #else
 220:keyboards/lily58/serial.c ****   #define SLAVE_INT_ACK_WIDTH_UNIT 2
 221:keyboards/lily58/serial.c ****   #define SLAVE_INT_ACK_WIDTH 4
 222:keyboards/lily58/serial.c **** #endif
 223:keyboards/lily58/serial.c **** 
 224:keyboards/lily58/serial.c **** static SSTD_t *Transaction_table = NULL;
 225:keyboards/lily58/serial.c **** static uint8_t Transaction_table_size = 0;
 226:keyboards/lily58/serial.c **** 
 227:keyboards/lily58/serial.c **** inline static void serial_delay(void) ALWAYS_INLINE;
 228:keyboards/lily58/serial.c **** inline static
 229:keyboards/lily58/serial.c **** void serial_delay(void) {
 230:keyboards/lily58/serial.c ****   _delay_us(SERIAL_DELAY);
 231:keyboards/lily58/serial.c **** }
 232:keyboards/lily58/serial.c **** 
 233:keyboards/lily58/serial.c **** inline static void serial_delay_half1(void) ALWAYS_INLINE;
 234:keyboards/lily58/serial.c **** inline static
 235:keyboards/lily58/serial.c **** void serial_delay_half1(void) {
 236:keyboards/lily58/serial.c ****   _delay_us(SERIAL_DELAY_HALF1);
 237:keyboards/lily58/serial.c **** }
 238:keyboards/lily58/serial.c **** 
 239:keyboards/lily58/serial.c **** inline static void serial_delay_half2(void) ALWAYS_INLINE;
 240:keyboards/lily58/serial.c **** inline static
 241:keyboards/lily58/serial.c **** void serial_delay_half2(void) {
 242:keyboards/lily58/serial.c ****   _delay_us(SERIAL_DELAY_HALF2);
 243:keyboards/lily58/serial.c **** }
 244:keyboards/lily58/serial.c **** 
 245:keyboards/lily58/serial.c **** inline static void serial_output(void) ALWAYS_INLINE;
 246:keyboards/lily58/serial.c **** inline static
 247:keyboards/lily58/serial.c **** void serial_output(void) {
 248:keyboards/lily58/serial.c ****   SERIAL_PIN_DDR |= SERIAL_PIN_MASK;
 249:keyboards/lily58/serial.c **** }
 250:keyboards/lily58/serial.c **** 
 251:keyboards/lily58/serial.c **** // make the serial pin an input with pull-up resistor
 252:keyboards/lily58/serial.c **** inline static void serial_input_with_pullup(void) ALWAYS_INLINE;
 253:keyboards/lily58/serial.c **** inline static
 254:keyboards/lily58/serial.c **** void serial_input_with_pullup(void) {
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_DDR  &= ~SERIAL_PIN_MASK;
 256:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 257:keyboards/lily58/serial.c **** }
 258:keyboards/lily58/serial.c **** 
 259:keyboards/lily58/serial.c **** inline static uint8_t serial_read_pin(void) ALWAYS_INLINE;
 260:keyboards/lily58/serial.c **** inline static
 261:keyboards/lily58/serial.c **** uint8_t serial_read_pin(void) {
 262:keyboards/lily58/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
 263:keyboards/lily58/serial.c **** }
 264:keyboards/lily58/serial.c **** 
 265:keyboards/lily58/serial.c **** inline static void serial_low(void) ALWAYS_INLINE;
 266:keyboards/lily58/serial.c **** inline static
 267:keyboards/lily58/serial.c **** void serial_low(void) {
 268:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
 269:keyboards/lily58/serial.c **** }
 270:keyboards/lily58/serial.c **** 
 271:keyboards/lily58/serial.c **** inline static void serial_high(void) ALWAYS_INLINE;
 272:keyboards/lily58/serial.c **** inline static
 273:keyboards/lily58/serial.c **** void serial_high(void) {
 274:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 275:keyboards/lily58/serial.c **** }
 276:keyboards/lily58/serial.c **** 
 277:keyboards/lily58/serial.c **** void soft_serial_initiator_init(SSTD_t *sstd_table, int sstd_table_size)
 278:keyboards/lily58/serial.c **** {
 279:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 280:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 281:keyboards/lily58/serial.c ****     serial_output();
 282:keyboards/lily58/serial.c ****     serial_high();
 283:keyboards/lily58/serial.c **** }
 284:keyboards/lily58/serial.c **** 
 285:keyboards/lily58/serial.c **** void soft_serial_target_init(SSTD_t *sstd_table, int sstd_table_size)
 286:keyboards/lily58/serial.c **** {
 287:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 288:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 289:keyboards/lily58/serial.c ****     serial_input_with_pullup();
 290:keyboards/lily58/serial.c **** 
 291:keyboards/lily58/serial.c ****     // Enable INT0-INT3,INT6
 292:keyboards/lily58/serial.c ****     EIMSK |= EIMSK_BIT;
 293:keyboards/lily58/serial.c **** #if SERIAL_PIN_MASK == _BV(PE6)
 294:keyboards/lily58/serial.c ****     // Trigger on falling edge of INT6
 295:keyboards/lily58/serial.c ****     EICRB &= EICRx_BIT;
 296:keyboards/lily58/serial.c **** #else
 297:keyboards/lily58/serial.c ****     // Trigger on falling edge of INT0-INT3
 298:keyboards/lily58/serial.c ****     EICRA &= EICRx_BIT;
 299:keyboards/lily58/serial.c **** #endif
 300:keyboards/lily58/serial.c **** }
 301:keyboards/lily58/serial.c **** 
 302:keyboards/lily58/serial.c **** // Used by the sender to synchronize timing with the reciver.
 303:keyboards/lily58/serial.c **** static void sync_recv(void) NO_INLINE;
 304:keyboards/lily58/serial.c **** static
 305:keyboards/lily58/serial.c **** void sync_recv(void) {
  15               		.loc 1 305 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               		.loc 1 305 0
  23 0000 8EE1      		ldi r24,lo8(30)
  24               	.LVL1:
  25               	.L2:
  26               	.LBB124:
 306:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < SERIAL_DELAY*5 && serial_read_pin(); i++ ) {
  27               		.loc 1 306 0
  28 0002 4A9B      		sbis 0x9,2
  29 0004 00C0      		rjmp .L7
  30               	.LVL2:
  31 0006 8150      		subi r24,lo8(-(-1))
  32               	.LVL3:
  33               		.loc 1 306 0 is_stmt 0 discriminator 4
  34 0008 01F4      		brne .L2
  35               	.LVL4:
  36               	.L7:
  37               	.LBE124:
 307:keyboards/lily58/serial.c ****   }
 308:keyboards/lily58/serial.c ****   // This shouldn't hang if the target disconnects because the
 309:keyboards/lily58/serial.c ****   // serial line will float to high if the target does disconnect.
 310:keyboards/lily58/serial.c ****   while (!serial_read_pin());
  38               		.loc 1 310 0 is_stmt 1 discriminator 1
  39 000a 4A9B      		sbis 0x9,2
  40 000c 00C0      		rjmp .L7
  41               	/* epilogue start */
 311:keyboards/lily58/serial.c **** }
  42               		.loc 1 311 0
  43 000e 0895      		ret
  44               		.cfi_endproc
  45               	.LFE16:
  47               		.section	.text.sync_send,"ax",@progbits
  49               	sync_send:
  50               	.LFB17:
 312:keyboards/lily58/serial.c **** 
 313:keyboards/lily58/serial.c **** // Used by the reciver to send a synchronization signal to the sender.
 314:keyboards/lily58/serial.c **** static void sync_send(void) NO_INLINE;
 315:keyboards/lily58/serial.c **** static
 316:keyboards/lily58/serial.c **** void sync_send(void) {
  51               		.loc 1 316 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  57               	.LBB125:
  58               	.LBB126:
 268:keyboards/lily58/serial.c **** }
  59               		.loc 1 268 0
  60 0000 5A98      		cbi 0xb,2
  61               	.LVL5:
  62               	.LBE126:
  63               	.LBE125:
  64               	.LBB127:
  65               	.LBB128:
  66               	.LBB129:
  67               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  68               		.loc 2 245 0
  69 0002 80E2      		ldi r24,lo8(32)
  70 0004 8A95      	1:	dec r24
  71 0006 01F4      		brne 1b
  72               	.LBE129:
  73               	.LBE128:
  74               	.LBE127:
  75               	.LBB130:
  76               	.LBB131:
 274:keyboards/lily58/serial.c **** }
  77               		.loc 1 274 0
  78 0008 5A9A      		sbi 0xb,2
  79 000a 0895      		ret
  80               	.LBE131:
  81               	.LBE130:
  82               		.cfi_endproc
  83               	.LFE17:
  85               		.section	.text.serial_read_chunk,"ax",@progbits
  87               	serial_read_chunk:
  88               	.LFB18:
 317:keyboards/lily58/serial.c ****   serial_low();
 318:keyboards/lily58/serial.c ****   serial_delay();
 319:keyboards/lily58/serial.c ****   serial_high();
 320:keyboards/lily58/serial.c **** }
 321:keyboards/lily58/serial.c **** 
 322:keyboards/lily58/serial.c **** // Reads a byte from the serial line
 323:keyboards/lily58/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) NO_INLINE;
 324:keyboards/lily58/serial.c **** static uint8_t serial_read_chunk(uint8_t *pterrcount, uint8_t bit) {
  89               		.loc 1 324 0
  90               		.cfi_startproc
  91               	.LVL6:
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
  96 0000 FC01      		movw r30,r24
 325:keyboards/lily58/serial.c ****     uint8_t byte, i, p, pb;
 326:keyboards/lily58/serial.c **** 
 327:keyboards/lily58/serial.c ****   _delay_sub_us(READ_WRITE_START_ADJUST);
  97               		.loc 1 327 0
  98 0002 4AE0      		ldi r20,lo8(10)
  99 0004 4A95      	1:	dec r20
 100 0006 01F4      		brne 1b
 101               	.LVL7:
 328:keyboards/lily58/serial.c ****   for( i = 0, byte = 0, p = PARITY; i < bit; i++ ) {
 102               		.loc 1 328 0
 103 0008 30E0      		ldi r19,0
 104 000a 90E0      		ldi r25,0
 105 000c 80E0      		ldi r24,0
 106               	.LVL8:
 329:keyboards/lily58/serial.c ****       serial_delay_half1();   // read the middle of pulses
 330:keyboards/lily58/serial.c ****       if( serial_read_pin() ) {
 331:keyboards/lily58/serial.c ****           byte = (byte << 1) | 1; p ^= 1;
 107               		.loc 1 331 0
 108 000e 21E0      		ldi r18,lo8(1)
 109               	.LVL9:
 110               	.L13:
 328:keyboards/lily58/serial.c ****   for( i = 0, byte = 0, p = PARITY; i < bit; i++ ) {
 111               		.loc 1 328 0 discriminator 1
 112 0010 9617      		cp r25,r22
 113 0012 01F0      		breq .L17
 114               	.LVL10:
 115               	.LBB132:
 116               	.LBB133:
 117               	.LBB134:
 118               		.loc 2 245 0
 119 0014 40E1      		ldi r20,lo8(16)
 120 0016 4A95      	1:	dec r20
 121 0018 01F4      		brne 1b
 122               	.LBE134:
 123               	.LBE133:
 124               	.LBE132:
 125               		.loc 1 331 0
 126 001a 880F      		lsl r24
 127               	.LVL11:
 330:keyboards/lily58/serial.c ****           byte = (byte << 1) | 1; p ^= 1;
 128               		.loc 1 330 0
 129 001c 4A9B      		sbis 0x9,2
 130 001e 00C0      		rjmp .L15
 131               		.loc 1 331 0
 132 0020 8160      		ori r24,lo8(1)
 133               	.LVL12:
 134 0022 3227      		eor r19,r18
 135               	.LVL13:
 136               	.L15:
 332:keyboards/lily58/serial.c ****       } else {
 333:keyboards/lily58/serial.c ****           byte = (byte << 1) | 0; p ^= 0;
 334:keyboards/lily58/serial.c ****       }
 335:keyboards/lily58/serial.c ****       _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 137               		.loc 1 335 0 discriminator 2
 138 0024 00C0      		rjmp .
 139 0026 0000      		nop
 140               	.LVL14:
 141               	.LBB135:
 142               	.LBB136:
 143               	.LBB137:
 144               		.loc 2 245 0 discriminator 2
 145 0028 40E1      		ldi r20,lo8(16)
 146 002a 4A95      	1:	dec r20
 147 002c 01F4      		brne 1b
 148               	.LBE137:
 149               	.LBE136:
 150               	.LBE135:
 328:keyboards/lily58/serial.c ****       serial_delay_half1();   // read the middle of pulses
 151               		.loc 1 328 0 discriminator 2
 152 002e 9F5F      		subi r25,lo8(-(1))
 153               	.LVL15:
 154 0030 00C0      		rjmp .L13
 155               	.LVL16:
 156               	.L17:
 157               	.LBB138:
 158               	.LBB139:
 159               	.LBB140:
 160               		.loc 2 245 0
 161 0032 90E1      		ldi r25,lo8(16)
 162 0034 9A95      	1:	dec r25
 163 0036 01F4      		brne 1b
 164               	.LVL17:
 165               	.LBE140:
 166               	.LBE139:
 167               	.LBE138:
 168               	.LBB141:
 169               	.LBB142:
 262:keyboards/lily58/serial.c **** }
 170               		.loc 1 262 0
 171 0038 29B1      		in r18,0x9
 172               	.LBE142:
 173               	.LBE141:
 336:keyboards/lily58/serial.c ****       serial_delay_half2();
 337:keyboards/lily58/serial.c ****   }
 338:keyboards/lily58/serial.c ****   /* recive parity bit */
 339:keyboards/lily58/serial.c ****   serial_delay_half1();   // read the middle of pulses
 340:keyboards/lily58/serial.c ****   pb = serial_read_pin();
 341:keyboards/lily58/serial.c ****   _delay_sub_us(READ_WRITE_WIDTH_ADJUST);
 174               		.loc 1 341 0
 175 003a 00C0      		rjmp .
 176 003c 0000      		nop
 177               	.LVL18:
 178               	.LBB144:
 179               	.LBB145:
 180               	.LBB146:
 181               		.loc 2 245 0
 182 003e 40E1      		ldi r20,lo8(16)
 183 0040 4A95      	1:	dec r20
 184 0042 01F4      		brne 1b
 185               	.LBE146:
 186               	.LBE145:
 187               	.LBE144:
 188               	.LBB147:
 189               	.LBB143:
 262:keyboards/lily58/serial.c **** }
 190               		.loc 1 262 0
 191 0044 22FB      		bst r18,2
 192 0046 9927      		clr r25
 193 0048 90F9      		bld r25,0
 194 004a 9327      		eor r25,r19
 195               	.LBE143:
 196               	.LBE147:
 342:keyboards/lily58/serial.c ****   serial_delay_half2();
 343:keyboards/lily58/serial.c **** 
 344:keyboards/lily58/serial.c ****   *pterrcount += (p != pb)? 1 : 0;
 197               		.loc 1 344 0
 198 004c 2081      		ld r18,Z
 199 004e 920F      		add r25,r18
 200 0050 9083      		st Z,r25
 345:keyboards/lily58/serial.c **** 
 346:keyboards/lily58/serial.c ****   return byte;
 347:keyboards/lily58/serial.c **** }
 201               		.loc 1 347 0
 202 0052 0895      		ret
 203               		.cfi_endproc
 204               	.LFE18:
 206               		.section	.text.serial_recive_packet,"ax",@progbits
 208               	serial_recive_packet:
 209               	.LFB21:
 348:keyboards/lily58/serial.c **** 
 349:keyboards/lily58/serial.c **** // Sends a byte with MSB ordering
 350:keyboards/lily58/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) NO_INLINE;
 351:keyboards/lily58/serial.c **** void serial_write_chunk(uint8_t data, uint8_t bit) {
 352:keyboards/lily58/serial.c ****     uint8_t b, p;
 353:keyboards/lily58/serial.c ****     for( p = PARITY, b = 1<<(bit-1); b ; b >>= 1) {
 354:keyboards/lily58/serial.c ****         if(data & b) {
 355:keyboards/lily58/serial.c ****             serial_high(); p ^= 1;
 356:keyboards/lily58/serial.c ****         } else {
 357:keyboards/lily58/serial.c ****             serial_low();  p ^= 0;
 358:keyboards/lily58/serial.c ****         }
 359:keyboards/lily58/serial.c ****         serial_delay();
 360:keyboards/lily58/serial.c ****     }
 361:keyboards/lily58/serial.c ****     /* send parity bit */
 362:keyboards/lily58/serial.c ****     if(p & 1) { serial_high(); }
 363:keyboards/lily58/serial.c ****     else      { serial_low(); }
 364:keyboards/lily58/serial.c ****     serial_delay();
 365:keyboards/lily58/serial.c **** 
 366:keyboards/lily58/serial.c ****     serial_low(); // sync_send() / senc_recv() need raise edge
 367:keyboards/lily58/serial.c **** }
 368:keyboards/lily58/serial.c **** 
 369:keyboards/lily58/serial.c **** static void serial_send_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 370:keyboards/lily58/serial.c **** static
 371:keyboards/lily58/serial.c **** void serial_send_packet(uint8_t *buffer, uint8_t size) {
 372:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < size; ++i) {
 373:keyboards/lily58/serial.c ****     uint8_t data;
 374:keyboards/lily58/serial.c ****     data = buffer[i];
 375:keyboards/lily58/serial.c ****     sync_send();
 376:keyboards/lily58/serial.c ****     serial_write_chunk(data,8);
 377:keyboards/lily58/serial.c ****   }
 378:keyboards/lily58/serial.c **** }
 379:keyboards/lily58/serial.c **** 
 380:keyboards/lily58/serial.c **** static uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) NO_INLINE;
 381:keyboards/lily58/serial.c **** static
 382:keyboards/lily58/serial.c **** uint8_t serial_recive_packet(uint8_t *buffer, uint8_t size) {
 210               		.loc 1 382 0
 211               		.cfi_startproc
 212               	.LVL19:
 213 0000 EF92      		push r14
 214               	.LCFI0:
 215               		.cfi_def_cfa_offset 3
 216               		.cfi_offset 14, -2
 217 0002 FF92      		push r15
 218               	.LCFI1:
 219               		.cfi_def_cfa_offset 4
 220               		.cfi_offset 15, -3
 221 0004 0F93      		push r16
 222               	.LCFI2:
 223               		.cfi_def_cfa_offset 5
 224               		.cfi_offset 16, -4
 225 0006 1F93      		push r17
 226               	.LCFI3:
 227               		.cfi_def_cfa_offset 6
 228               		.cfi_offset 17, -5
 229 0008 CF93      		push r28
 230               	.LCFI4:
 231               		.cfi_def_cfa_offset 7
 232               		.cfi_offset 28, -6
 233 000a DF93      		push r29
 234               	.LCFI5:
 235               		.cfi_def_cfa_offset 8
 236               		.cfi_offset 29, -7
 237 000c 1F92      		push __zero_reg__
 238               	.LCFI6:
 239               		.cfi_def_cfa_offset 9
 240 000e CDB7      		in r28,__SP_L__
 241 0010 DEB7      		in r29,__SP_H__
 242               	.LCFI7:
 243               		.cfi_def_cfa_register 28
 244               	/* prologue: function */
 245               	/* frame size = 1 */
 246               	/* stack size = 7 */
 247               	.L__stack_usage = 7
 248 0012 F62E      		mov r15,r22
 383:keyboards/lily58/serial.c ****   uint8_t pecount = 0;
 249               		.loc 1 383 0
 250 0014 1982      		std Y+1,__zero_reg__
 251               	.LVL20:
 252 0016 E82E      		mov r14,r24
 253               	.LBB148:
 384:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < size; ++i) {
 254               		.loc 1 384 0
 255 0018 8C01      		movw r16,r24
 256               	.LVL21:
 257               	.L19:
 258 001a 802F      		mov r24,r16
 259 001c 8E19      		sub r24,r14
 260               		.loc 1 384 0 is_stmt 0 discriminator 1
 261 001e 8F15      		cp r24,r15
 262 0020 00F4      		brsh .L25
 263               	.LBB149:
 385:keyboards/lily58/serial.c ****     uint8_t data;
 386:keyboards/lily58/serial.c ****     sync_recv();
 264               		.loc 1 386 0 is_stmt 1 discriminator 3
 265 0022 0E94 0000 		call sync_recv
 266               	.LVL22:
 387:keyboards/lily58/serial.c ****     data = serial_read_chunk(&pecount, 8);
 267               		.loc 1 387 0 discriminator 3
 268 0026 68E0      		ldi r22,lo8(8)
 269 0028 CE01      		movw r24,r28
 270 002a 0196      		adiw r24,1
 271 002c 0E94 0000 		call serial_read_chunk
 272               	.LVL23:
 388:keyboards/lily58/serial.c ****     buffer[i] = data;
 273               		.loc 1 388 0 discriminator 3
 274 0030 F801      		movw r30,r16
 275 0032 8193      		st Z+,r24
 276 0034 8F01      		movw r16,r30
 277               	.LVL24:
 278 0036 00C0      		rjmp .L19
 279               	.LVL25:
 280               	.L25:
 281               	.LBE149:
 282               	.LBE148:
 389:keyboards/lily58/serial.c ****   }
 390:keyboards/lily58/serial.c ****   return pecount == 0;
 283               		.loc 1 390 0
 284 0038 81E0      		ldi r24,lo8(1)
 285 003a 9981      		ldd r25,Y+1
 286 003c 9111      		cpse r25,__zero_reg__
 287 003e 80E0      		ldi r24,0
 288               	.L21:
 289               	/* epilogue start */
 391:keyboards/lily58/serial.c **** }
 290               		.loc 1 391 0
 291 0040 0F90      		pop __tmp_reg__
 292 0042 DF91      		pop r29
 293 0044 CF91      		pop r28
 294 0046 1F91      		pop r17
 295 0048 0F91      		pop r16
 296               	.LVL26:
 297 004a FF90      		pop r15
 298               	.LVL27:
 299 004c EF90      		pop r14
 300 004e 0895      		ret
 301               		.cfi_endproc
 302               	.LFE21:
 304               		.section	.text.soft_serial_initiator_init,"ax",@progbits
 305               	.global	soft_serial_initiator_init
 307               	soft_serial_initiator_init:
 308               	.LFB14:
 278:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 309               		.loc 1 278 0
 310               		.cfi_startproc
 311               	.LVL28:
 312               	/* prologue: function */
 313               	/* frame size = 0 */
 314               	/* stack size = 0 */
 315               	.L__stack_usage = 0
 279:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 316               		.loc 1 279 0
 317 0000 9093 0000 		sts Transaction_table+1,r25
 318 0004 8093 0000 		sts Transaction_table,r24
 280:keyboards/lily58/serial.c ****     serial_output();
 319               		.loc 1 280 0
 320 0008 6093 0000 		sts Transaction_table_size,r22
 321               	.LBB150:
 322               	.LBB151:
 248:keyboards/lily58/serial.c **** }
 323               		.loc 1 248 0
 324 000c 529A      		sbi 0xa,2
 325               	.LBE151:
 326               	.LBE150:
 327               	.LBB152:
 328               	.LBB153:
 274:keyboards/lily58/serial.c **** }
 329               		.loc 1 274 0
 330 000e 5A9A      		sbi 0xb,2
 331 0010 0895      		ret
 332               	.LBE153:
 333               	.LBE152:
 334               		.cfi_endproc
 335               	.LFE14:
 337               		.section	.text.soft_serial_target_init,"ax",@progbits
 338               	.global	soft_serial_target_init
 340               	soft_serial_target_init:
 341               	.LFB15:
 286:keyboards/lily58/serial.c ****     Transaction_table = sstd_table;
 342               		.loc 1 286 0
 343               		.cfi_startproc
 344               	.LVL29:
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 0 */
 348               	.L__stack_usage = 0
 287:keyboards/lily58/serial.c ****     Transaction_table_size = (uint8_t)sstd_table_size;
 349               		.loc 1 287 0
 350 0000 9093 0000 		sts Transaction_table+1,r25
 351 0004 8093 0000 		sts Transaction_table,r24
 288:keyboards/lily58/serial.c ****     serial_input_with_pullup();
 352               		.loc 1 288 0
 353 0008 6093 0000 		sts Transaction_table_size,r22
 354               	.LBB154:
 355               	.LBB155:
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 356               		.loc 1 255 0
 357 000c 5298      		cbi 0xa,2
 256:keyboards/lily58/serial.c **** }
 358               		.loc 1 256 0
 359 000e 5A9A      		sbi 0xb,2
 360               	.LBE155:
 361               	.LBE154:
 292:keyboards/lily58/serial.c **** #if SERIAL_PIN_MASK == _BV(PE6)
 362               		.loc 1 292 0
 363 0010 EA9A      		sbi 0x1d,2
 298:keyboards/lily58/serial.c **** #endif
 364               		.loc 1 298 0
 365 0012 E9E6      		ldi r30,lo8(105)
 366 0014 F0E0      		ldi r31,0
 367 0016 8081      		ld r24,Z
 368               	.LVL30:
 369 0018 8F7C      		andi r24,lo8(-49)
 370 001a 8083      		st Z,r24
 371               	.LVL31:
 372 001c 0895      		ret
 373               		.cfi_endproc
 374               	.LFE15:
 376               		.section	.text.serial_write_chunk,"ax",@progbits
 377               	.global	serial_write_chunk
 379               	serial_write_chunk:
 380               	.LFB19:
 351:keyboards/lily58/serial.c ****     uint8_t b, p;
 381               		.loc 1 351 0
 382               		.cfi_startproc
 383               	.LVL32:
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 0 */
 387               	.L__stack_usage = 0
 353:keyboards/lily58/serial.c ****         if(data & b) {
 388               		.loc 1 353 0
 389 0000 6150      		subi r22,lo8(-(-1))
 390               	.LVL33:
 391 0002 91E0      		ldi r25,lo8(1)
 392 0004 00C0      		rjmp 2f
 393               		1:
 394 0006 990F      		lsl r25
 395               		2:
 396 0008 6A95      		dec r22
 397 000a 02F4      		brpl 1b
 398               	.LVL34:
 399 000c 20E0      		ldi r18,0
 355:keyboards/lily58/serial.c ****         } else {
 400               		.loc 1 355 0
 401 000e 31E0      		ldi r19,lo8(1)
 402               	.LVL35:
 403               	.L29:
 353:keyboards/lily58/serial.c ****         if(data & b) {
 404               		.loc 1 353 0 discriminator 1
 405 0010 9923      		tst r25
 406 0012 01F0      		breq .L35
 354:keyboards/lily58/serial.c ****             serial_high(); p ^= 1;
 407               		.loc 1 354 0
 408 0014 492F      		mov r20,r25
 409 0016 4823      		and r20,r24
 410 0018 01F0      		breq .L30
 411               	.LBB156:
 412               	.LBB157:
 274:keyboards/lily58/serial.c **** }
 413               		.loc 1 274 0
 414 001a 5A9A      		sbi 0xb,2
 415               	.LBE157:
 416               	.LBE156:
 355:keyboards/lily58/serial.c ****         } else {
 417               		.loc 1 355 0
 418 001c 2327      		eor r18,r19
 419               	.LVL36:
 420 001e 00C0      		rjmp .L31
 421               	.L30:
 422               	.LBB158:
 423               	.LBB159:
 268:keyboards/lily58/serial.c **** }
 424               		.loc 1 268 0
 425 0020 5A98      		cbi 0xb,2
 426               	.L31:
 427               	.LVL37:
 428               	.LBE159:
 429               	.LBE158:
 430               	.LBB160:
 431               	.LBB161:
 432               	.LBB162:
 433               		.loc 2 245 0 discriminator 2
 434 0022 40E2      		ldi r20,lo8(32)
 435 0024 4A95      	1:	dec r20
 436 0026 01F4      		brne 1b
 437               	.LBE162:
 438               	.LBE161:
 439               	.LBE160:
 353:keyboards/lily58/serial.c ****         if(data & b) {
 440               		.loc 1 353 0 discriminator 2
 441 0028 9695      		lsr r25
 442               	.LVL38:
 443 002a 00C0      		rjmp .L29
 444               	.LVL39:
 445               	.L35:
 362:keyboards/lily58/serial.c ****     else      { serial_low(); }
 446               		.loc 1 362 0
 447 002c 2223      		tst r18
 448 002e 01F0      		breq .L33
 449               	.LBB163:
 450               	.LBB164:
 274:keyboards/lily58/serial.c **** }
 451               		.loc 1 274 0
 452 0030 5A9A      		sbi 0xb,2
 453 0032 00C0      		rjmp .L34
 454               	.L33:
 455               	.LBE164:
 456               	.LBE163:
 457               	.LBB165:
 458               	.LBB166:
 268:keyboards/lily58/serial.c **** }
 459               		.loc 1 268 0
 460 0034 5A98      		cbi 0xb,2
 461               	.L34:
 462               	.LVL40:
 463               	.LBE166:
 464               	.LBE165:
 465               	.LBB167:
 466               	.LBB168:
 467               	.LBB169:
 468               		.loc 2 245 0
 469 0036 80E2      		ldi r24,lo8(32)
 470 0038 8A95      	1:	dec r24
 471 003a 01F4      		brne 1b
 472               	.LVL41:
 473               	.LBE169:
 474               	.LBE168:
 475               	.LBE167:
 476               	.LBB170:
 477               	.LBB171:
 268:keyboards/lily58/serial.c **** }
 478               		.loc 1 268 0
 479 003c 5A98      		cbi 0xb,2
 480 003e 0895      		ret
 481               	.LBE171:
 482               	.LBE170:
 483               		.cfi_endproc
 484               	.LFE19:
 486               		.section	.text.serial_send_packet,"ax",@progbits
 488               	serial_send_packet:
 489               	.LFB20:
 371:keyboards/lily58/serial.c ****   for (uint8_t i = 0; i < size; ++i) {
 490               		.loc 1 371 0
 491               		.cfi_startproc
 492               	.LVL42:
 493 0000 EF92      		push r14
 494               	.LCFI8:
 495               		.cfi_def_cfa_offset 3
 496               		.cfi_offset 14, -2
 497 0002 FF92      		push r15
 498               	.LCFI9:
 499               		.cfi_def_cfa_offset 4
 500               		.cfi_offset 15, -3
 501 0004 0F93      		push r16
 502               	.LCFI10:
 503               		.cfi_def_cfa_offset 5
 504               		.cfi_offset 16, -4
 505 0006 1F93      		push r17
 506               	.LCFI11:
 507               		.cfi_def_cfa_offset 6
 508               		.cfi_offset 17, -5
 509 0008 CF93      		push r28
 510               	.LCFI12:
 511               		.cfi_def_cfa_offset 7
 512               		.cfi_offset 28, -6
 513 000a DF93      		push r29
 514               	.LCFI13:
 515               		.cfi_def_cfa_offset 8
 516               		.cfi_offset 29, -7
 517 000c 1F92      		push __zero_reg__
 518               	.LCFI14:
 519               		.cfi_def_cfa_offset 9
 520 000e CDB7      		in r28,__SP_L__
 521 0010 DEB7      		in r29,__SP_H__
 522               	.LCFI15:
 523               		.cfi_def_cfa_register 28
 524               	/* prologue: function */
 525               	/* frame size = 1 */
 526               	/* stack size = 7 */
 527               	.L__stack_usage = 7
 528 0012 162F      		mov r17,r22
 529               	.LVL43:
 530 0014 082F      		mov r16,r24
 531               	.LBB172:
 372:keyboards/lily58/serial.c ****     uint8_t data;
 532               		.loc 1 372 0
 533 0016 7C01      		movw r14,r24
 534               	.LVL44:
 535               	.L37:
 536 0018 8E2D      		mov r24,r14
 537 001a 801B      		sub r24,r16
 372:keyboards/lily58/serial.c ****     uint8_t data;
 538               		.loc 1 372 0 is_stmt 0 discriminator 1
 539 001c 8117      		cp r24,r17
 540 001e 00F4      		brsh .L39
 541               	.LBB173:
 374:keyboards/lily58/serial.c ****     sync_send();
 542               		.loc 1 374 0 is_stmt 1 discriminator 3
 543 0020 F701      		movw r30,r14
 544 0022 8191      		ld r24,Z+
 545 0024 7F01      		movw r14,r30
 546               	.LVL45:
 375:keyboards/lily58/serial.c ****     serial_write_chunk(data,8);
 547               		.loc 1 375 0 discriminator 3
 548 0026 8983      		std Y+1,r24
 549 0028 0E94 0000 		call sync_send
 550               	.LVL46:
 376:keyboards/lily58/serial.c ****   }
 551               		.loc 1 376 0 discriminator 3
 552 002c 68E0      		ldi r22,lo8(8)
 553 002e 8981      		ldd r24,Y+1
 554 0030 0E94 0000 		call serial_write_chunk
 555               	.LVL47:
 556 0034 00C0      		rjmp .L37
 557               	.L39:
 558               	/* epilogue start */
 559               	.LBE173:
 560               	.LBE172:
 378:keyboards/lily58/serial.c **** 
 561               		.loc 1 378 0
 562 0036 0F90      		pop __tmp_reg__
 563 0038 DF91      		pop r29
 564 003a CF91      		pop r28
 565 003c 1F91      		pop r17
 566               	.LVL48:
 567 003e 0F91      		pop r16
 568 0040 FF90      		pop r15
 569 0042 EF90      		pop r14
 570               	.LVL49:
 571 0044 0895      		ret
 572               		.cfi_endproc
 573               	.LFE20:
 575               		.section	.text.__vector_3,"ax",@progbits
 576               	.global	__vector_3
 578               	__vector_3:
 579               	.LFB25:
 392:keyboards/lily58/serial.c **** 
 393:keyboards/lily58/serial.c **** inline static
 394:keyboards/lily58/serial.c **** void change_sender2reciver(void) {
 395:keyboards/lily58/serial.c ****     sync_send();          //0
 396:keyboards/lily58/serial.c ****     serial_delay_half1(); //1
 397:keyboards/lily58/serial.c ****     serial_low();         //2
 398:keyboards/lily58/serial.c ****     serial_input_with_pullup(); //2
 399:keyboards/lily58/serial.c ****     serial_delay_half1(); //3
 400:keyboards/lily58/serial.c **** }
 401:keyboards/lily58/serial.c **** 
 402:keyboards/lily58/serial.c **** inline static
 403:keyboards/lily58/serial.c **** void change_reciver2sender(void) {
 404:keyboards/lily58/serial.c ****     sync_recv();     //0
 405:keyboards/lily58/serial.c ****     serial_delay();  //1
 406:keyboards/lily58/serial.c ****     serial_low();    //3
 407:keyboards/lily58/serial.c ****     serial_output(); //3
 408:keyboards/lily58/serial.c ****     serial_delay_half1(); //4
 409:keyboards/lily58/serial.c **** }
 410:keyboards/lily58/serial.c **** 
 411:keyboards/lily58/serial.c **** static inline uint8_t nibble_bits_count(uint8_t bits)
 412:keyboards/lily58/serial.c **** {
 413:keyboards/lily58/serial.c ****     bits = (bits & 0x5) + (bits >> 1 & 0x5);
 414:keyboards/lily58/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 415:keyboards/lily58/serial.c ****     return bits;
 416:keyboards/lily58/serial.c **** }
 417:keyboards/lily58/serial.c **** 
 418:keyboards/lily58/serial.c **** // interrupt handle to be used by the target device
 419:keyboards/lily58/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 580               		.loc 1 419 0
 581               		.cfi_startproc
 582 0000 1F92      		push r1
 583               	.LCFI16:
 584               		.cfi_def_cfa_offset 3
 585               		.cfi_offset 1, -2
 586 0002 0F92      		push r0
 587               	.LCFI17:
 588               		.cfi_def_cfa_offset 4
 589               		.cfi_offset 0, -3
 590 0004 0FB6      		in r0,__SREG__
 591 0006 0F92      		push r0
 592 0008 1124      		clr __zero_reg__
 593 000a 0F93      		push r16
 594               	.LCFI18:
 595               		.cfi_def_cfa_offset 5
 596               		.cfi_offset 16, -4
 597 000c 1F93      		push r17
 598               	.LCFI19:
 599               		.cfi_def_cfa_offset 6
 600               		.cfi_offset 17, -5
 601 000e 2F93      		push r18
 602               	.LCFI20:
 603               		.cfi_def_cfa_offset 7
 604               		.cfi_offset 18, -6
 605 0010 3F93      		push r19
 606               	.LCFI21:
 607               		.cfi_def_cfa_offset 8
 608               		.cfi_offset 19, -7
 609 0012 4F93      		push r20
 610               	.LCFI22:
 611               		.cfi_def_cfa_offset 9
 612               		.cfi_offset 20, -8
 613 0014 5F93      		push r21
 614               	.LCFI23:
 615               		.cfi_def_cfa_offset 10
 616               		.cfi_offset 21, -9
 617 0016 6F93      		push r22
 618               	.LCFI24:
 619               		.cfi_def_cfa_offset 11
 620               		.cfi_offset 22, -10
 621 0018 7F93      		push r23
 622               	.LCFI25:
 623               		.cfi_def_cfa_offset 12
 624               		.cfi_offset 23, -11
 625 001a 8F93      		push r24
 626               	.LCFI26:
 627               		.cfi_def_cfa_offset 13
 628               		.cfi_offset 24, -12
 629 001c 9F93      		push r25
 630               	.LCFI27:
 631               		.cfi_def_cfa_offset 14
 632               		.cfi_offset 25, -13
 633 001e AF93      		push r26
 634               	.LCFI28:
 635               		.cfi_def_cfa_offset 15
 636               		.cfi_offset 26, -14
 637 0020 BF93      		push r27
 638               	.LCFI29:
 639               		.cfi_def_cfa_offset 16
 640               		.cfi_offset 27, -15
 641 0022 EF93      		push r30
 642               	.LCFI30:
 643               		.cfi_def_cfa_offset 17
 644               		.cfi_offset 30, -16
 645 0024 FF93      		push r31
 646               	.LCFI31:
 647               		.cfi_def_cfa_offset 18
 648               		.cfi_offset 31, -17
 649 0026 CF93      		push r28
 650               	.LCFI32:
 651               		.cfi_def_cfa_offset 19
 652               		.cfi_offset 28, -18
 653 0028 DF93      		push r29
 654               	.LCFI33:
 655               		.cfi_def_cfa_offset 20
 656               		.cfi_offset 29, -19
 657 002a 1F92      		push __zero_reg__
 658               	.LCFI34:
 659               		.cfi_def_cfa_offset 21
 660 002c CDB7      		in r28,__SP_L__
 661 002e DEB7      		in r29,__SP_H__
 662               	.LCFI35:
 663               		.cfi_def_cfa_register 28
 664               	/* prologue: Signal */
 665               	/* frame size = 1 */
 666               	/* stack size = 20 */
 667               	.L__stack_usage = 20
 420:keyboards/lily58/serial.c **** 
 421:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 422:keyboards/lily58/serial.c ****   serial_low();
 423:keyboards/lily58/serial.c ****   serial_output();
 424:keyboards/lily58/serial.c ****   SSTD_t *trans = Transaction_table;
 425:keyboards/lily58/serial.c **** #else
 426:keyboards/lily58/serial.c ****   // recive transaction table index
 427:keyboards/lily58/serial.c ****   uint8_t tid, bits;
 428:keyboards/lily58/serial.c ****   uint8_t pecount = 0;
 668               		.loc 1 428 0
 669 0030 1982      		std Y+1,__zero_reg__
 429:keyboards/lily58/serial.c ****   sync_recv();
 670               		.loc 1 429 0
 671 0032 0E94 0000 		call sync_recv
 672               	.LVL50:
 430:keyboards/lily58/serial.c ****   bits = serial_read_chunk(&pecount,7);
 673               		.loc 1 430 0
 674 0036 67E0      		ldi r22,lo8(7)
 675 0038 CE01      		movw r24,r28
 676 003a 0196      		adiw r24,1
 677 003c 0E94 0000 		call serial_read_chunk
 678               	.LVL51:
 431:keyboards/lily58/serial.c ****   tid = bits>>3;
 679               		.loc 1 431 0
 680 0040 382F      		mov r19,r24
 681 0042 3695      		lsr r19
 682 0044 3695      		lsr r19
 683 0046 3695      		lsr r19
 684               	.LVL52:
 685               	.LBB197:
 686               	.LBB198:
 413:keyboards/lily58/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 687               		.loc 1 413 0
 688 0048 932F      		mov r25,r19
 689 004a 9695      		lsr r25
 690 004c 9570      		andi r25,lo8(5)
 691 004e 232F      		mov r18,r19
 692 0050 2570      		andi r18,lo8(5)
 693 0052 920F      		add r25,r18
 694               	.LVL53:
 414:keyboards/lily58/serial.c ****     return bits;
 695               		.loc 1 414 0
 696 0054 292F      		mov r18,r25
 697 0056 2370      		andi r18,lo8(3)
 698 0058 9695      		lsr r25
 699 005a 9695      		lsr r25
 700               	.LVL54:
 701               	.LBE198:
 702               	.LBE197:
 432:keyboards/lily58/serial.c ****   bits = (bits&7) != nibble_bits_count(tid);
 703               		.loc 1 432 0
 704 005c 8770      		andi r24,lo8(7)
 705               	.LVL55:
 706               	.LBB200:
 707               	.LBB199:
 414:keyboards/lily58/serial.c ****     return bits;
 708               		.loc 1 414 0
 709 005e 920F      		add r25,r18
 710               	.LVL56:
 711               	.LBE199:
 712               	.LBE200:
 433:keyboards/lily58/serial.c ****   if( bits || pecount> 0 || tid > Transaction_table_size ) {
 713               		.loc 1 433 0
 714 0060 8913      		cpse r24,r25
 715 0062 00C0      		rjmp .L40
 716               		.loc 1 433 0 is_stmt 0 discriminator 1
 717 0064 8981      		ldd r24,Y+1
 718 0066 8111      		cpse r24,__zero_reg__
 719 0068 00C0      		rjmp .L40
 720               		.loc 1 433 0 discriminator 2
 721 006a 8091 0000 		lds r24,Transaction_table_size
 722 006e 8317      		cp r24,r19
 723 0070 00F4      		brsh .+2
 724 0072 00C0      		rjmp .L40
 725               	.LVL57:
 726               	.LBB201:
 727               	.LBB202:
 728               	.LBB203:
 729               		.loc 2 245 0 is_stmt 1
 730 0074 80E1      		ldi r24,lo8(16)
 731 0076 8A95      	1:	dec r24
 732 0078 01F4      		brne 1b
 733               	.LBE203:
 734               	.LBE202:
 735               	.LBE201:
 736               	.LBB204:
 737               	.LBB205:
 274:keyboards/lily58/serial.c **** }
 738               		.loc 1 274 0
 739 007a 5A9A      		sbi 0xb,2
 740               	.LBE205:
 741               	.LBE204:
 742               	.LBB206:
 743               	.LBB207:
 248:keyboards/lily58/serial.c **** }
 744               		.loc 1 248 0
 745 007c 529A      		sbi 0xa,2
 746               	.LBE207:
 747               	.LBE206:
 434:keyboards/lily58/serial.c ****       return;
 435:keyboards/lily58/serial.c ****   }
 436:keyboards/lily58/serial.c ****   serial_delay_half1();
 437:keyboards/lily58/serial.c **** 
 438:keyboards/lily58/serial.c ****   serial_high(); // response step1 low->high
 439:keyboards/lily58/serial.c ****   serial_output();
 440:keyboards/lily58/serial.c ****   _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT*SLAVE_INT_ACK_WIDTH);
 748               		.loc 1 440 0
 749 007e A2E0      		ldi r26,lo8(2)
 750 0080 AA95      	1:	dec r26
 751 0082 01F4      		brne 1b
 752 0084 00C0      		rjmp .
 441:keyboards/lily58/serial.c ****   SSTD_t *trans = &Transaction_table[tid];
 753               		.loc 1 441 0
 754 0086 0091 0000 		lds r16,Transaction_table
 755 008a 1091 0000 		lds r17,Transaction_table+1
 756 008e B8E0      		ldi r27,lo8(8)
 757 0090 3B9F      		mul r19,r27
 758 0092 000D      		add r16,r0
 759 0094 111D      		adc r17,r1
 760 0096 1124      		clr __zero_reg__
 761               	.LVL58:
 762               	.LBB208:
 763               	.LBB209:
 268:keyboards/lily58/serial.c **** }
 764               		.loc 1 268 0
 765 0098 5A98      		cbi 0xb,2
 766               	.LBE209:
 767               	.LBE208:
 442:keyboards/lily58/serial.c ****   serial_low(); // response step2 ack high->low
 443:keyboards/lily58/serial.c **** #endif
 444:keyboards/lily58/serial.c **** 
 445:keyboards/lily58/serial.c ****   // target send phase
 446:keyboards/lily58/serial.c ****   if( trans->target2initiator_buffer_size > 0 )
 768               		.loc 1 446 0
 769 009a F801      		movw r30,r16
 770 009c 6581      		ldd r22,Z+5
 771 009e 6623      		tst r22
 772 00a0 01F0      		breq .L42
 447:keyboards/lily58/serial.c ****       serial_send_packet((uint8_t *)trans->target2initiator_buffer,
 773               		.loc 1 447 0
 774 00a2 8681      		ldd r24,Z+6
 775 00a4 9781      		ldd r25,Z+7
 776 00a6 0E94 0000 		call serial_send_packet
 777               	.LVL59:
 778               	.L42:
 779               	.LBB210:
 780               	.LBB211:
 395:keyboards/lily58/serial.c ****     serial_delay_half1(); //1
 781               		.loc 1 395 0
 782 00aa 0E94 0000 		call sync_send
 783               	.LVL60:
 784               	.LBB212:
 785               	.LBB213:
 786               	.LBB214:
 787               		.loc 2 245 0
 788 00ae F0E1      		ldi r31,lo8(16)
 789 00b0 FA95      	1:	dec r31
 790 00b2 01F4      		brne 1b
 791               	.LBE214:
 792               	.LBE213:
 793               	.LBE212:
 794               	.LBB215:
 795               	.LBB216:
 268:keyboards/lily58/serial.c **** }
 796               		.loc 1 268 0
 797 00b4 5A98      		cbi 0xb,2
 798               	.LBE216:
 799               	.LBE215:
 800               	.LBB217:
 801               	.LBB218:
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 802               		.loc 1 255 0
 803 00b6 5298      		cbi 0xa,2
 256:keyboards/lily58/serial.c **** }
 804               		.loc 1 256 0
 805 00b8 5A9A      		sbi 0xb,2
 806               	.LVL61:
 807               	.LBE218:
 808               	.LBE217:
 809               	.LBB219:
 810               	.LBB220:
 811               	.LBB221:
 812               		.loc 2 245 0
 813 00ba 80E1      		ldi r24,lo8(16)
 814 00bc 8A95      	1:	dec r24
 815 00be 01F4      		brne 1b
 816               	.LBE221:
 817               	.LBE220:
 818               	.LBE219:
 819               	.LBE211:
 820               	.LBE210:
 448:keyboards/lily58/serial.c ****                          trans->target2initiator_buffer_size);
 449:keyboards/lily58/serial.c ****   // target switch to input
 450:keyboards/lily58/serial.c ****   change_sender2reciver();
 451:keyboards/lily58/serial.c **** 
 452:keyboards/lily58/serial.c ****   // target recive phase
 453:keyboards/lily58/serial.c ****   if( trans->initiator2target_buffer_size > 0 ) {
 821               		.loc 1 453 0
 822 00c0 D801      		movw r26,r16
 823 00c2 1296      		adiw r26,2
 824 00c4 6C91      		ld r22,X
 825 00c6 1297      		sbiw r26,2
 826 00c8 6623      		tst r22
 827 00ca 01F0      		breq .L43
 454:keyboards/lily58/serial.c ****       if (serial_recive_packet((uint8_t *)trans->initiator2target_buffer,
 828               		.loc 1 454 0
 829 00cc 1396      		adiw r26,3
 830 00ce 8D91      		ld r24,X+
 831 00d0 9C91      		ld r25,X
 832 00d2 1497      		sbiw r26,3+1
 833 00d4 0E94 0000 		call serial_recive_packet
 834               	.LVL62:
 835 00d8 D801      		movw r26,r16
 836 00da ED91      		ld r30,X+
 837 00dc FC91      		ld r31,X
 838 00de 8111      		cpse r24,__zero_reg__
 839 00e0 00C0      		rjmp .L50
 455:keyboards/lily58/serial.c ****                                trans->initiator2target_buffer_size) ) {
 456:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_ACCEPTED;
 457:keyboards/lily58/serial.c ****       } else {
 458:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_DATA_ERROR;
 840               		.loc 1 458 0
 841 00e2 82E0      		ldi r24,lo8(2)
 842 00e4 00C0      		rjmp .L51
 843               	.L43:
 459:keyboards/lily58/serial.c ****       }
 460:keyboards/lily58/serial.c ****   } else {
 461:keyboards/lily58/serial.c ****       *trans->status = TRANSACTION_ACCEPTED;
 844               		.loc 1 461 0
 845 00e6 D801      		movw r26,r16
 846 00e8 ED91      		ld r30,X+
 847 00ea FC91      		ld r31,X
 848               	.L50:
 849 00ec 88E0      		ldi r24,lo8(8)
 850               	.L51:
 851 00ee 8083      		st Z,r24
 462:keyboards/lily58/serial.c ****   }
 463:keyboards/lily58/serial.c **** 
 464:keyboards/lily58/serial.c ****   sync_recv(); //weit initiator output to high
 852               		.loc 1 464 0
 853 00f0 0E94 0000 		call sync_recv
 854               	.LVL63:
 855               	.L40:
 856               	/* epilogue start */
 465:keyboards/lily58/serial.c **** }
 857               		.loc 1 465 0
 858 00f4 0F90      		pop __tmp_reg__
 859 00f6 DF91      		pop r29
 860 00f8 CF91      		pop r28
 861 00fa FF91      		pop r31
 862 00fc EF91      		pop r30
 863 00fe BF91      		pop r27
 864 0100 AF91      		pop r26
 865 0102 9F91      		pop r25
 866 0104 8F91      		pop r24
 867 0106 7F91      		pop r23
 868 0108 6F91      		pop r22
 869 010a 5F91      		pop r21
 870 010c 4F91      		pop r20
 871 010e 3F91      		pop r19
 872 0110 2F91      		pop r18
 873 0112 1F91      		pop r17
 874 0114 0F91      		pop r16
 875 0116 0F90      		pop r0
 876 0118 0FBE      		out __SREG__,r0
 877 011a 0F90      		pop r0
 878 011c 1F90      		pop r1
 879 011e 1895      		reti
 880               		.cfi_endproc
 881               	.LFE25:
 883               		.section	.text.soft_serial_transaction,"ax",@progbits
 884               	.global	soft_serial_transaction
 886               	soft_serial_transaction:
 887               	.LFB26:
 466:keyboards/lily58/serial.c **** 
 467:keyboards/lily58/serial.c **** /////////
 468:keyboards/lily58/serial.c **** //  start transaction by initiator
 469:keyboards/lily58/serial.c **** //
 470:keyboards/lily58/serial.c **** // int  soft_serial_transaction(int sstd_index)
 471:keyboards/lily58/serial.c **** //
 472:keyboards/lily58/serial.c **** // Returns:
 473:keyboards/lily58/serial.c **** //    TRANSACTION_END
 474:keyboards/lily58/serial.c **** //    TRANSACTION_NO_RESPONSE
 475:keyboards/lily58/serial.c **** //    TRANSACTION_DATA_ERROR
 476:keyboards/lily58/serial.c **** // this code is very time dependent, so we need to disable interrupts
 477:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 478:keyboards/lily58/serial.c **** int  soft_serial_transaction(void) {
 479:keyboards/lily58/serial.c ****   SSTD_t *trans = Transaction_table;
 480:keyboards/lily58/serial.c **** #else
 481:keyboards/lily58/serial.c **** int  soft_serial_transaction(int sstd_index) {
 888               		.loc 1 481 0
 889               		.cfi_startproc
 890               	.LVL64:
 891 0000 0F93      		push r16
 892               	.LCFI36:
 893               		.cfi_def_cfa_offset 3
 894               		.cfi_offset 16, -2
 895 0002 1F93      		push r17
 896               	.LCFI37:
 897               		.cfi_def_cfa_offset 4
 898               		.cfi_offset 17, -3
 899 0004 CF93      		push r28
 900               	.LCFI38:
 901               		.cfi_def_cfa_offset 5
 902               		.cfi_offset 28, -4
 903 0006 DF93      		push r29
 904               	.LCFI39:
 905               		.cfi_def_cfa_offset 6
 906               		.cfi_offset 29, -5
 907               	/* prologue: function */
 908               	/* frame size = 0 */
 909               	/* stack size = 4 */
 910               	.L__stack_usage = 4
 482:keyboards/lily58/serial.c ****   if( sstd_index > Transaction_table_size )
 911               		.loc 1 482 0
 912 0008 2091 0000 		lds r18,Transaction_table_size
 913 000c 30E0      		ldi r19,0
 914 000e 2817      		cp r18,r24
 915 0010 3907      		cpc r19,r25
 916 0012 04F4      		brge .+2
 917 0014 00C0      		rjmp .L61
 483:keyboards/lily58/serial.c ****       return TRANSACTION_TYPE_ERROR;
 484:keyboards/lily58/serial.c ****   SSTD_t *trans = &Transaction_table[sstd_index];
 918               		.loc 1 484 0
 919 0016 9C01      		movw r18,r24
 920 0018 93E0      		ldi r25,3
 921               		1:
 922 001a 220F      		lsl r18
 923 001c 331F      		rol r19
 924 001e 9A95      		dec r25
 925 0020 01F4      		brne 1b
 926 0022 C091 0000 		lds r28,Transaction_table
 927 0026 D091 0000 		lds r29,Transaction_table+1
 928 002a C20F      		add r28,r18
 929 002c D31F      		adc r29,r19
 930               	.LVL65:
 485:keyboards/lily58/serial.c **** #endif
 486:keyboards/lily58/serial.c ****   cli();
 931               		.loc 1 486 0
 932               	/* #APP */
 933               	 ;  486 "keyboards/lily58/serial.c" 1
 934 002e F894      		cli
 935               	 ;  0 "" 2
 936               	/* #NOAPP */
 937               	.LBB260:
 938               	.LBB261:
 248:keyboards/lily58/serial.c **** }
 939               		.loc 1 248 0
 940 0030 529A      		sbi 0xa,2
 941               	.LBE261:
 942               	.LBE260:
 943               	.LBB262:
 944               	.LBB263:
 268:keyboards/lily58/serial.c **** }
 945               		.loc 1 268 0
 946 0032 5A98      		cbi 0xb,2
 947               	.LVL66:
 948               	.LBE263:
 949               	.LBE262:
 950               	.LBB264:
 951               	.LBB265:
 952               		.loc 2 245 0
 953 0034 45E0      		ldi r20,lo8(5)
 954 0036 4A95      	1:	dec r20
 955 0038 01F4      		brne 1b
 956 003a 0000      		nop
 957               	.LVL67:
 958               	.LBE265:
 959               	.LBE264:
 960               	.LBB266:
 961               	.LBB267:
 413:keyboards/lily58/serial.c ****     bits = (bits & 0x3) + (bits >> 2 & 0x3);
 962               		.loc 1 413 0
 963 003c 982F      		mov r25,r24
 964 003e 9695      		lsr r25
 965 0040 9570      		andi r25,lo8(5)
 966 0042 8570      		andi r24,lo8(5)
 967               	.LVL68:
 968 0044 890F      		add r24,r25
 969               	.LVL69:
 414:keyboards/lily58/serial.c ****     return bits;
 970               		.loc 1 414 0
 971 0046 982F      		mov r25,r24
 972 0048 9370      		andi r25,lo8(3)
 973 004a 8695      		lsr r24
 974 004c 8695      		lsr r24
 975               	.LVL70:
 976 004e 890F      		add r24,r25
 977               	.LVL71:
 978               	.LBE267:
 979               	.LBE266:
 487:keyboards/lily58/serial.c **** 
 488:keyboards/lily58/serial.c ****   // signal to the target that we want to start a transaction
 489:keyboards/lily58/serial.c ****   serial_output();
 490:keyboards/lily58/serial.c ****   serial_low();
 491:keyboards/lily58/serial.c ****   _delay_us(SLAVE_INT_WIDTH_US);
 492:keyboards/lily58/serial.c **** 
 493:keyboards/lily58/serial.c **** #ifndef SERIAL_USE_MULTI_TRANSACTION
 494:keyboards/lily58/serial.c ****   // wait for the target response
 495:keyboards/lily58/serial.c ****   serial_input_with_pullup();
 496:keyboards/lily58/serial.c ****   _delay_us(SLAVE_INT_RESPONSE_TIME);
 497:keyboards/lily58/serial.c **** 
 498:keyboards/lily58/serial.c ****   // check if the target is present
 499:keyboards/lily58/serial.c ****   if (serial_read_pin()) {
 500:keyboards/lily58/serial.c ****     // target failed to pull the line low, assume not present
 501:keyboards/lily58/serial.c ****     serial_output();
 502:keyboards/lily58/serial.c ****     serial_high();
 503:keyboards/lily58/serial.c ****     *trans->status = TRANSACTION_NO_RESPONSE;
 504:keyboards/lily58/serial.c ****     sei();
 505:keyboards/lily58/serial.c ****     return TRANSACTION_NO_RESPONSE;
 506:keyboards/lily58/serial.c ****   }
 507:keyboards/lily58/serial.c **** 
 508:keyboards/lily58/serial.c **** #else
 509:keyboards/lily58/serial.c ****   // send transaction table index
 510:keyboards/lily58/serial.c ****   int tid = (sstd_index<<3) | (7 & nibble_bits_count(sstd_index));
 980               		.loc 1 510 0
 981 0050 8901      		movw r16,r18
 982 0052 082B      		or r16,r24
 511:keyboards/lily58/serial.c ****   sync_send();
 983               		.loc 1 511 0
 984 0054 0E94 0000 		call sync_send
 985               	.LVL72:
 512:keyboards/lily58/serial.c ****   _delay_sub_us(TID_SEND_ADJUST);
 986               		.loc 1 512 0
 987 0058 84E0      		ldi r24,lo8(4)
 988 005a 8A95      	1:	dec r24
 989 005c 01F4      		brne 1b
 990 005e 00C0      		rjmp .
 513:keyboards/lily58/serial.c ****   serial_write_chunk(tid, 7);
 991               		.loc 1 513 0
 992 0060 67E0      		ldi r22,lo8(7)
 993 0062 802F      		mov r24,r16
 994 0064 0E94 0000 		call serial_write_chunk
 995               	.LVL73:
 996               	.LBB268:
 997               	.LBB269:
 998               	.LBB270:
 999               		.loc 2 245 0
 1000 0068 40E1      		ldi r20,lo8(16)
 1001 006a 4A95      	1:	dec r20
 1002 006c 01F4      		brne 1b
 1003               	.LBE270:
 1004               	.LBE269:
 1005               	.LBE268:
 1006               	.LBB271:
 1007               	.LBB272:
 255:keyboards/lily58/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
 1008               		.loc 1 255 0
 1009 006e 5298      		cbi 0xa,2
 256:keyboards/lily58/serial.c **** }
 1010               		.loc 1 256 0
 1011 0070 5A9A      		sbi 0xb,2
 1012               	.L54:
 1013               	.LBE272:
 1014               	.LBE271:
 514:keyboards/lily58/serial.c ****   serial_delay_half1();
 515:keyboards/lily58/serial.c **** 
 516:keyboards/lily58/serial.c ****   // wait for the target response (step1 low->high)
 517:keyboards/lily58/serial.c ****   serial_input_with_pullup();
 518:keyboards/lily58/serial.c ****   while( !serial_read_pin() ) {
 1015               		.loc 1 518 0
 1016 0072 4A99      		sbic 0x9,2
 1017 0074 00C0      		rjmp .L68
 519:keyboards/lily58/serial.c ****       _delay_sub_us(2);
 1018               		.loc 1 519 0
 1019 0076 00C0      		rjmp .
 1020 0078 00C0      		rjmp .L54
 1021               	.L68:
 1022 007a 87E0      		ldi r24,lo8(7)
 1023 007c 90E0      		ldi r25,0
 1024               	.L56:
 1025               	.LVL74:
 1026               	.LBB273:
 520:keyboards/lily58/serial.c ****   }
 521:keyboards/lily58/serial.c **** 
 522:keyboards/lily58/serial.c ****   // check if the target is present (step2 high->low)
 523:keyboards/lily58/serial.c ****   for( int i = 0; serial_read_pin(); i++ ) {
 1027               		.loc 1 523 0 discriminator 1
 1028 007e 4A9B      		sbis 0x9,2
 1029 0080 00C0      		rjmp .L69
 1030 0082 0197      		sbiw r24,1
 1031               	.LVL75:
 524:keyboards/lily58/serial.c ****       if (i > SLAVE_INT_ACK_WIDTH + 1) {
 1032               		.loc 1 524 0
 1033 0084 01F4      		brne .L57
 1034               	.LBB274:
 1035               	.LBB275:
 248:keyboards/lily58/serial.c **** }
 1036               		.loc 1 248 0
 1037 0086 529A      		sbi 0xa,2
 1038               	.LBE275:
 1039               	.LBE274:
 1040               	.LBB276:
 1041               	.LBB277:
 274:keyboards/lily58/serial.c **** }
 1042               		.loc 1 274 0
 1043 0088 5A9A      		sbi 0xb,2
 1044               	.LBE277:
 1045               	.LBE276:
 525:keyboards/lily58/serial.c ****           // slave failed to pull the line low, assume not present
 526:keyboards/lily58/serial.c ****           serial_output();
 527:keyboards/lily58/serial.c ****           serial_high();
 528:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_NO_RESPONSE;
 1046               		.loc 1 528 0
 1047 008a E881      		ld r30,Y
 1048 008c F981      		ldd r31,Y+1
 1049 008e 81E0      		ldi r24,lo8(1)
 1050               	.LVL76:
 1051 0090 8083      		st Z,r24
 529:keyboards/lily58/serial.c ****           sei();
 1052               		.loc 1 529 0
 1053               	/* #APP */
 1054               	 ;  529 "keyboards/lily58/serial.c" 1
 1055 0092 7894      		sei
 1056               	 ;  0 "" 2
 530:keyboards/lily58/serial.c ****           return TRANSACTION_NO_RESPONSE;
 1057               		.loc 1 530 0
 1058               	/* #NOAPP */
 1059 0094 81E0      		ldi r24,lo8(1)
 1060 0096 90E0      		ldi r25,0
 1061 0098 00C0      		rjmp .L53
 1062               	.LVL77:
 1063               	.L57:
 531:keyboards/lily58/serial.c ****       }
 532:keyboards/lily58/serial.c ****       _delay_sub_us(SLAVE_INT_ACK_WIDTH_UNIT);
 1064               		.loc 1 532 0 discriminator 2
 1065 009a 00C0      		rjmp .
 1066               	.LVL78:
 1067 009c 00C0      		rjmp .L56
 1068               	.L69:
 1069               	.LBE273:
 533:keyboards/lily58/serial.c ****   }
 534:keyboards/lily58/serial.c **** #endif
 535:keyboards/lily58/serial.c **** 
 536:keyboards/lily58/serial.c ****   // initiator recive phase
 537:keyboards/lily58/serial.c ****   // if the target is present syncronize with it
 538:keyboards/lily58/serial.c ****   if( trans->target2initiator_buffer_size > 0 ) {
 1070               		.loc 1 538 0
 1071 009e 6D81      		ldd r22,Y+5
 1072 00a0 6623      		tst r22
 1073 00a2 01F0      		breq .L59
 539:keyboards/lily58/serial.c ****       if (!serial_recive_packet((uint8_t *)trans->target2initiator_buffer,
 1074               		.loc 1 539 0
 1075 00a4 8E81      		ldd r24,Y+6
 1076 00a6 9F81      		ldd r25,Y+7
 1077               	.LVL79:
 1078 00a8 0E94 0000 		call serial_recive_packet
 1079               	.LVL80:
 1080 00ac 8111      		cpse r24,__zero_reg__
 1081 00ae 00C0      		rjmp .L59
 1082               	.LBB278:
 1083               	.LBB279:
 248:keyboards/lily58/serial.c **** }
 1084               		.loc 1 248 0
 1085 00b0 529A      		sbi 0xa,2
 1086               	.LBE279:
 1087               	.LBE278:
 1088               	.LBB280:
 1089               	.LBB281:
 274:keyboards/lily58/serial.c **** }
 1090               		.loc 1 274 0
 1091 00b2 5A9A      		sbi 0xb,2
 1092               	.LBE281:
 1093               	.LBE280:
 540:keyboards/lily58/serial.c ****                                 trans->target2initiator_buffer_size) ) {
 541:keyboards/lily58/serial.c ****           serial_output();
 542:keyboards/lily58/serial.c ****           serial_high();
 543:keyboards/lily58/serial.c ****           *trans->status = TRANSACTION_DATA_ERROR;
 1094               		.loc 1 543 0
 1095 00b4 E881      		ld r30,Y
 1096 00b6 F981      		ldd r31,Y+1
 1097 00b8 82E0      		ldi r24,lo8(2)
 1098 00ba 8083      		st Z,r24
 544:keyboards/lily58/serial.c ****           sei();
 1099               		.loc 1 544 0
 1100               	/* #APP */
 1101               	 ;  544 "keyboards/lily58/serial.c" 1
 1102 00bc 7894      		sei
 1103               	 ;  0 "" 2
 545:keyboards/lily58/serial.c ****           return TRANSACTION_DATA_ERROR;
 1104               		.loc 1 545 0
 1105               	/* #NOAPP */
 1106 00be 82E0      		ldi r24,lo8(2)
 1107 00c0 90E0      		ldi r25,0
 1108 00c2 00C0      		rjmp .L53
 1109               	.L59:
 1110               	.LBB282:
 1111               	.LBB283:
 404:keyboards/lily58/serial.c ****     serial_delay();  //1
 1112               		.loc 1 404 0
 1113 00c4 0E94 0000 		call sync_recv
 1114               	.LVL81:
 1115               	.LBB284:
 1116               	.LBB285:
 1117               	.LBB286:
 1118               		.loc 2 245 0
 1119 00c8 80E2      		ldi r24,lo8(32)
 1120 00ca 8A95      	1:	dec r24
 1121 00cc 01F4      		brne 1b
 1122               	.LBE286:
 1123               	.LBE285:
 1124               	.LBE284:
 1125               	.LBB287:
 1126               	.LBB288:
 268:keyboards/lily58/serial.c **** }
 1127               		.loc 1 268 0
 1128 00ce 5A98      		cbi 0xb,2
 1129               	.LBE288:
 1130               	.LBE287:
 1131               	.LBB289:
 1132               	.LBB290:
 248:keyboards/lily58/serial.c **** }
 1133               		.loc 1 248 0
 1134 00d0 529A      		sbi 0xa,2
 1135               	.LVL82:
 1136               	.LBE290:
 1137               	.LBE289:
 1138               	.LBB291:
 1139               	.LBB292:
 1140               	.LBB293:
 1141               		.loc 2 245 0
 1142 00d2 40E1      		ldi r20,lo8(16)
 1143 00d4 4A95      	1:	dec r20
 1144 00d6 01F4      		brne 1b
 1145               	.LBE293:
 1146               	.LBE292:
 1147               	.LBE291:
 1148               	.LBE283:
 1149               	.LBE282:
 546:keyboards/lily58/serial.c ****       }
 547:keyboards/lily58/serial.c ****    }
 548:keyboards/lily58/serial.c **** 
 549:keyboards/lily58/serial.c ****   // initiator switch to output
 550:keyboards/lily58/serial.c ****   change_reciver2sender();
 551:keyboards/lily58/serial.c **** 
 552:keyboards/lily58/serial.c ****   // initiator send phase
 553:keyboards/lily58/serial.c ****   if( trans->initiator2target_buffer_size > 0 ) {
 1150               		.loc 1 553 0
 1151 00d8 6A81      		ldd r22,Y+2
 1152 00da 6623      		tst r22
 1153 00dc 01F0      		breq .L60
 554:keyboards/lily58/serial.c ****       serial_send_packet((uint8_t *)trans->initiator2target_buffer,
 1154               		.loc 1 554 0
 1155 00de 8B81      		ldd r24,Y+3
 1156 00e0 9C81      		ldd r25,Y+4
 1157 00e2 0E94 0000 		call serial_send_packet
 1158               	.LVL83:
 1159               	.L60:
 555:keyboards/lily58/serial.c ****                          trans->initiator2target_buffer_size);
 556:keyboards/lily58/serial.c ****   }
 557:keyboards/lily58/serial.c **** 
 558:keyboards/lily58/serial.c ****   // always, release the line when not in use
 559:keyboards/lily58/serial.c ****   sync_send();
 1160               		.loc 1 559 0
 1161 00e6 0E94 0000 		call sync_send
 1162               	.LVL84:
 560:keyboards/lily58/serial.c **** 
 561:keyboards/lily58/serial.c ****   *trans->status = TRANSACTION_END;
 1163               		.loc 1 561 0
 1164 00ea E881      		ld r30,Y
 1165 00ec F981      		ldd r31,Y+1
 1166 00ee 1082      		st Z,__zero_reg__
 562:keyboards/lily58/serial.c ****   sei();
 1167               		.loc 1 562 0
 1168               	/* #APP */
 1169               	 ;  562 "keyboards/lily58/serial.c" 1
 1170 00f0 7894      		sei
 1171               	 ;  0 "" 2
 563:keyboards/lily58/serial.c ****   return TRANSACTION_END;
 1172               		.loc 1 563 0
 1173               	/* #NOAPP */
 1174 00f2 80E0      		ldi r24,0
 1175 00f4 90E0      		ldi r25,0
 1176 00f6 00C0      		rjmp .L53
 1177               	.LVL85:
 1178               	.L61:
 483:keyboards/lily58/serial.c ****   SSTD_t *trans = &Transaction_table[sstd_index];
 1179               		.loc 1 483 0
 1180 00f8 84E0      		ldi r24,lo8(4)
 1181 00fa 90E0      		ldi r25,0
 1182               	.LVL86:
 1183               	.L53:
 1184               	/* epilogue start */
 564:keyboards/lily58/serial.c **** }
 1185               		.loc 1 564 0
 1186 00fc DF91      		pop r29
 1187 00fe CF91      		pop r28
 1188 0100 1F91      		pop r17
 1189 0102 0F91      		pop r16
 1190 0104 0895      		ret
 1191               		.cfi_endproc
 1192               	.LFE26:
 1194               		.section	.text.soft_serial_get_and_clean_status,"ax",@progbits
 1195               	.global	soft_serial_get_and_clean_status
 1197               	soft_serial_get_and_clean_status:
 1198               	.LFB27:
 565:keyboards/lily58/serial.c **** 
 566:keyboards/lily58/serial.c **** #ifdef SERIAL_USE_MULTI_TRANSACTION
 567:keyboards/lily58/serial.c **** int soft_serial_get_and_clean_status(int sstd_index) {
 1199               		.loc 1 567 0
 1200               		.cfi_startproc
 1201               	.LVL87:
 1202               	/* prologue: function */
 1203               	/* frame size = 0 */
 1204               	/* stack size = 0 */
 1205               	.L__stack_usage = 0
 568:keyboards/lily58/serial.c ****     SSTD_t *trans = &Transaction_table[sstd_index];
 1206               		.loc 1 568 0
 1207 0000 23E0      		ldi r18,3
 1208               		1:
 1209 0002 880F      		lsl r24
 1210 0004 991F      		rol r25
 1211 0006 2A95      		dec r18
 1212 0008 01F4      		brne 1b
 1213               	.LVL88:
 1214 000a E091 0000 		lds r30,Transaction_table
 1215 000e F091 0000 		lds r31,Transaction_table+1
 1216 0012 E80F      		add r30,r24
 1217 0014 F91F      		adc r31,r25
 1218               	.LVL89:
 569:keyboards/lily58/serial.c ****     cli();
 1219               		.loc 1 569 0
 1220               	/* #APP */
 1221               	 ;  569 "keyboards/lily58/serial.c" 1
 1222 0016 F894      		cli
 1223               	 ;  0 "" 2
 570:keyboards/lily58/serial.c ****     int retval = *trans->status;
 1224               		.loc 1 570 0
 1225               	/* #NOAPP */
 1226 0018 0190      		ld __tmp_reg__,Z+
 1227 001a F081      		ld r31,Z
 1228 001c E02D      		mov r30,__tmp_reg__
 1229               	.LVL90:
 1230 001e 8081      		ld r24,Z
 1231               	.LVL91:
 1232 0020 90E0      		ldi r25,0
 1233               	.LVL92:
 571:keyboards/lily58/serial.c ****     *trans->status = 0;;
 1234               		.loc 1 571 0
 1235 0022 1082      		st Z,__zero_reg__
 572:keyboards/lily58/serial.c ****     sei();
 1236               		.loc 1 572 0
 1237               	/* #APP */
 1238               	 ;  572 "keyboards/lily58/serial.c" 1
 1239 0024 7894      		sei
 1240               	 ;  0 "" 2
 573:keyboards/lily58/serial.c ****     return retval;
 574:keyboards/lily58/serial.c **** }
 1241               		.loc 1 574 0
 1242               	/* #NOAPP */
 1243 0026 0895      		ret
 1244               		.cfi_endproc
 1245               	.LFE27:
 1247               		.section	.bss.Transaction_table_size,"aw",@nobits
 1250               	Transaction_table_size:
 1251 0000 00        		.zero	1
 1252               		.section	.bss.Transaction_table,"aw",@nobits
 1255               	Transaction_table:
 1256 0000 0000      		.zero	2
 1257               		.text
 1258               	.Letext0:
 1259               		.file 3 "/usr/lib/avr/include/stdint.h"
 1260               		.file 4 "keyboards/lily58/serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
     /tmp/cc50FSc8.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc50FSc8.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc50FSc8.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc50FSc8.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc50FSc8.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc50FSc8.s:12     .text.sync_recv:0000000000000000 sync_recv
     /tmp/cc50FSc8.s:49     .text.sync_send:0000000000000000 sync_send
     /tmp/cc50FSc8.s:87     .text.serial_read_chunk:0000000000000000 serial_read_chunk
     /tmp/cc50FSc8.s:208    .text.serial_recive_packet:0000000000000000 serial_recive_packet
     /tmp/cc50FSc8.s:307    .text.soft_serial_initiator_init:0000000000000000 soft_serial_initiator_init
     /tmp/cc50FSc8.s:1255   .bss.Transaction_table:0000000000000000 Transaction_table
     /tmp/cc50FSc8.s:1250   .bss.Transaction_table_size:0000000000000000 Transaction_table_size
     /tmp/cc50FSc8.s:340    .text.soft_serial_target_init:0000000000000000 soft_serial_target_init
     /tmp/cc50FSc8.s:379    .text.serial_write_chunk:0000000000000000 serial_write_chunk
     /tmp/cc50FSc8.s:488    .text.serial_send_packet:0000000000000000 serial_send_packet
     /tmp/cc50FSc8.s:578    .text.__vector_3:0000000000000000 __vector_3
     /tmp/cc50FSc8.s:886    .text.soft_serial_transaction:0000000000000000 soft_serial_transaction
     /tmp/cc50FSc8.s:1197   .text.soft_serial_get_and_clean_status:0000000000000000 soft_serial_get_and_clean_status

UNDEFINED SYMBOLS
__do_clear_bss
