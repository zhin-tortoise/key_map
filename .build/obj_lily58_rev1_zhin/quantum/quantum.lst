   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB29:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** 
  19:quantum/quantum.c **** #if !defined(RGBLIGHT_ENABLE) && !defined(RGB_MATRIX_ENABLE)
  20:quantum/quantum.c **** 	#include "rgb.h"
  21:quantum/quantum.c **** #endif
  22:quantum/quantum.c **** 
  23:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  24:quantum/quantum.c **** #include "outputselect.h"
  25:quantum/quantum.c **** #endif
  26:quantum/quantum.c **** 
  27:quantum/quantum.c **** #ifndef TAPPING_TERM
  28:quantum/quantum.c **** #define TAPPING_TERM 200
  29:quantum/quantum.c **** #endif
  30:quantum/quantum.c **** 
  31:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  32:quantum/quantum.c **** #define BREATHING_PERIOD 6
  33:quantum/quantum.c **** #endif
  34:quantum/quantum.c **** 
  35:quantum/quantum.c **** #include "backlight.h"
  36:quantum/quantum.c **** extern backlight_config_t backlight_config;
  37:quantum/quantum.c **** 
  38:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  39:quantum/quantum.c **** #include "fauxclicky.h"
  40:quantum/quantum.c **** #endif
  41:quantum/quantum.c **** 
  42:quantum/quantum.c **** #ifdef API_ENABLE
  43:quantum/quantum.c **** #include "api.h"
  44:quantum/quantum.c **** #endif
  45:quantum/quantum.c **** 
  46:quantum/quantum.c **** #ifdef MIDI_ENABLE
  47:quantum/quantum.c **** #include "process_midi.h"
  48:quantum/quantum.c **** #endif
  49:quantum/quantum.c **** 
  50:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  51:quantum/quantum.c **** #include "velocikey.h"
  52:quantum/quantum.c **** #endif
  53:quantum/quantum.c **** 
  54:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  55:quantum/quantum.c ****     #include "haptic.h"
  56:quantum/quantum.c **** #endif
  57:quantum/quantum.c **** 
  58:quantum/quantum.c **** #ifdef ENCODER_ENABLE
  59:quantum/quantum.c **** #include "encoder.h"
  60:quantum/quantum.c **** #endif
  61:quantum/quantum.c **** 
  62:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  63:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  64:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  65:quantum/quantum.c ****   #endif
  66:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  67:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  68:quantum/quantum.c ****   #endif
  69:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  70:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  71:quantum/quantum.c ****   #endif
  72:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  73:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  74:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  75:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  76:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  77:quantum/quantum.c ****   #endif
  78:quantum/quantum.c **** #endif
  79:quantum/quantum.c **** 
  80:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 80 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  81:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 81 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  82:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  83:quantum/quantum.c ****     break;
  84:quantum/quantum.c ****   default:
  85:quantum/quantum.c ****     return;
  86:quantum/quantum.c ****   }
  87:quantum/quantum.c **** 
  88:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 88 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  89:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 89 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  90:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 90 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  91:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 91 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  92:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 92 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  93:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 93 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  94:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 94 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  95:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 95 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  96:quantum/quantum.c **** 
  97:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 97 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  98:quantum/quantum.c **** 
  99:quantum/quantum.c ****   if (code & QK_RCTL)
 100:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 100 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
 101:quantum/quantum.c ****   if (code & QK_RSFT)
 102:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 102 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
 103:quantum/quantum.c ****   if (code & QK_RALT)
 104:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 104 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
 105:quantum/quantum.c ****   if (code & QK_RGUI)
 106:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 106 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
 107:quantum/quantum.c **** }
 106               		.loc 1 107 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
 106:quantum/quantum.c **** }
 113               		.loc 1 106 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 107 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE29:
 127               		.section	.text.qk_register_weak_mods,"ax",@progbits
 129               	qk_register_weak_mods:
 130               	.LFB30:
 108:quantum/quantum.c **** 
 109:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 131               		.loc 1 109 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 110:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 110 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
 111:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 111 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE30:
 157               		.section	.text.qk_register_mods,"ax",@progbits
 159               	qk_register_mods:
 160               	.LFB32:
 112:quantum/quantum.c **** }
 113:quantum/quantum.c **** 
 114:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 115:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 116:quantum/quantum.c ****     send_keyboard_report();
 117:quantum/quantum.c **** }
 118:quantum/quantum.c **** 
 119:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 161               		.loc 1 119 0
 162               		.cfi_startproc
 163               	.LVL16:
 164               	/* prologue: function */
 165               	/* frame size = 0 */
 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 120:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 168               		.loc 1 120 0
 169 0000 8770      		andi r24,lo8(7)
 170               	.LVL17:
 171 0002 91E0      		ldi r25,lo8(1)
 172 0004 00C0      		rjmp 2f
 173               		1:
 174 0006 990F      		lsl r25
 175               		2:
 176 0008 8A95      		dec r24
 177 000a 02F4      		brpl 1b
 178 000c 892F      		mov r24,r25
 179 000e 0E94 0000 		call add_weak_mods
 180               	.LVL18:
 121:quantum/quantum.c ****     send_keyboard_report();
 181               		.loc 1 121 0
 182 0012 0C94 0000 		jmp send_keyboard_report
 183               	.LVL19:
 184               		.cfi_endproc
 185               	.LFE32:
 187               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 189               	qk_unregister_weak_mods:
 190               	.LFB31:
 114:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 191               		.loc 1 114 0
 192               		.cfi_startproc
 193               	.LVL20:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 115:quantum/quantum.c ****     send_keyboard_report();
 198               		.loc 1 115 0
 199 0000 8770      		andi r24,lo8(7)
 200               	.LVL21:
 201 0002 91E0      		ldi r25,lo8(1)
 202 0004 00C0      		rjmp 2f
 203               		1:
 204 0006 990F      		lsl r25
 205               		2:
 206 0008 8A95      		dec r24
 207 000a 02F4      		brpl 1b
 208 000c 892F      		mov r24,r25
 209 000e 0E94 0000 		call del_weak_mods
 210               	.LVL22:
 116:quantum/quantum.c **** }
 211               		.loc 1 116 0
 212 0012 0C94 0000 		jmp send_keyboard_report
 213               	.LVL23:
 214               		.cfi_endproc
 215               	.LFE31:
 217               		.section	.text.qk_unregister_mods,"ax",@progbits
 219               	qk_unregister_mods:
 220               	.LFB33:
 122:quantum/quantum.c **** }
 123:quantum/quantum.c **** 
 124:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 221               		.loc 1 124 0
 222               		.cfi_startproc
 223               	.LVL24:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 125:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 228               		.loc 1 125 0
 229 0000 8770      		andi r24,lo8(7)
 230               	.LVL25:
 231 0002 91E0      		ldi r25,lo8(1)
 232 0004 00C0      		rjmp 2f
 233               		1:
 234 0006 990F      		lsl r25
 235               		2:
 236 0008 8A95      		dec r24
 237 000a 02F4      		brpl 1b
 238 000c 892F      		mov r24,r25
 239 000e 0E94 0000 		call del_weak_mods
 240               	.LVL26:
 126:quantum/quantum.c ****     send_keyboard_report();
 241               		.loc 1 126 0
 242 0012 0C94 0000 		jmp send_keyboard_report
 243               	.LVL27:
 244               		.cfi_endproc
 245               	.LFE33:
 247               		.section	.text.rgblight_toggle,"ax",@progbits
 248               		.weak	rgblight_toggle
 250               	rgblight_toggle:
 251               	.LFB18:
 252               		.file 2 "quantum/rgb.h"
   1:quantum/rgb.h **** /* Copyright 2017 Jack Humbert
   2:quantum/rgb.h ****  *
   3:quantum/rgb.h ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/rgb.h ****  * it under the terms of the GNU General Public License as published by
   5:quantum/rgb.h ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/rgb.h ****  * (at your option) any later version.
   7:quantum/rgb.h ****  *
   8:quantum/rgb.h ****  * This program is distributed in the hope that it will be useful,
   9:quantum/rgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/rgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/rgb.h ****  * GNU General Public License for more details.
  12:quantum/rgb.h ****  *
  13:quantum/rgb.h ****  * You should have received a copy of the GNU General Public License
  14:quantum/rgb.h ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/rgb.h ****  */
  16:quantum/rgb.h **** 
  17:quantum/rgb.h **** #ifndef RGB_H
  18:quantum/rgb.h **** #define RGB_H
  19:quantum/rgb.h **** 
  20:quantum/rgb.h **** __attribute__((weak))
  21:quantum/rgb.h **** void rgblight_toggle(void) {};
 253               		.loc 2 21 0
 254               		.cfi_startproc
 255               	/* prologue: function */
 256               	/* frame size = 0 */
 257               	/* stack size = 0 */
 258               	.L__stack_usage = 0
 259 0000 0895      		ret
 260               		.cfi_endproc
 261               	.LFE18:
 263               		.section	.text.rgblight_step,"ax",@progbits
 264               		.weak	rgblight_step
 266               	rgblight_step:
 267               	.LFB19:
  22:quantum/rgb.h **** 
  23:quantum/rgb.h **** __attribute__((weak))
  24:quantum/rgb.h **** void rgblight_step(void) {};
 268               		.loc 2 24 0
 269               		.cfi_startproc
 270               	/* prologue: function */
 271               	/* frame size = 0 */
 272               	/* stack size = 0 */
 273               	.L__stack_usage = 0
 274 0000 0895      		ret
 275               		.cfi_endproc
 276               	.LFE19:
 278               		.section	.text.rgblight_step_reverse,"ax",@progbits
 279               		.weak	rgblight_step_reverse
 281               	rgblight_step_reverse:
 282               	.LFB20:
  25:quantum/rgb.h **** 
  26:quantum/rgb.h **** __attribute__((weak))
  27:quantum/rgb.h **** void rgblight_step_reverse(void) {};
 283               		.loc 2 27 0
 284               		.cfi_startproc
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 287               	/* stack size = 0 */
 288               	.L__stack_usage = 0
 289 0000 0895      		ret
 290               		.cfi_endproc
 291               	.LFE20:
 293               		.section	.text.rgblight_increase_hue,"ax",@progbits
 294               		.weak	rgblight_increase_hue
 296               	rgblight_increase_hue:
 297               	.LFB21:
  28:quantum/rgb.h **** 
  29:quantum/rgb.h **** __attribute__((weak))
  30:quantum/rgb.h **** void rgblight_increase_hue(void) {};
 298               		.loc 2 30 0
 299               		.cfi_startproc
 300               	/* prologue: function */
 301               	/* frame size = 0 */
 302               	/* stack size = 0 */
 303               	.L__stack_usage = 0
 304 0000 0895      		ret
 305               		.cfi_endproc
 306               	.LFE21:
 308               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 309               		.weak	rgblight_decrease_hue
 311               	rgblight_decrease_hue:
 312               	.LFB22:
  31:quantum/rgb.h **** 
  32:quantum/rgb.h **** __attribute__((weak))
  33:quantum/rgb.h **** void rgblight_decrease_hue(void) {};
 313               		.loc 2 33 0
 314               		.cfi_startproc
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 0 */
 318               	.L__stack_usage = 0
 319 0000 0895      		ret
 320               		.cfi_endproc
 321               	.LFE22:
 323               		.section	.text.rgblight_increase_sat,"ax",@progbits
 324               		.weak	rgblight_increase_sat
 326               	rgblight_increase_sat:
 327               	.LFB23:
  34:quantum/rgb.h **** 
  35:quantum/rgb.h **** __attribute__((weak))
  36:quantum/rgb.h **** void rgblight_increase_sat(void) {};
 328               		.loc 2 36 0
 329               		.cfi_startproc
 330               	/* prologue: function */
 331               	/* frame size = 0 */
 332               	/* stack size = 0 */
 333               	.L__stack_usage = 0
 334 0000 0895      		ret
 335               		.cfi_endproc
 336               	.LFE23:
 338               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 339               		.weak	rgblight_decrease_sat
 341               	rgblight_decrease_sat:
 342               	.LFB24:
  37:quantum/rgb.h **** 
  38:quantum/rgb.h **** __attribute__((weak))
  39:quantum/rgb.h **** void rgblight_decrease_sat(void) {};
 343               		.loc 2 39 0
 344               		.cfi_startproc
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 0 */
 348               	.L__stack_usage = 0
 349 0000 0895      		ret
 350               		.cfi_endproc
 351               	.LFE24:
 353               		.section	.text.rgblight_increase_val,"ax",@progbits
 354               		.weak	rgblight_increase_val
 356               	rgblight_increase_val:
 357               	.LFB25:
  40:quantum/rgb.h **** 
  41:quantum/rgb.h **** __attribute__((weak))
  42:quantum/rgb.h **** void rgblight_increase_val(void) {};
 358               		.loc 2 42 0
 359               		.cfi_startproc
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
 364 0000 0895      		ret
 365               		.cfi_endproc
 366               	.LFE25:
 368               		.section	.text.rgblight_decrease_val,"ax",@progbits
 369               		.weak	rgblight_decrease_val
 371               	rgblight_decrease_val:
 372               	.LFB26:
  43:quantum/rgb.h **** 
  44:quantum/rgb.h **** __attribute__((weak))
  45:quantum/rgb.h **** void rgblight_decrease_val(void) {};
 373               		.loc 2 45 0
 374               		.cfi_startproc
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 0 */
 378               	.L__stack_usage = 0
 379 0000 0895      		ret
 380               		.cfi_endproc
 381               	.LFE26:
 383               		.section	.text.rgblight_increase_speed,"ax",@progbits
 384               		.weak	rgblight_increase_speed
 386               	rgblight_increase_speed:
 387               	.LFB27:
  46:quantum/rgb.h **** 
  47:quantum/rgb.h **** __attribute__((weak))
  48:quantum/rgb.h **** void rgblight_increase_speed(void) {};
 388               		.loc 2 48 0
 389               		.cfi_startproc
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 0 */
 393               	.L__stack_usage = 0
 394 0000 0895      		ret
 395               		.cfi_endproc
 396               	.LFE27:
 398               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 399               		.weak	rgblight_decrease_speed
 401               	rgblight_decrease_speed:
 402               	.LFB28:
  49:quantum/rgb.h **** 
  50:quantum/rgb.h **** __attribute__((weak))
  51:quantum/rgb.h **** void rgblight_decrease_speed(void) {};
 403               		.loc 2 51 0
 404               		.cfi_startproc
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 409 0000 0895      		ret
 410               		.cfi_endproc
 411               	.LFE28:
 413               		.section	.text.register_code16,"ax",@progbits
 414               	.global	register_code16
 416               	register_code16:
 417               	.LFB34:
 127:quantum/quantum.c **** }
 128:quantum/quantum.c **** 
 129:quantum/quantum.c **** void register_code16 (uint16_t code) {
 418               		.loc 1 129 0
 419               		.cfi_startproc
 420               	.LVL28:
 421               		.loc 1 129 0
 422 0000 CF93      		push r28
 423               	.LCFI4:
 424               		.cfi_def_cfa_offset 3
 425               		.cfi_offset 28, -2
 426 0002 DF93      		push r29
 427               	.LCFI5:
 428               		.cfi_def_cfa_offset 4
 429               		.cfi_offset 29, -3
 430               	/* prologue: function */
 431               	/* frame size = 0 */
 432               	/* stack size = 2 */
 433               	.L__stack_usage = 2
 434 0004 EC01      		movw r28,r24
 130:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 435               		.loc 1 130 0
 436 0006 805E      		subi r24,-32
 437 0008 9109      		sbc r25,__zero_reg__
 438               	.LVL29:
 439 000a 0897      		sbiw r24,8
 440 000c 00F0      		brlo .L39
 441               		.loc 1 130 0 is_stmt 0 discriminator 1
 442 000e 2097      		sbiw r28,0
 443 0010 01F4      		brne .L40
 444               	.L39:
 131:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 445               		.loc 1 131 0 is_stmt 1
 446 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 447 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 448 0016 00C0      		rjmp .L42
 449               	.L40:
 132:quantum/quantum.c ****   } else {
 133:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 450               		.loc 1 133 0
 451 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 452 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 453               	.L42:
 454 001c CE01      		movw r24,r28
 455 001e 0E94 0000 		call do_code16
 456               	.LVL30:
 134:quantum/quantum.c ****   }
 135:quantum/quantum.c ****   register_code (code);
 457               		.loc 1 135 0
 458 0022 8C2F      		mov r24,r28
 459               	/* epilogue start */
 136:quantum/quantum.c **** }
 460               		.loc 1 136 0
 461 0024 DF91      		pop r29
 462 0026 CF91      		pop r28
 463               	.LVL31:
 135:quantum/quantum.c **** }
 464               		.loc 1 135 0
 465 0028 0C94 0000 		jmp register_code
 466               	.LVL32:
 467               		.cfi_endproc
 468               	.LFE34:
 470               		.section	.text.unregister_code16,"ax",@progbits
 471               	.global	unregister_code16
 473               	unregister_code16:
 474               	.LFB35:
 137:quantum/quantum.c **** 
 138:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 475               		.loc 1 138 0
 476               		.cfi_startproc
 477               	.LVL33:
 478 0000 CF93      		push r28
 479               	.LCFI6:
 480               		.cfi_def_cfa_offset 3
 481               		.cfi_offset 28, -2
 482 0002 DF93      		push r29
 483               	.LCFI7:
 484               		.cfi_def_cfa_offset 4
 485               		.cfi_offset 29, -3
 486               	/* prologue: function */
 487               	/* frame size = 0 */
 488               	/* stack size = 2 */
 489               	.L__stack_usage = 2
 490 0004 EC01      		movw r28,r24
 139:quantum/quantum.c ****   unregister_code (code);
 491               		.loc 1 139 0
 492 0006 0E94 0000 		call unregister_code
 493               	.LVL34:
 140:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 494               		.loc 1 140 0
 495 000a CE01      		movw r24,r28
 496 000c 805E      		subi r24,-32
 497 000e 9109      		sbc r25,__zero_reg__
 498 0010 0897      		sbiw r24,8
 499 0012 00F0      		brlo .L44
 500               		.loc 1 140 0 is_stmt 0 discriminator 1
 501 0014 2097      		sbiw r28,0
 502 0016 01F4      		brne .L45
 503               	.L44:
 141:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 504               		.loc 1 141 0 is_stmt 1
 505 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 506 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 507 001c 00C0      		rjmp .L46
 508               	.L45:
 142:quantum/quantum.c ****   } else {
 143:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 509               		.loc 1 143 0
 510 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 511 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 512               	.L46:
 513 0022 CE01      		movw r24,r28
 514               	/* epilogue start */
 144:quantum/quantum.c ****   }
 145:quantum/quantum.c **** }
 515               		.loc 1 145 0
 516 0024 DF91      		pop r29
 517 0026 CF91      		pop r28
 518               	.LVL35:
 143:quantum/quantum.c ****   }
 519               		.loc 1 143 0
 520 0028 0C94 0000 		jmp do_code16
 521               	.LVL36:
 522               		.cfi_endproc
 523               	.LFE35:
 525               		.section	.text.tap_code16,"ax",@progbits
 526               	.global	tap_code16
 528               	tap_code16:
 529               	.LFB36:
 146:quantum/quantum.c **** 
 147:quantum/quantum.c **** void tap_code16(uint16_t code) {
 530               		.loc 1 147 0
 531               		.cfi_startproc
 532               	.LVL37:
 533 0000 CF93      		push r28
 534               	.LCFI8:
 535               		.cfi_def_cfa_offset 3
 536               		.cfi_offset 28, -2
 537 0002 DF93      		push r29
 538               	.LCFI9:
 539               		.cfi_def_cfa_offset 4
 540               		.cfi_offset 29, -3
 541               	/* prologue: function */
 542               	/* frame size = 0 */
 543               	/* stack size = 2 */
 544               	.L__stack_usage = 2
 545 0004 EC01      		movw r28,r24
 148:quantum/quantum.c ****   register_code16(code);
 546               		.loc 1 148 0
 547 0006 0E94 0000 		call register_code16
 548               	.LVL38:
 149:quantum/quantum.c ****   #if TAP_CODE_DELAY > 0
 150:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 151:quantum/quantum.c ****   #endif
 152:quantum/quantum.c ****   unregister_code16(code);
 549               		.loc 1 152 0
 550 000a CE01      		movw r24,r28
 551               	/* epilogue start */
 153:quantum/quantum.c **** }
 552               		.loc 1 153 0
 553 000c DF91      		pop r29
 554 000e CF91      		pop r28
 555               	.LVL39:
 152:quantum/quantum.c **** }
 556               		.loc 1 152 0
 557 0010 0C94 0000 		jmp unregister_code16
 558               	.LVL40:
 559               		.cfi_endproc
 560               	.LFE36:
 562               		.section	.text.process_action_kb,"ax",@progbits
 563               		.weak	process_action_kb
 565               	process_action_kb:
 566               	.LFB37:
 154:quantum/quantum.c **** 
 155:quantum/quantum.c **** __attribute__ ((weak))
 156:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 567               		.loc 1 156 0
 568               		.cfi_startproc
 569               	.LVL41:
 570               	/* prologue: function */
 571               	/* frame size = 0 */
 572               	/* stack size = 0 */
 573               	.L__stack_usage = 0
 157:quantum/quantum.c ****   return true;
 158:quantum/quantum.c **** }
 574               		.loc 1 158 0
 575 0000 81E0      		ldi r24,lo8(1)
 576               	.LVL42:
 577 0002 0895      		ret
 578               		.cfi_endproc
 579               	.LFE37:
 581               		.section	.text.process_record_user,"ax",@progbits
 582               		.weak	process_record_user
 584               	process_record_user:
 585               	.LFB39:
 159:quantum/quantum.c **** 
 160:quantum/quantum.c **** __attribute__ ((weak))
 161:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 162:quantum/quantum.c ****   return process_record_user(keycode, record);
 163:quantum/quantum.c **** }
 164:quantum/quantum.c **** 
 165:quantum/quantum.c **** __attribute__ ((weak))
 166:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 586               		.loc 1 166 0
 587               		.cfi_startproc
 588               	.LVL43:
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 167:quantum/quantum.c ****   return true;
 168:quantum/quantum.c **** }
 593               		.loc 1 168 0
 594 0000 81E0      		ldi r24,lo8(1)
 595               	.LVL44:
 596 0002 0895      		ret
 597               		.cfi_endproc
 598               	.LFE39:
 600               		.section	.text.process_record_kb,"ax",@progbits
 601               		.weak	process_record_kb
 603               	process_record_kb:
 604               	.LFB38:
 161:quantum/quantum.c ****   return process_record_user(keycode, record);
 605               		.loc 1 161 0
 606               		.cfi_startproc
 607               	.LVL45:
 608               	/* prologue: function */
 609               	/* frame size = 0 */
 610               	/* stack size = 0 */
 611               	.L__stack_usage = 0
 162:quantum/quantum.c **** }
 612               		.loc 1 162 0
 613 0000 0C94 0000 		jmp process_record_user
 614               	.LVL46:
 615               		.cfi_endproc
 616               	.LFE38:
 618               		.section	.text.send_char,"ax",@progbits
 619               	.global	send_char
 621               	send_char:
 622               	.LFB46:
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** void reset_keyboard(void) {
 171:quantum/quantum.c ****   clear_keyboard();
 172:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 173:quantum/quantum.c ****   process_midi_all_notes_off();
 174:quantum/quantum.c **** #endif
 175:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 176:quantum/quantum.c ****   #ifndef NO_MUSIC_MODE
 177:quantum/quantum.c ****     music_all_notes_off();
 178:quantum/quantum.c ****   #endif
 179:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 180:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 181:quantum/quantum.c ****   shutdown_user();
 182:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 183:quantum/quantum.c ****     wait_ms(1);
 184:quantum/quantum.c ****   stop_all_notes();
 185:quantum/quantum.c **** #else
 186:quantum/quantum.c ****   shutdown_user();
 187:quantum/quantum.c ****   wait_ms(250);
 188:quantum/quantum.c **** #endif
 189:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 190:quantum/quantum.c ****   haptic_shutdown();
 191:quantum/quantum.c **** #endif
 192:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 193:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 194:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 195:quantum/quantum.c **** #endif
 196:quantum/quantum.c ****   bootloader_jump();
 197:quantum/quantum.c **** }
 198:quantum/quantum.c **** 
 199:quantum/quantum.c **** // Shift / paren setup
 200:quantum/quantum.c **** 
 201:quantum/quantum.c **** #ifndef LSPO_KEY
 202:quantum/quantum.c ****   #define LSPO_KEY KC_9
 203:quantum/quantum.c **** #endif
 204:quantum/quantum.c **** #ifndef RSPC_KEY
 205:quantum/quantum.c ****   #define RSPC_KEY KC_0
 206:quantum/quantum.c **** #endif
 207:quantum/quantum.c **** 
 208:quantum/quantum.c **** #ifndef LSPO_MOD
 209:quantum/quantum.c ****   #define LSPO_MOD KC_LSFT
 210:quantum/quantum.c **** #endif
 211:quantum/quantum.c **** #ifndef RSPC_MOD
 212:quantum/quantum.c ****   #define RSPC_MOD KC_RSFT
 213:quantum/quantum.c **** #endif
 214:quantum/quantum.c **** 
 215:quantum/quantum.c **** // Shift / Enter setup
 216:quantum/quantum.c **** #ifndef SFTENT_KEY
 217:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 218:quantum/quantum.c **** #endif
 219:quantum/quantum.c **** 
 220:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 221:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 222:quantum/quantum.c **** 
 223:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 224:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 225:quantum/quantum.c ****  */
 226:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 227:quantum/quantum.c **** 
 228:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 229:quantum/quantum.c **** 
 230:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 231:quantum/quantum.c ****   keypos_t key = record->event.key;
 232:quantum/quantum.c ****   uint16_t keycode;
 233:quantum/quantum.c **** 
 234:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 235:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 236:quantum/quantum.c ****     if (!disable_action_cache) {
 237:quantum/quantum.c ****       uint8_t layer;
 238:quantum/quantum.c **** 
 239:quantum/quantum.c ****       if (record->event.pressed) {
 240:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 241:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 242:quantum/quantum.c ****       } else {
 243:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 244:quantum/quantum.c ****       }
 245:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 246:quantum/quantum.c ****     } else
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 249:quantum/quantum.c **** 
 250:quantum/quantum.c ****     // This is how you use actions here
 251:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 252:quantum/quantum.c ****     //   action_t action;
 253:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 254:quantum/quantum.c ****     //   process_action(record, action);
 255:quantum/quantum.c ****     //   return false;
 256:quantum/quantum.c ****     // }
 257:quantum/quantum.c **** 
 258:quantum/quantum.c ****   #ifdef VELOCIKEY_ENABLE
 259:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) { velocikey_accelerate(); }
 260:quantum/quantum.c ****   #endif
 261:quantum/quantum.c **** 
 262:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 263:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 264:quantum/quantum.c ****   #endif
 265:quantum/quantum.c **** 
 266:quantum/quantum.c ****   if (!(
 267:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 268:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 269:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 270:quantum/quantum.c ****   #endif
 271:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 272:quantum/quantum.c ****     process_clicky(keycode, record) &&
 273:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 274:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
 275:quantum/quantum.c ****     process_haptic(keycode, record) &&
 276:quantum/quantum.c ****   #endif //HAPTIC_ENABLE
 277:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 278:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 279:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 280:quantum/quantum.c ****   #endif
 281:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 282:quantum/quantum.c ****     process_midi(keycode, record) &&
 283:quantum/quantum.c ****   #endif
 284:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 285:quantum/quantum.c ****     process_audio(keycode, record) &&
 286:quantum/quantum.c ****   #endif
 287:quantum/quantum.c ****   #ifdef STENO_ENABLE
 288:quantum/quantum.c ****     process_steno(keycode, record) &&
 289:quantum/quantum.c ****   #endif
 290:quantum/quantum.c ****   #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC
 291:quantum/quantum.c ****     process_music(keycode, record) &&
 292:quantum/quantum.c ****   #endif
 293:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 294:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 295:quantum/quantum.c ****   #endif
 296:quantum/quantum.c ****   #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 297:quantum/quantum.c ****     process_unicode_common(keycode, record) &&
 298:quantum/quantum.c ****   #endif
 299:quantum/quantum.c ****   #ifdef LEADER_ENABLE
 300:quantum/quantum.c ****     process_leader(keycode, record) &&
 301:quantum/quantum.c ****   #endif
 302:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 303:quantum/quantum.c ****     process_combo(keycode, record) &&
 304:quantum/quantum.c ****   #endif
 305:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 306:quantum/quantum.c ****     process_printer(keycode, record) &&
 307:quantum/quantum.c ****   #endif
 308:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 309:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 310:quantum/quantum.c ****   #endif
 311:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 312:quantum/quantum.c ****     process_terminal(keycode, record) &&
 313:quantum/quantum.c ****   #endif
 314:quantum/quantum.c ****       true)) {
 315:quantum/quantum.c ****     return false;
 316:quantum/quantum.c ****   }
 317:quantum/quantum.c **** 
 318:quantum/quantum.c ****   // Shift / paren setup
 319:quantum/quantum.c **** 
 320:quantum/quantum.c ****   switch(keycode) {
 321:quantum/quantum.c ****     case RESET:
 322:quantum/quantum.c ****       if (record->event.pressed) {
 323:quantum/quantum.c ****         reset_keyboard();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****     return false;
 326:quantum/quantum.c ****     case DEBUG:
 327:quantum/quantum.c ****       if (record->event.pressed) {
 328:quantum/quantum.c ****           debug_enable = true;
 329:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 330:quantum/quantum.c ****       }
 331:quantum/quantum.c ****     return false;
 332:quantum/quantum.c ****     case EEPROM_RESET:
 333:quantum/quantum.c ****       if (record->event.pressed) {
 334:quantum/quantum.c ****           eeconfig_init();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****     return false;
 337:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 338:quantum/quantum.c ****   case FC_TOG:
 339:quantum/quantum.c ****     if (record->event.pressed) {
 340:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 341:quantum/quantum.c ****     }
 342:quantum/quantum.c ****     return false;
 343:quantum/quantum.c ****   case FC_ON:
 344:quantum/quantum.c ****     if (record->event.pressed) {
 345:quantum/quantum.c ****       FAUXCLICKY_ON;
 346:quantum/quantum.c ****     }
 347:quantum/quantum.c ****     return false;
 348:quantum/quantum.c ****   case FC_OFF:
 349:quantum/quantum.c ****     if (record->event.pressed) {
 350:quantum/quantum.c ****       FAUXCLICKY_OFF;
 351:quantum/quantum.c ****     }
 352:quantum/quantum.c ****     return false;
 353:quantum/quantum.c ****   #endif
 354:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 355:quantum/quantum.c ****   case RGB_TOG:
 356:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 357:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 358:quantum/quantum.c ****     if (record->event.pressed) {
 359:quantum/quantum.c ****     #else
 360:quantum/quantum.c ****     if (!record->event.pressed) {
 361:quantum/quantum.c ****     #endif
 362:quantum/quantum.c ****       rgblight_toggle();
 363:quantum/quantum.c ****     }
 364:quantum/quantum.c ****     return false;
 365:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 366:quantum/quantum.c ****     if (record->event.pressed) {
 367:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 368:quantum/quantum.c ****       if(shifted) {
 369:quantum/quantum.c ****         rgblight_step_reverse();
 370:quantum/quantum.c ****       }
 371:quantum/quantum.c ****       else {
 372:quantum/quantum.c ****         rgblight_step();
 373:quantum/quantum.c ****       }
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 379:quantum/quantum.c ****       if(shifted) {
 380:quantum/quantum.c ****         rgblight_step();
 381:quantum/quantum.c ****       }
 382:quantum/quantum.c ****       else {
 383:quantum/quantum.c ****         rgblight_step_reverse();
 384:quantum/quantum.c ****       }
 385:quantum/quantum.c ****     }
 386:quantum/quantum.c ****     return false;
 387:quantum/quantum.c ****   case RGB_HUI:
 388:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 389:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 390:quantum/quantum.c ****     if (record->event.pressed) {
 391:quantum/quantum.c ****     #else
 392:quantum/quantum.c ****     if (!record->event.pressed) {
 393:quantum/quantum.c ****     #endif
 394:quantum/quantum.c ****       rgblight_increase_hue();
 395:quantum/quantum.c ****     }
 396:quantum/quantum.c ****     return false;
 397:quantum/quantum.c ****   case RGB_HUD:
 398:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 399:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 400:quantum/quantum.c ****     if (record->event.pressed) {
 401:quantum/quantum.c ****     #else
 402:quantum/quantum.c ****     if (!record->event.pressed) {
 403:quantum/quantum.c ****     #endif
 404:quantum/quantum.c ****       rgblight_decrease_hue();
 405:quantum/quantum.c ****     }
 406:quantum/quantum.c ****     return false;
 407:quantum/quantum.c ****   case RGB_SAI:
 408:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 409:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 410:quantum/quantum.c ****     if (record->event.pressed) {
 411:quantum/quantum.c ****     #else
 412:quantum/quantum.c ****     if (!record->event.pressed) {
 413:quantum/quantum.c ****     #endif
 414:quantum/quantum.c ****       rgblight_increase_sat();
 415:quantum/quantum.c ****     }
 416:quantum/quantum.c ****     return false;
 417:quantum/quantum.c ****   case RGB_SAD:
 418:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 419:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 420:quantum/quantum.c ****     if (record->event.pressed) {
 421:quantum/quantum.c ****     #else
 422:quantum/quantum.c ****     if (!record->event.pressed) {
 423:quantum/quantum.c ****     #endif
 424:quantum/quantum.c ****       rgblight_decrease_sat();
 425:quantum/quantum.c ****     }
 426:quantum/quantum.c ****     return false;
 427:quantum/quantum.c ****   case RGB_VAI:
 428:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 429:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 430:quantum/quantum.c ****     if (record->event.pressed) {
 431:quantum/quantum.c ****     #else
 432:quantum/quantum.c ****     if (!record->event.pressed) {
 433:quantum/quantum.c ****     #endif
 434:quantum/quantum.c ****       rgblight_increase_val();
 435:quantum/quantum.c ****     }
 436:quantum/quantum.c ****     return false;
 437:quantum/quantum.c ****   case RGB_VAD:
 438:quantum/quantum.c ****     // Split keyboards need to trigger on key-up for edge-case issue
 439:quantum/quantum.c ****     #ifndef SPLIT_KEYBOARD
 440:quantum/quantum.c ****     if (record->event.pressed) {
 441:quantum/quantum.c ****     #else
 442:quantum/quantum.c ****     if (!record->event.pressed) {
 443:quantum/quantum.c ****     #endif
 444:quantum/quantum.c ****       rgblight_decrease_val();
 445:quantum/quantum.c ****     }
 446:quantum/quantum.c ****     return false;
 447:quantum/quantum.c ****   case RGB_SPI:
 448:quantum/quantum.c ****     if (record->event.pressed) {
 449:quantum/quantum.c ****       rgblight_increase_speed();
 450:quantum/quantum.c ****     }
 451:quantum/quantum.c ****     return false;
 452:quantum/quantum.c ****   case RGB_SPD:
 453:quantum/quantum.c ****     if (record->event.pressed) {
 454:quantum/quantum.c ****       rgblight_decrease_speed();
 455:quantum/quantum.c ****     }
 456:quantum/quantum.c ****     return false;
 457:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 458:quantum/quantum.c ****     if (record->event.pressed) {
 459:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 460:quantum/quantum.c ****     }
 461:quantum/quantum.c ****     return false;
 462:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 463:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_BREATHING
 464:quantum/quantum.c ****     if (record->event.pressed) {
 465:quantum/quantum.c ****       if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) &&
 466:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_BREATHING_end)) {
 467:quantum/quantum.c ****         rgblight_step();
 468:quantum/quantum.c ****       } else {
 469:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_BREATHING);
 470:quantum/quantum.c ****       }
 471:quantum/quantum.c ****     }
 472:quantum/quantum.c ****   #endif
 473:quantum/quantum.c ****     return false;
 474:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 475:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RAINBOW_MOOD
 476:quantum/quantum.c ****     if (record->event.pressed) {
 477:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) &&
 478:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_MOOD_end)) {
 479:quantum/quantum.c ****         rgblight_step();
 480:quantum/quantum.c ****       } else {
 481:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_RAINBOW_MOOD);
 482:quantum/quantum.c ****       }
 483:quantum/quantum.c ****     }
 484:quantum/quantum.c ****   #endif
 485:quantum/quantum.c ****     return false;
 486:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 487:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RAINBOW_SWIRL
 488:quantum/quantum.c ****     if (record->event.pressed) {
 489:quantum/quantum.c ****       if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) &&
 490:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_RAINBOW_SWIRL_end)) {
 491:quantum/quantum.c ****         rgblight_step();
 492:quantum/quantum.c ****       } else {
 493:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_RAINBOW_SWIRL);
 494:quantum/quantum.c ****       }
 495:quantum/quantum.c ****     }
 496:quantum/quantum.c ****   #endif
 497:quantum/quantum.c ****     return false;
 498:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 499:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_SNAKE
 500:quantum/quantum.c ****     if (record->event.pressed) {
 501:quantum/quantum.c ****       if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) &&
 502:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_SNAKE_end)) {
 503:quantum/quantum.c ****         rgblight_step();
 504:quantum/quantum.c ****       } else {
 505:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_SNAKE);
 506:quantum/quantum.c ****       }
 507:quantum/quantum.c ****     }
 508:quantum/quantum.c ****   #endif
 509:quantum/quantum.c ****     return false;
 510:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 511:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_KNIGHT
 512:quantum/quantum.c ****     if (record->event.pressed) {
 513:quantum/quantum.c ****       if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) &&
 514:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_KNIGHT_end)) {
 515:quantum/quantum.c ****         rgblight_step();
 516:quantum/quantum.c ****       } else {
 517:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_KNIGHT);
 518:quantum/quantum.c ****       }
 519:quantum/quantum.c ****     }
 520:quantum/quantum.c ****   #endif
 521:quantum/quantum.c ****     return false;
 522:quantum/quantum.c ****   case RGB_MODE_XMAS:
 523:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_CHRISTMAS
 524:quantum/quantum.c ****     if (record->event.pressed) {
 525:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 526:quantum/quantum.c ****     }
 527:quantum/quantum.c ****   #endif
 528:quantum/quantum.c ****     return false;
 529:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 530:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_STATIC_GRADIENT
 531:quantum/quantum.c ****     if (record->event.pressed) {
 532:quantum/quantum.c ****       if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) &&
 533:quantum/quantum.c ****           (rgblight_get_mode() < RGBLIGHT_MODE_STATIC_GRADIENT_end)) {
 534:quantum/quantum.c ****         rgblight_step();
 535:quantum/quantum.c ****       } else {
 536:quantum/quantum.c ****         rgblight_mode(RGBLIGHT_MODE_STATIC_GRADIENT);
 537:quantum/quantum.c ****       }
 538:quantum/quantum.c ****     }
 539:quantum/quantum.c ****   #endif
 540:quantum/quantum.c ****     return false;
 541:quantum/quantum.c ****   case RGB_MODE_RGBTEST:
 542:quantum/quantum.c ****   #ifdef RGBLIGHT_EFFECT_RGB_TEST
 543:quantum/quantum.c ****     if (record->event.pressed) {
 544:quantum/quantum.c ****       rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 545:quantum/quantum.c ****     }
 546:quantum/quantum.c ****   #endif
 547:quantum/quantum.c ****     return false;
 548:quantum/quantum.c ****   #endif // defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 549:quantum/quantum.c ****   #ifdef VELOCIKEY_ENABLE
 550:quantum/quantum.c ****     case VLK_TOG:
 551:quantum/quantum.c ****       if (record->event.pressed) {
 552:quantum/quantum.c ****         velocikey_toggle();
 553:quantum/quantum.c ****       }
 554:quantum/quantum.c ****       return false;
 555:quantum/quantum.c ****   #endif
 556:quantum/quantum.c ****   #ifdef PROTOCOL_LUFA
 557:quantum/quantum.c ****     case OUT_AUTO:
 558:quantum/quantum.c ****       if (record->event.pressed) {
 559:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 560:quantum/quantum.c ****       }
 561:quantum/quantum.c ****       return false;
 562:quantum/quantum.c ****     case OUT_USB:
 563:quantum/quantum.c ****       if (record->event.pressed) {
 564:quantum/quantum.c ****         set_output(OUTPUT_USB);
 565:quantum/quantum.c ****       }
 566:quantum/quantum.c ****       return false;
 567:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 568:quantum/quantum.c ****     case OUT_BT:
 569:quantum/quantum.c ****       if (record->event.pressed) {
 570:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 571:quantum/quantum.c ****       }
 572:quantum/quantum.c ****       return false;
 573:quantum/quantum.c ****     #endif
 574:quantum/quantum.c ****     #endif
 575:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 576:quantum/quantum.c ****       if (record->event.pressed) {
 577:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 578:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 579:quantum/quantum.c ****             eeconfig_init();
 580:quantum/quantum.c ****         }
 581:quantum/quantum.c ****         /* keymap config */
 582:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 583:quantum/quantum.c ****         switch (keycode)
 584:quantum/quantum.c ****         {
 585:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 586:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 587:quantum/quantum.c ****             break;
 588:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 589:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 590:quantum/quantum.c ****             break;
 591:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 592:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 593:quantum/quantum.c ****             break;
 594:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 595:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 596:quantum/quantum.c ****             break;
 597:quantum/quantum.c ****           case MAGIC_NO_GUI:
 598:quantum/quantum.c ****             keymap_config.no_gui = true;
 599:quantum/quantum.c ****             break;
 600:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 601:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 602:quantum/quantum.c ****             break;
 603:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 604:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 605:quantum/quantum.c ****             break;
 606:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 607:quantum/quantum.c ****             keymap_config.nkro = true;
 608:quantum/quantum.c ****             break;
 609:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 610:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 611:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 612:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 613:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 614:quantum/quantum.c ****             #endif
 615:quantum/quantum.c ****             break;
 616:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 617:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 618:quantum/quantum.c ****             break;
 619:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 620:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 621:quantum/quantum.c ****             break;
 622:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 623:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 624:quantum/quantum.c ****             break;
 625:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 626:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 627:quantum/quantum.c ****             break;
 628:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 629:quantum/quantum.c ****             keymap_config.no_gui = false;
 630:quantum/quantum.c ****             break;
 631:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 632:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 633:quantum/quantum.c ****             break;
 634:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 635:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 636:quantum/quantum.c ****             break;
 637:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 638:quantum/quantum.c ****             keymap_config.nkro = false;
 639:quantum/quantum.c ****             break;
 640:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 641:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 642:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 643:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 644:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 645:quantum/quantum.c ****             #endif
 646:quantum/quantum.c ****             break;
 647:quantum/quantum.c ****           case MAGIC_TOGGLE_ALT_GUI:
 648:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = !keymap_config.swap_lalt_lgui;
 649:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = !keymap_config.swap_ralt_rgui;
 650:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 651:quantum/quantum.c ****               if (keymap_config.swap_ralt_rgui) {
 652:quantum/quantum.c ****                 PLAY_SONG(ag_swap_song);
 653:quantum/quantum.c ****               } else {
 654:quantum/quantum.c ****                 PLAY_SONG(ag_norm_song);
 655:quantum/quantum.c ****               }
 656:quantum/quantum.c ****             #endif
 657:quantum/quantum.c ****             break;
 658:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 659:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 660:quantum/quantum.c ****             break;
 661:quantum/quantum.c ****           default:
 662:quantum/quantum.c ****             break;
 663:quantum/quantum.c ****         }
 664:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 665:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 666:quantum/quantum.c **** 
 667:quantum/quantum.c ****         return false;
 668:quantum/quantum.c ****       }
 669:quantum/quantum.c ****       break;
 670:quantum/quantum.c ****     case KC_LSPO: {
 671:quantum/quantum.c ****       if (record->event.pressed) {
 672:quantum/quantum.c ****         shift_interrupted[0] = false;
 673:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 674:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 675:quantum/quantum.c ****       }
 676:quantum/quantum.c ****       else {
 677:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 678:quantum/quantum.c ****           if (get_mods() & MOD_BIT(RSPC_MOD)) {
 679:quantum/quantum.c ****             shift_interrupted[0] = true;
 680:quantum/quantum.c ****             shift_interrupted[1] = true;
 681:quantum/quantum.c ****           }
 682:quantum/quantum.c ****         #endif
 683:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 684:quantum/quantum.c ****           #ifdef DISABLE_SPACE_CADET_MODIFIER
 685:quantum/quantum.c ****             unregister_mods(MOD_BIT(KC_LSFT));
 686:quantum/quantum.c ****           #else
 687:quantum/quantum.c ****             if( LSPO_MOD != KC_LSFT ){
 688:quantum/quantum.c ****               unregister_mods(MOD_BIT(KC_LSFT));
 689:quantum/quantum.c ****               register_mods(MOD_BIT(LSPO_MOD));
 690:quantum/quantum.c ****             }
 691:quantum/quantum.c ****           #endif
 692:quantum/quantum.c ****           register_code(LSPO_KEY);
 693:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 694:quantum/quantum.c ****           #ifndef DISABLE_SPACE_CADET_MODIFIER
 695:quantum/quantum.c ****             if( LSPO_MOD != KC_LSFT ){
 696:quantum/quantum.c ****               unregister_mods(MOD_BIT(LSPO_MOD));
 697:quantum/quantum.c ****             }
 698:quantum/quantum.c ****           #endif
 699:quantum/quantum.c ****         }
 700:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 701:quantum/quantum.c ****       }
 702:quantum/quantum.c ****       return false;
 703:quantum/quantum.c ****     }
 704:quantum/quantum.c **** 
 705:quantum/quantum.c ****     case KC_RSPC: {
 706:quantum/quantum.c ****       if (record->event.pressed) {
 707:quantum/quantum.c ****         shift_interrupted[1] = false;
 708:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 709:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 710:quantum/quantum.c ****       }
 711:quantum/quantum.c ****       else {
 712:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 713:quantum/quantum.c ****           if (get_mods() & MOD_BIT(LSPO_MOD)) {
 714:quantum/quantum.c ****             shift_interrupted[0] = true;
 715:quantum/quantum.c ****             shift_interrupted[1] = true;
 716:quantum/quantum.c ****           }
 717:quantum/quantum.c ****         #endif
 718:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 719:quantum/quantum.c ****           #ifdef DISABLE_SPACE_CADET_MODIFIER
 720:quantum/quantum.c ****             unregister_mods(MOD_BIT(KC_RSFT));
 721:quantum/quantum.c ****           #else
 722:quantum/quantum.c ****             if( RSPC_MOD != KC_RSFT ){
 723:quantum/quantum.c ****               unregister_mods(MOD_BIT(KC_RSFT));
 724:quantum/quantum.c ****               register_mods(MOD_BIT(RSPC_MOD));
 725:quantum/quantum.c ****             }
 726:quantum/quantum.c ****           #endif
 727:quantum/quantum.c ****           register_code(RSPC_KEY);
 728:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 729:quantum/quantum.c ****           #ifndef DISABLE_SPACE_CADET_MODIFIER
 730:quantum/quantum.c ****             if ( RSPC_MOD != KC_RSFT ){
 731:quantum/quantum.c ****               unregister_mods(MOD_BIT(RSPC_MOD));
 732:quantum/quantum.c ****             }
 733:quantum/quantum.c ****           #endif
 734:quantum/quantum.c ****         }
 735:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 736:quantum/quantum.c ****       }
 737:quantum/quantum.c ****       return false;
 738:quantum/quantum.c ****     }
 739:quantum/quantum.c **** 
 740:quantum/quantum.c ****     case KC_SFTENT: {
 741:quantum/quantum.c ****       if (record->event.pressed) {
 742:quantum/quantum.c ****         shift_interrupted[1] = false;
 743:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 744:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 745:quantum/quantum.c ****       }
 746:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 747:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 748:quantum/quantum.c ****         register_code(SFTENT_KEY);
 749:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 750:quantum/quantum.c ****       }
 751:quantum/quantum.c ****       else {
 752:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 753:quantum/quantum.c ****       }
 754:quantum/quantum.c ****       return false;
 755:quantum/quantum.c ****     }
 756:quantum/quantum.c **** 
 757:quantum/quantum.c ****     case GRAVE_ESC: {
 758:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 759:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 760:quantum/quantum.c **** 
 761:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 762:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 763:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 764:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 765:quantum/quantum.c ****         shifted = 0;
 766:quantum/quantum.c ****       }
 767:quantum/quantum.c **** #endif
 768:quantum/quantum.c **** 
 769:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 770:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 771:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 772:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 773:quantum/quantum.c ****         shifted = 0;
 774:quantum/quantum.c ****       }
 775:quantum/quantum.c **** #endif
 776:quantum/quantum.c **** 
 777:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 778:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 779:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 780:quantum/quantum.c ****         shifted = 0;
 781:quantum/quantum.c ****       }
 782:quantum/quantum.c **** #endif
 783:quantum/quantum.c **** 
 784:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 785:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 786:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 787:quantum/quantum.c ****         shifted = 0;
 788:quantum/quantum.c ****       }
 789:quantum/quantum.c **** #endif
 790:quantum/quantum.c **** 
 791:quantum/quantum.c ****       if (record->event.pressed) {
 792:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 793:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 794:quantum/quantum.c ****       }
 795:quantum/quantum.c ****       else {
 796:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 797:quantum/quantum.c ****       }
 798:quantum/quantum.c **** 
 799:quantum/quantum.c ****       send_keyboard_report();
 800:quantum/quantum.c ****       return false;
 801:quantum/quantum.c ****     }
 802:quantum/quantum.c **** 
 803:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 804:quantum/quantum.c ****     case BL_BRTG: {
 805:quantum/quantum.c ****       if (record->event.pressed)
 806:quantum/quantum.c ****         breathing_toggle();
 807:quantum/quantum.c ****       return false;
 808:quantum/quantum.c ****     }
 809:quantum/quantum.c **** #endif
 810:quantum/quantum.c **** 
 811:quantum/quantum.c ****     default: {
 812:quantum/quantum.c ****       shift_interrupted[0] = true;
 813:quantum/quantum.c ****       shift_interrupted[1] = true;
 814:quantum/quantum.c ****       break;
 815:quantum/quantum.c ****     }
 816:quantum/quantum.c ****   }
 817:quantum/quantum.c **** 
 818:quantum/quantum.c ****   return process_action_kb(record);
 819:quantum/quantum.c **** }
 820:quantum/quantum.c **** 
 821:quantum/quantum.c **** __attribute__ ((weak))
 822:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 823:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 824:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 825:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 826:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 827:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 828:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 829:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 830:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 831:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 832:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 833:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 834:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 835:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 836:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 837:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 838:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 839:quantum/quantum.c **** };
 840:quantum/quantum.c **** 
 841:quantum/quantum.c **** __attribute__ ((weak))
 842:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 843:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 844:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 845:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 846:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 847:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 848:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 849:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 850:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 851:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 852:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 853:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 854:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 855:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 856:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 857:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 858:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 859:quantum/quantum.c **** };
 860:quantum/quantum.c **** 
 861:quantum/quantum.c **** void send_string(const char *str) {
 862:quantum/quantum.c ****   send_string_with_delay(str, 0);
 863:quantum/quantum.c **** }
 864:quantum/quantum.c **** 
 865:quantum/quantum.c **** void send_string_P(const char *str) {
 866:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 867:quantum/quantum.c **** }
 868:quantum/quantum.c **** 
 869:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 870:quantum/quantum.c ****     while (1) {
 871:quantum/quantum.c ****         char ascii_code = *str;
 872:quantum/quantum.c ****         if (!ascii_code) break;
 873:quantum/quantum.c ****         if (ascii_code == 1) {
 874:quantum/quantum.c ****           // tap
 875:quantum/quantum.c ****           uint8_t keycode = *(++str);
 876:quantum/quantum.c ****           register_code(keycode);
 877:quantum/quantum.c ****           unregister_code(keycode);
 878:quantum/quantum.c ****         } else if (ascii_code == 2) {
 879:quantum/quantum.c ****           // down
 880:quantum/quantum.c ****           uint8_t keycode = *(++str);
 881:quantum/quantum.c ****           register_code(keycode);
 882:quantum/quantum.c ****         } else if (ascii_code == 3) {
 883:quantum/quantum.c ****           // up
 884:quantum/quantum.c ****           uint8_t keycode = *(++str);
 885:quantum/quantum.c ****           unregister_code(keycode);
 886:quantum/quantum.c ****         } else {
 887:quantum/quantum.c ****           send_char(ascii_code);
 888:quantum/quantum.c ****         }
 889:quantum/quantum.c ****         ++str;
 890:quantum/quantum.c ****         // interval
 891:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 892:quantum/quantum.c ****     }
 893:quantum/quantum.c **** }
 894:quantum/quantum.c **** 
 895:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 896:quantum/quantum.c ****     while (1) {
 897:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 898:quantum/quantum.c ****         if (!ascii_code) break;
 899:quantum/quantum.c ****         if (ascii_code == 1) {
 900:quantum/quantum.c ****           // tap
 901:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 902:quantum/quantum.c ****           register_code(keycode);
 903:quantum/quantum.c ****           unregister_code(keycode);
 904:quantum/quantum.c ****         } else if (ascii_code == 2) {
 905:quantum/quantum.c ****           // down
 906:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 907:quantum/quantum.c ****           register_code(keycode);
 908:quantum/quantum.c ****         } else if (ascii_code == 3) {
 909:quantum/quantum.c ****           // up
 910:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 911:quantum/quantum.c ****           unregister_code(keycode);
 912:quantum/quantum.c ****         } else {
 913:quantum/quantum.c ****           send_char(ascii_code);
 914:quantum/quantum.c ****         }
 915:quantum/quantum.c ****         ++str;
 916:quantum/quantum.c ****         // interval
 917:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 918:quantum/quantum.c ****     }
 919:quantum/quantum.c **** }
 920:quantum/quantum.c **** 
 921:quantum/quantum.c **** void send_char(char ascii_code) {
 623               		.loc 1 921 0
 624               		.cfi_startproc
 625               	.LVL47:
 626 0000 CF93      		push r28
 627               	.LCFI10:
 628               		.cfi_def_cfa_offset 3
 629               		.cfi_offset 28, -2
 630               	/* prologue: function */
 631               	/* frame size = 0 */
 632               	/* stack size = 1 */
 633               	.L__stack_usage = 1
 634               	.LBB30:
 922:quantum/quantum.c ****   uint8_t keycode;
 923:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 635               		.loc 1 923 0
 636 0002 282F      		mov r18,r24
 637 0004 30E0      		ldi r19,0
 638               	.LVL48:
 639 0006 F901      		movw r30,r18
 640 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 641 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 642               	.LVL49:
 643               	/* #APP */
 644               	 ;  923 "quantum/quantum.c" 1
 645 000c C491      		lpm r28, Z
 646               		
 647               	 ;  0 "" 2
 648               	.LVL50:
 649               	/* #NOAPP */
 650               	.LBE30:
 651               	.LBB31:
 924:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 652               		.loc 1 924 0
 653 000e F901      		movw r30,r18
 654               	.LVL51:
 655 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 656 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 657               	.LVL52:
 658               	/* #APP */
 659               	 ;  924 "quantum/quantum.c" 1
 660 0014 2491      		lpm r18, Z
 661               		
 662               	 ;  0 "" 2
 663               	.LVL53:
 664               	/* #NOAPP */
 665               	.LBE31:
 666 0016 2223      		tst r18
 667 0018 01F0      		breq .L52
 925:quantum/quantum.c ****       register_code(KC_LSFT);
 668               		.loc 1 925 0
 669 001a 81EE      		ldi r24,lo8(-31)
 670               	.LVL54:
 671 001c 0E94 0000 		call register_code
 672               	.LVL55:
 926:quantum/quantum.c ****       register_code(keycode);
 673               		.loc 1 926 0
 674 0020 8C2F      		mov r24,r28
 675 0022 0E94 0000 		call register_code
 676               	.LVL56:
 927:quantum/quantum.c ****       unregister_code(keycode);
 677               		.loc 1 927 0
 678 0026 8C2F      		mov r24,r28
 679 0028 0E94 0000 		call unregister_code
 680               	.LVL57:
 928:quantum/quantum.c ****       unregister_code(KC_LSFT);
 681               		.loc 1 928 0
 682 002c 81EE      		ldi r24,lo8(-31)
 683 002e 00C0      		rjmp .L53
 684               	.LVL58:
 685               	.L52:
 929:quantum/quantum.c ****   } else {
 930:quantum/quantum.c ****       register_code(keycode);
 686               		.loc 1 930 0
 687 0030 8C2F      		mov r24,r28
 688               	.LVL59:
 689 0032 0E94 0000 		call register_code
 690               	.LVL60:
 931:quantum/quantum.c ****       unregister_code(keycode);
 691               		.loc 1 931 0
 692 0036 8C2F      		mov r24,r28
 693               	.L53:
 694               	/* epilogue start */
 932:quantum/quantum.c ****   }
 933:quantum/quantum.c **** }
 695               		.loc 1 933 0
 696 0038 CF91      		pop r28
 697               	.LVL61:
 931:quantum/quantum.c ****       unregister_code(keycode);
 698               		.loc 1 931 0
 699 003a 0C94 0000 		jmp unregister_code
 700               	.LVL62:
 701               		.cfi_endproc
 702               	.LFE46:
 704               		.section	.text.send_string_with_delay,"ax",@progbits
 705               	.global	send_string_with_delay
 707               	send_string_with_delay:
 708               	.LFB44:
 869:quantum/quantum.c ****     while (1) {
 709               		.loc 1 869 0
 710               		.cfi_startproc
 711               	.LVL63:
 712 0000 FF92      		push r15
 713               	.LCFI11:
 714               		.cfi_def_cfa_offset 3
 715               		.cfi_offset 15, -2
 716 0002 0F93      		push r16
 717               	.LCFI12:
 718               		.cfi_def_cfa_offset 4
 719               		.cfi_offset 16, -3
 720 0004 1F93      		push r17
 721               	.LCFI13:
 722               		.cfi_def_cfa_offset 5
 723               		.cfi_offset 17, -4
 724 0006 CF93      		push r28
 725               	.LCFI14:
 726               		.cfi_def_cfa_offset 6
 727               		.cfi_offset 28, -5
 728 0008 DF93      		push r29
 729               	.LCFI15:
 730               		.cfi_def_cfa_offset 7
 731               		.cfi_offset 29, -6
 732               	/* prologue: function */
 733               	/* frame size = 0 */
 734               	/* stack size = 5 */
 735               	.L__stack_usage = 5
 736 000a EC01      		movw r28,r24
 737 000c F62E      		mov r15,r22
 738               	.LVL64:
 739               	.L62:
 740               	.LBB32:
 871:quantum/quantum.c ****         if (!ascii_code) break;
 741               		.loc 1 871 0
 742 000e 8881      		ld r24,Y
 743               	.LVL65:
 872:quantum/quantum.c ****         if (ascii_code == 1) {
 744               		.loc 1 872 0
 745 0010 8823      		tst r24
 746 0012 01F0      		breq .L54
 747 0014 8E01      		movw r16,r28
 748 0016 0F5F      		subi r16,-1
 749 0018 1F4F      		sbci r17,-1
 873:quantum/quantum.c ****           // tap
 750               		.loc 1 873 0
 751 001a 8130      		cpi r24,lo8(1)
 752 001c 01F4      		brne .L56
 753               	.LVL66:
 754               	.LBB33:
 875:quantum/quantum.c ****           register_code(keycode);
 755               		.loc 1 875 0
 756 001e C981      		ldd r28,Y+1
 757               	.LVL67:
 876:quantum/quantum.c ****           unregister_code(keycode);
 758               		.loc 1 876 0
 759 0020 8C2F      		mov r24,r28
 760               	.LVL68:
 761 0022 0E94 0000 		call register_code
 762               	.LVL69:
 877:quantum/quantum.c ****         } else if (ascii_code == 2) {
 763               		.loc 1 877 0
 764 0026 8C2F      		mov r24,r28
 765 0028 00C0      		rjmp .L64
 766               	.LVL70:
 767               	.L56:
 768               	.LBE33:
 878:quantum/quantum.c ****           // down
 769               		.loc 1 878 0
 770 002a 8230      		cpi r24,lo8(2)
 771 002c 01F4      		brne .L58
 772               	.LVL71:
 773               	.LBB34:
 881:quantum/quantum.c ****         } else if (ascii_code == 3) {
 774               		.loc 1 881 0
 775 002e 8981      		ldd r24,Y+1
 776               	.LVL72:
 777 0030 0E94 0000 		call register_code
 778               	.LVL73:
 779               	.L63:
 880:quantum/quantum.c ****           register_code(keycode);
 780               		.loc 1 880 0
 781 0034 E801      		movw r28,r16
 782               	.LBE34:
 783 0036 00C0      		rjmp .L57
 784               	.LVL74:
 785               	.L58:
 882:quantum/quantum.c ****           // up
 786               		.loc 1 882 0
 787 0038 8330      		cpi r24,lo8(3)
 788 003a 01F4      		brne .L59
 789               	.LVL75:
 790               	.LBB35:
 885:quantum/quantum.c ****         } else {
 791               		.loc 1 885 0
 792 003c 8981      		ldd r24,Y+1
 793               	.LVL76:
 794               	.L64:
 795 003e 0E94 0000 		call unregister_code
 796               	.LVL77:
 797 0042 00C0      		rjmp .L63
 798               	.LVL78:
 799               	.L59:
 800               	.LBE35:
 887:quantum/quantum.c ****         }
 801               		.loc 1 887 0
 802 0044 0E94 0000 		call send_char
 803               	.LVL79:
 804               	.L57:
 889:quantum/quantum.c ****         // interval
 805               		.loc 1 889 0
 806 0048 2196      		adiw r28,1
 807               	.LVL80:
 808               	.LBB36:
 891:quantum/quantum.c ****     }
 809               		.loc 1 891 0
 810 004a 8F2D      		mov r24,r15
 811               	.LVL81:
 812               	.L60:
 891:quantum/quantum.c ****     }
 813               		.loc 1 891 0 is_stmt 0 discriminator 1
 814 004c 8823      		tst r24
 815 004e 01F0      		breq .L62
 816               	.LVL82:
 817               	.LBB37:
 818               	.LBB38:
 819               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 820               		.loc 3 163 0 is_stmt 1
 821 0050 EFE9      		ldi r30,lo8(3999)
 822 0052 FFE0      		ldi r31,hi8(3999)
 823 0054 3197      	1:	sbiw r30,1
 824 0056 01F4      		brne 1b
 825 0058 00C0      		rjmp .
 826 005a 0000      		nop
 827 005c 8150      		subi r24,lo8(-(-1))
 828               	.LVL83:
 829 005e 00C0      		rjmp .L60
 830               	.LVL84:
 831               	.L54:
 832               	/* epilogue start */
 833               	.LBE38:
 834               	.LBE37:
 835               	.LBE36:
 836               	.LBE32:
 893:quantum/quantum.c **** 
 837               		.loc 1 893 0
 838 0060 DF91      		pop r29
 839 0062 CF91      		pop r28
 840               	.LVL85:
 841 0064 1F91      		pop r17
 842 0066 0F91      		pop r16
 843 0068 FF90      		pop r15
 844               	.LVL86:
 845 006a 0895      		ret
 846               		.cfi_endproc
 847               	.LFE44:
 849               		.section	.text.send_string,"ax",@progbits
 850               	.global	send_string
 852               	send_string:
 853               	.LFB42:
 861:quantum/quantum.c ****   send_string_with_delay(str, 0);
 854               		.loc 1 861 0
 855               		.cfi_startproc
 856               	.LVL87:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 862:quantum/quantum.c **** }
 861               		.loc 1 862 0
 862 0000 60E0      		ldi r22,0
 863 0002 0C94 0000 		jmp send_string_with_delay
 864               	.LVL88:
 865               		.cfi_endproc
 866               	.LFE42:
 868               		.section	.text.send_string_with_delay_P,"ax",@progbits
 869               	.global	send_string_with_delay_P
 871               	send_string_with_delay_P:
 872               	.LFB45:
 895:quantum/quantum.c ****     while (1) {
 873               		.loc 1 895 0
 874               		.cfi_startproc
 875               	.LVL89:
 876 0000 0F93      		push r16
 877               	.LCFI16:
 878               		.cfi_def_cfa_offset 3
 879               		.cfi_offset 16, -2
 880 0002 1F93      		push r17
 881               	.LCFI17:
 882               		.cfi_def_cfa_offset 4
 883               		.cfi_offset 17, -3
 884 0004 CF93      		push r28
 885               	.LCFI18:
 886               		.cfi_def_cfa_offset 5
 887               		.cfi_offset 28, -4
 888 0006 DF93      		push r29
 889               	.LCFI19:
 890               		.cfi_def_cfa_offset 6
 891               		.cfi_offset 29, -5
 892               	/* prologue: function */
 893               	/* frame size = 0 */
 894               	/* stack size = 4 */
 895               	.L__stack_usage = 4
 896 0008 EC01      		movw r28,r24
 897 000a 062F      		mov r16,r22
 898               	.LVL90:
 899               	.L74:
 900               	.LBB39:
 901               	.LBB40:
 897:quantum/quantum.c ****         if (!ascii_code) break;
 902               		.loc 1 897 0
 903 000c FE01      		movw r30,r28
 904               	/* #APP */
 905               	 ;  897 "quantum/quantum.c" 1
 906 000e 8491      		lpm r24, Z
 907               		
 908               	 ;  0 "" 2
 909               	.LVL91:
 910               	/* #NOAPP */
 911               	.LBE40:
 898:quantum/quantum.c ****         if (ascii_code == 1) {
 912               		.loc 1 898 0
 913 0010 8823      		tst r24
 914 0012 01F0      		breq .L66
 915 0014 9E01      		movw r18,r28
 916 0016 2F5F      		subi r18,-1
 917 0018 3F4F      		sbci r19,-1
 899:quantum/quantum.c ****           // tap
 918               		.loc 1 899 0
 919 001a 8130      		cpi r24,lo8(1)
 920 001c 01F4      		brne .L68
 921               	.LBB41:
 922               	.LBB42:
 901:quantum/quantum.c ****           register_code(keycode);
 923               		.loc 1 901 0
 924 001e E901      		movw r28,r18
 925               	.LVL92:
 926 0020 F901      		movw r30,r18
 927               	.LVL93:
 928               	/* #APP */
 929               	 ;  901 "quantum/quantum.c" 1
 930 0022 1491      		lpm r17, Z
 931               		
 932               	 ;  0 "" 2
 933               	.LVL94:
 934               	/* #NOAPP */
 935               	.LBE42:
 902:quantum/quantum.c ****           unregister_code(keycode);
 936               		.loc 1 902 0
 937 0024 812F      		mov r24,r17
 938               	.LVL95:
 939 0026 0E94 0000 		call register_code
 940               	.LVL96:
 903:quantum/quantum.c ****         } else if (ascii_code == 2) {
 941               		.loc 1 903 0
 942 002a 812F      		mov r24,r17
 943 002c 00C0      		rjmp .L75
 944               	.LVL97:
 945               	.L68:
 946               	.LBE41:
 904:quantum/quantum.c ****           // down
 947               		.loc 1 904 0
 948 002e 8230      		cpi r24,lo8(2)
 949 0030 01F4      		brne .L70
 950               	.LBB43:
 951               	.LBB44:
 906:quantum/quantum.c ****           register_code(keycode);
 952               		.loc 1 906 0
 953 0032 E901      		movw r28,r18
 954               	.LVL98:
 955 0034 F901      		movw r30,r18
 956               	.LVL99:
 957               	/* #APP */
 958               	 ;  906 "quantum/quantum.c" 1
 959 0036 8491      		lpm r24, Z
 960               		
 961               	 ;  0 "" 2
 962               	.LVL100:
 963               	/* #NOAPP */
 964               	.LBE44:
 907:quantum/quantum.c ****         } else if (ascii_code == 3) {
 965               		.loc 1 907 0
 966 0038 0E94 0000 		call register_code
 967               	.LVL101:
 968               	.LBE43:
 969 003c 00C0      		rjmp .L69
 970               	.LVL102:
 971               	.L70:
 908:quantum/quantum.c ****           // up
 972               		.loc 1 908 0
 973 003e 8330      		cpi r24,lo8(3)
 974 0040 01F4      		brne .L71
 975               	.LBB45:
 976               	.LBB46:
 910:quantum/quantum.c ****           unregister_code(keycode);
 977               		.loc 1 910 0
 978 0042 E901      		movw r28,r18
 979               	.LVL103:
 980 0044 F901      		movw r30,r18
 981               	.LVL104:
 982               	/* #APP */
 983               	 ;  910 "quantum/quantum.c" 1
 984 0046 8491      		lpm r24, Z
 985               		
 986               	 ;  0 "" 2
 987               	.LVL105:
 988               	/* #NOAPP */
 989               	.L75:
 990               	.LBE46:
 911:quantum/quantum.c ****         } else {
 991               		.loc 1 911 0
 992 0048 0E94 0000 		call unregister_code
 993               	.LVL106:
 994               	.LBE45:
 995 004c 00C0      		rjmp .L69
 996               	.LVL107:
 997               	.L71:
 913:quantum/quantum.c ****         }
 998               		.loc 1 913 0
 999 004e 0E94 0000 		call send_char
 1000               	.LVL108:
 1001               	.L69:
 915:quantum/quantum.c ****         // interval
 1002               		.loc 1 915 0
 1003 0052 2196      		adiw r28,1
 1004               	.LVL109:
 1005               	.LBB47:
 917:quantum/quantum.c ****     }
 1006               		.loc 1 917 0
 1007 0054 802F      		mov r24,r16
 1008               	.LVL110:
 1009               	.L72:
 917:quantum/quantum.c ****     }
 1010               		.loc 1 917 0 is_stmt 0 discriminator 1
 1011 0056 8823      		tst r24
 1012 0058 01F0      		breq .L74
 1013               	.LVL111:
 1014               	.LBB48:
 1015               	.LBB49:
 1016               		.loc 3 163 0 is_stmt 1
 1017 005a EFE9      		ldi r30,lo8(3999)
 1018 005c FFE0      		ldi r31,hi8(3999)
 1019 005e 3197      	1:	sbiw r30,1
 1020 0060 01F4      		brne 1b
 1021 0062 00C0      		rjmp .
 1022 0064 0000      		nop
 1023 0066 8150      		subi r24,lo8(-(-1))
 1024               	.LVL112:
 1025 0068 00C0      		rjmp .L72
 1026               	.LVL113:
 1027               	.L66:
 1028               	/* epilogue start */
 1029               	.LBE49:
 1030               	.LBE48:
 1031               	.LBE47:
 1032               	.LBE39:
 919:quantum/quantum.c **** 
 1033               		.loc 1 919 0
 1034 006a DF91      		pop r29
 1035 006c CF91      		pop r28
 1036               	.LVL114:
 1037 006e 1F91      		pop r17
 1038 0070 0F91      		pop r16
 1039               	.LVL115:
 1040 0072 0895      		ret
 1041               		.cfi_endproc
 1042               	.LFE45:
 1044               		.section	.text.send_string_P,"ax",@progbits
 1045               	.global	send_string_P
 1047               	send_string_P:
 1048               	.LFB43:
 865:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1049               		.loc 1 865 0
 1050               		.cfi_startproc
 1051               	.LVL116:
 1052               	/* prologue: function */
 1053               	/* frame size = 0 */
 1054               	/* stack size = 0 */
 1055               	.L__stack_usage = 0
 866:quantum/quantum.c **** }
 1056               		.loc 1 866 0
 1057 0000 60E0      		ldi r22,0
 1058 0002 0C94 0000 		jmp send_string_with_delay_P
 1059               	.LVL117:
 1060               		.cfi_endproc
 1061               	.LFE43:
 1063               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1064               	.global	set_single_persistent_default_layer
 1066               	set_single_persistent_default_layer:
 1067               	.LFB47:
 934:quantum/quantum.c **** 
 935:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1068               		.loc 1 935 0
 1069               		.cfi_startproc
 1070               	.LVL118:
 1071 0000 CF93      		push r28
 1072               	.LCFI20:
 1073               		.cfi_def_cfa_offset 3
 1074               		.cfi_offset 28, -2
 1075 0002 DF93      		push r29
 1076               	.LCFI21:
 1077               		.cfi_def_cfa_offset 4
 1078               		.cfi_offset 29, -3
 1079               	/* prologue: function */
 1080               	/* frame size = 0 */
 1081               	/* stack size = 2 */
 1082               	.L__stack_usage = 2
 936:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 937:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 938:quantum/quantum.c ****   #endif
 939:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1083               		.loc 1 939 0
 1084 0004 61E0      		ldi r22,lo8(1)
 1085 0006 70E0      		ldi r23,0
 1086 0008 EB01      		movw r28,r22
 1087 000a 00C0      		rjmp 2f
 1088               		1:
 1089 000c CC0F      		lsl r28
 1090 000e DD1F      		rol r29
 1091               		2:
 1092 0010 8A95      		dec r24
 1093 0012 02F4      		brpl 1b
 1094 0014 8C2F      		mov r24,r28
 1095               	.LVL119:
 1096 0016 0E94 0000 		call eeconfig_update_default_layer
 1097               	.LVL120:
 940:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1098               		.loc 1 940 0
 1099 001a BE01      		movw r22,r28
 1100 001c 80E0      		ldi r24,0
 1101 001e 90E0      		ldi r25,0
 1102               	/* epilogue start */
 941:quantum/quantum.c **** }
 1103               		.loc 1 941 0
 1104 0020 DF91      		pop r29
 1105 0022 CF91      		pop r28
 940:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1106               		.loc 1 940 0
 1107 0024 0C94 0000 		jmp default_layer_set
 1108               	.LVL121:
 1109               		.cfi_endproc
 1110               	.LFE47:
 1112               		.section	.text.update_tri_layer_state,"ax",@progbits
 1113               	.global	update_tri_layer_state
 1115               	update_tri_layer_state:
 1116               	.LFB48:
 942:quantum/quantum.c **** 
 943:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1117               		.loc 1 943 0
 1118               		.cfi_startproc
 1119               	.LVL122:
 1120 0000 8F92      		push r8
 1121               	.LCFI22:
 1122               		.cfi_def_cfa_offset 3
 1123               		.cfi_offset 8, -2
 1124 0002 9F92      		push r9
 1125               	.LCFI23:
 1126               		.cfi_def_cfa_offset 4
 1127               		.cfi_offset 9, -3
 1128 0004 AF92      		push r10
 1129               	.LCFI24:
 1130               		.cfi_def_cfa_offset 5
 1131               		.cfi_offset 10, -4
 1132 0006 BF92      		push r11
 1133               	.LCFI25:
 1134               		.cfi_def_cfa_offset 6
 1135               		.cfi_offset 11, -5
 1136 0008 CF92      		push r12
 1137               	.LCFI26:
 1138               		.cfi_def_cfa_offset 7
 1139               		.cfi_offset 12, -6
 1140 000a DF92      		push r13
 1141               	.LCFI27:
 1142               		.cfi_def_cfa_offset 8
 1143               		.cfi_offset 13, -7
 1144 000c EF92      		push r14
 1145               	.LCFI28:
 1146               		.cfi_def_cfa_offset 9
 1147               		.cfi_offset 14, -8
 1148 000e FF92      		push r15
 1149               	.LCFI29:
 1150               		.cfi_def_cfa_offset 10
 1151               		.cfi_offset 15, -9
 1152 0010 0F93      		push r16
 1153               	.LCFI30:
 1154               		.cfi_def_cfa_offset 11
 1155               		.cfi_offset 16, -10
 1156 0012 1F93      		push r17
 1157               	.LCFI31:
 1158               		.cfi_def_cfa_offset 12
 1159               		.cfi_offset 17, -11
 1160               	/* prologue: function */
 1161               	/* frame size = 0 */
 1162               	/* stack size = 10 */
 1163               	.L__stack_usage = 10
 1164 0014 6B01      		movw r12,r22
 1165 0016 7C01      		movw r14,r24
 944:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1166               		.loc 1 944 0
 1167 0018 81E0      		ldi r24,lo8(1)
 1168 001a 90E0      		ldi r25,0
 1169 001c A0E0      		ldi r26,0
 1170 001e B0E0      		ldi r27,0
 1171 0020 4C01      		movw r8,r24
 1172 0022 5D01      		movw r10,r26
 1173 0024 00C0      		rjmp 2f
 1174               		1:
 1175 0026 880C      		lsl r8
 1176 0028 991C      		rol r9
 1177 002a AA1C      		rol r10
 1178 002c BB1C      		rol r11
 1179               		2:
 1180 002e 4A95      		dec r20
 1181 0030 02F4      		brpl 1b
 1182 0032 AC01      		movw r20,r24
 1183 0034 BD01      		movw r22,r26
 1184               	.LVL123:
 1185 0036 00C0      		rjmp 2f
 1186               		1:
 1187 0038 440F      		lsl r20
 1188 003a 551F      		rol r21
 1189 003c 661F      		rol r22
 1190 003e 771F      		rol r23
 1191               		2:
 1192 0040 2A95      		dec r18
 1193 0042 02F4      		brpl 1b
 1194 0044 4829      		or r20,r8
 1195 0046 5929      		or r21,r9
 1196 0048 6A29      		or r22,r10
 1197 004a 7B29      		or r23,r11
 1198               	.LVL124:
 945:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1199               		.loc 1 945 0
 1200 004c 00C0      		rjmp 2f
 1201               		1:
 1202 004e 880F      		lsl r24
 1203 0050 991F      		rol r25
 1204 0052 AA1F      		rol r26
 1205 0054 BB1F      		rol r27
 1206               		2:
 1207 0056 0A95      		dec r16
 1208 0058 02F4      		brpl 1b
 1209               	.LVL125:
 946:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1210               		.loc 1 946 0
 1211 005a 8A01      		movw r16,r20
 1212 005c 9B01      		movw r18,r22
 1213               	.LVL126:
 1214 005e 0C21      		and r16,r12
 1215 0060 1D21      		and r17,r13
 1216 0062 2E21      		and r18,r14
 1217 0064 3F21      		and r19,r15
 1218 0066 0417      		cp r16,r20
 1219 0068 1507      		cpc r17,r21
 1220 006a 2607      		cpc r18,r22
 1221 006c 3707      		cpc r19,r23
 1222 006e 01F4      		brne .L79
 1223               		.loc 1 946 0 is_stmt 0 discriminator 1
 1224 0070 BC01      		movw r22,r24
 1225 0072 CD01      		movw r24,r26
 1226               	.LVL127:
 1227 0074 6C29      		or r22,r12
 1228 0076 7D29      		or r23,r13
 1229 0078 8E29      		or r24,r14
 1230 007a 9F29      		or r25,r15
 1231 007c 00C0      		rjmp .L80
 1232               	.L79:
 1233               		.loc 1 946 0 discriminator 2
 1234 007e 8095      		com r24
 1235 0080 9095      		com r25
 1236 0082 A095      		com r26
 1237 0084 B095      		com r27
 1238               	.LVL128:
 1239 0086 BC01      		movw r22,r24
 1240 0088 CD01      		movw r24,r26
 1241 008a 6C21      		and r22,r12
 1242 008c 7D21      		and r23,r13
 1243 008e 8E21      		and r24,r14
 1244 0090 9F21      		and r25,r15
 1245               	.LVL129:
 1246               	.L80:
 1247               	/* epilogue start */
 947:quantum/quantum.c **** }
 1248               		.loc 1 947 0 is_stmt 1 discriminator 4
 1249 0092 1F91      		pop r17
 1250 0094 0F91      		pop r16
 1251 0096 FF90      		pop r15
 1252 0098 EF90      		pop r14
 1253 009a DF90      		pop r13
 1254 009c CF90      		pop r12
 1255               	.LVL130:
 1256 009e BF90      		pop r11
 1257 00a0 AF90      		pop r10
 1258 00a2 9F90      		pop r9
 1259 00a4 8F90      		pop r8
 1260 00a6 0895      		ret
 1261               		.cfi_endproc
 1262               	.LFE48:
 1264               		.section	.text.update_tri_layer,"ax",@progbits
 1265               	.global	update_tri_layer
 1267               	update_tri_layer:
 1268               	.LFB49:
 948:quantum/quantum.c **** 
 949:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1269               		.loc 1 949 0
 1270               		.cfi_startproc
 1271               	.LVL131:
 1272 0000 0F93      		push r16
 1273               	.LCFI32:
 1274               		.cfi_def_cfa_offset 3
 1275               		.cfi_offset 16, -2
 1276               	/* prologue: function */
 1277               	/* frame size = 0 */
 1278               	/* stack size = 1 */
 1279               	.L__stack_usage = 1
 1280 0002 382F      		mov r19,r24
 1281 0004 262F      		mov r18,r22
 950:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1282               		.loc 1 950 0
 1283 0006 6091 0000 		lds r22,layer_state
 1284 000a 7091 0000 		lds r23,layer_state+1
 1285 000e 8091 0000 		lds r24,layer_state+2
 1286 0012 9091 0000 		lds r25,layer_state+3
 1287               	.LVL132:
 1288 0016 042F      		mov r16,r20
 1289 0018 432F      		mov r20,r19
 1290               	.LVL133:
 1291 001a 0E94 0000 		call update_tri_layer_state
 1292               	.LVL134:
 1293               	/* epilogue start */
 951:quantum/quantum.c **** }
 1294               		.loc 1 951 0
 1295 001e 0F91      		pop r16
 1296               	.LVL135:
 950:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1297               		.loc 1 950 0
 1298 0020 0C94 0000 		jmp layer_state_set
 1299               	.LVL136:
 1300               		.cfi_endproc
 1301               	.LFE49:
 1303               		.section	.text.tap_random_base64,"ax",@progbits
 1304               	.global	tap_random_base64
 1306               	tap_random_base64:
 1307               	.LFB50:
 952:quantum/quantum.c **** 
 953:quantum/quantum.c **** void tap_random_base64(void) {
 1308               		.loc 1 953 0
 1309               		.cfi_startproc
 1310 0000 CF93      		push r28
 1311               	.LCFI33:
 1312               		.cfi_def_cfa_offset 3
 1313               		.cfi_offset 28, -2
 1314 0002 DF93      		push r29
 1315               	.LCFI34:
 1316               		.cfi_def_cfa_offset 4
 1317               		.cfi_offset 29, -3
 1318               	/* prologue: function */
 1319               	/* frame size = 0 */
 1320               	/* stack size = 2 */
 1321               	.L__stack_usage = 2
 954:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 955:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1322               		.loc 1 955 0
 1323 0004 26B5      		in r18,0x26
 1324 0006 C091 8400 		lds r28,132
 1325 000a D091 8500 		lds r29,132+1
 1326 000e 4091 9400 		lds r20,148
 1327 0012 5091 9500 		lds r21,148+1
 1328 0016 8091 BE00 		lds r24,190
 1329 001a 9091 BF00 		lds r25,190+1
 1330 001e C40F      		add r28,r20
 1331 0020 C20F      		add r28,r18
 1332 0022 8C0F      		add r24,r28
 1333 0024 C82F      		mov r28,r24
 1334 0026 CF73      		andi r28,lo8(63)
 1335               	.LVL137:
 956:quantum/quantum.c ****   #else
 957:quantum/quantum.c ****     uint8_t key = rand() % 64;
 958:quantum/quantum.c ****   #endif
 959:quantum/quantum.c ****   switch (key) {
 1336               		.loc 1 959 0
 1337 0028 CE33      		cpi r28,lo8(62)
 1338 002a 00F4      		brsh .L84
 1339 002c C533      		cpi r28,lo8(53)
 1340 002e 00F4      		brsh .L85
 1341 0030 CA31      		cpi r28,lo8(26)
 1342 0032 00F0      		brlo .L83
 1343 0034 C433      		cpi r28,lo8(52)
 1344 0036 00F4      		brsh .L90
 960:quantum/quantum.c ****     case 0 ... 25:
 961:quantum/quantum.c ****       register_code(KC_LSFT);
 962:quantum/quantum.c ****       register_code(key + KC_A);
 963:quantum/quantum.c ****       unregister_code(key + KC_A);
 964:quantum/quantum.c ****       unregister_code(KC_LSFT);
 965:quantum/quantum.c ****       break;
 966:quantum/quantum.c ****     case 26 ... 51:
 967:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1345               		.loc 1 967 0
 1346 0038 C651      		subi r28,lo8(-(-22))
 1347               	.LVL138:
 1348 003a 00C0      		rjmp .L93
 1349               	.LVL139:
 1350               	.L84:
 959:quantum/quantum.c ****     case 0 ... 25:
 1351               		.loc 1 959 0
 1352 003c CE33      		cpi r28,lo8(62)
 1353 003e 01F0      		breq .L88
 1354 0040 CF33      		cpi r28,lo8(63)
 1355 0042 01F0      		breq .L89
 1356               	.L83:
 961:quantum/quantum.c ****       register_code(key + KC_A);
 1357               		.loc 1 961 0
 1358 0044 81EE      		ldi r24,lo8(-31)
 1359 0046 0E94 0000 		call register_code
 1360               	.LVL140:
 962:quantum/quantum.c ****       unregister_code(key + KC_A);
 1361               		.loc 1 962 0
 1362 004a CC5F      		subi r28,lo8(-(4))
 1363               	.LVL141:
 1364 004c 8C2F      		mov r24,r28
 1365 004e 0E94 0000 		call register_code
 1366               	.LVL142:
 963:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1367               		.loc 1 963 0
 1368 0052 8C2F      		mov r24,r28
 1369 0054 00C0      		rjmp .L92
 1370               	.LVL143:
 1371               	.L90:
 968:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 969:quantum/quantum.c ****       break;
 970:quantum/quantum.c ****     case 52:
 971:quantum/quantum.c ****       register_code(KC_0);
 1372               		.loc 1 971 0
 1373 0056 87E2      		ldi r24,lo8(39)
 1374 0058 0E94 0000 		call register_code
 1375               	.LVL144:
 972:quantum/quantum.c ****       unregister_code(KC_0);
 1376               		.loc 1 972 0
 1377 005c 87E2      		ldi r24,lo8(39)
 1378 005e 00C0      		rjmp .L91
 1379               	.L85:
 973:quantum/quantum.c ****       break;
 974:quantum/quantum.c ****     case 53 ... 61:
 975:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1380               		.loc 1 975 0
 1381 0060 C751      		subi r28,lo8(-(-23))
 1382               	.LVL145:
 1383               	.L93:
 1384 0062 8C2F      		mov r24,r28
 1385               	.LVL146:
 1386 0064 0E94 0000 		call register_code
 1387               	.LVL147:
 976:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1388               		.loc 1 976 0
 1389 0068 8C2F      		mov r24,r28
 1390 006a 00C0      		rjmp .L91
 1391               	.LVL148:
 1392               	.L88:
 977:quantum/quantum.c ****       break;
 978:quantum/quantum.c ****     case 62:
 979:quantum/quantum.c ****       register_code(KC_LSFT);
 1393               		.loc 1 979 0
 1394 006c 81EE      		ldi r24,lo8(-31)
 1395 006e 0E94 0000 		call register_code
 1396               	.LVL149:
 980:quantum/quantum.c ****       register_code(KC_EQL);
 1397               		.loc 1 980 0
 1398 0072 8EE2      		ldi r24,lo8(46)
 1399 0074 0E94 0000 		call register_code
 1400               	.LVL150:
 981:quantum/quantum.c ****       unregister_code(KC_EQL);
 1401               		.loc 1 981 0
 1402 0078 8EE2      		ldi r24,lo8(46)
 1403               	.LVL151:
 1404               	.L92:
 1405 007a 0E94 0000 		call unregister_code
 1406               	.LVL152:
 982:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1407               		.loc 1 982 0
 1408 007e 81EE      		ldi r24,lo8(-31)
 1409 0080 00C0      		rjmp .L91
 1410               	.LVL153:
 1411               	.L89:
 983:quantum/quantum.c ****       break;
 984:quantum/quantum.c ****     case 63:
 985:quantum/quantum.c ****       register_code(KC_SLSH);
 1412               		.loc 1 985 0
 1413 0082 88E3      		ldi r24,lo8(56)
 1414 0084 0E94 0000 		call register_code
 1415               	.LVL154:
 986:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1416               		.loc 1 986 0
 1417 0088 88E3      		ldi r24,lo8(56)
 1418               	.LVL155:
 1419               	.L91:
 1420               	/* epilogue start */
 987:quantum/quantum.c ****       break;
 988:quantum/quantum.c ****   }
 989:quantum/quantum.c **** }
 1421               		.loc 1 989 0
 1422 008a DF91      		pop r29
 1423 008c CF91      		pop r28
 986:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1424               		.loc 1 986 0
 1425 008e 0C94 0000 		jmp unregister_code
 1426               	.LVL156:
 1427               		.cfi_endproc
 1428               	.LFE50:
 1430               		.section	.text.bootmagic_lite,"ax",@progbits
 1431               		.weak	bootmagic_lite
 1433               	bootmagic_lite:
 1434               	.LFB51:
 990:quantum/quantum.c **** 
 991:quantum/quantum.c **** __attribute__((weak))
 992:quantum/quantum.c **** void bootmagic_lite(void) {
 1435               		.loc 1 992 0
 1436               		.cfi_startproc
 1437               	/* prologue: function */
 1438               	/* frame size = 0 */
 1439               	/* stack size = 0 */
 1440               	.L__stack_usage = 0
 993:quantum/quantum.c ****   // The lite version of TMK's bootmagic based on Wilba.
 994:quantum/quantum.c ****   // 100% less potential for accidentally making the
 995:quantum/quantum.c ****   // keyboard do stupid things.
 996:quantum/quantum.c **** 
 997:quantum/quantum.c ****   // We need multiple scans because debouncing can't be turned off.
 998:quantum/quantum.c ****   matrix_scan();
 1441               		.loc 1 998 0
 1442 0000 0E94 0000 		call matrix_scan
 1443               	.LVL157:
 1444               	.LBB50:
 1445               	.LBB51:
 1446               		.loc 3 163 0
 1447 0004 8FE3      		ldi r24,lo8(-25537)
 1448 0006 9CE9      		ldi r25,hi8(-25537)
 1449 0008 0197      	1:	sbiw r24,1
 1450 000a 01F4      		brne 1b
 1451 000c 00C0      		rjmp .
 1452 000e 0000      		nop
 1453               	.LBE51:
 1454               	.LBE50:
 999:quantum/quantum.c ****   #if defined(DEBOUNCING_DELAY) && DEBOUNCING_DELAY > 0
1000:quantum/quantum.c ****     wait_ms(DEBOUNCING_DELAY * 2);
1001:quantum/quantum.c ****   #elif defined(DEBOUNCE) && DEBOUNCE > 0
1002:quantum/quantum.c ****     wait_ms(DEBOUNCE * 2);
1003:quantum/quantum.c ****   #else
1004:quantum/quantum.c ****     wait_ms(30);
1005:quantum/quantum.c ****   #endif
1006:quantum/quantum.c ****   matrix_scan();
 1455               		.loc 1 1006 0
 1456 0010 0E94 0000 		call matrix_scan
 1457               	.LVL158:
1007:quantum/quantum.c **** 
1008:quantum/quantum.c ****   // If the Esc and space bar are held down on power up,
1009:quantum/quantum.c ****   // reset the EEPROM valid state and jump to bootloader.
1010:quantum/quantum.c ****   // Assumes Esc is at [0,0].
1011:quantum/quantum.c ****   // This isn't very generalized, but we need something that doesn't
1012:quantum/quantum.c ****   // rely on user's keymaps in firmware or EEPROM.
1013:quantum/quantum.c ****   if (matrix_get_row(BOOTMAGIC_LITE_ROW) & (1 << BOOTMAGIC_LITE_COLUMN)) {
 1458               		.loc 1 1013 0
 1459 0014 80E0      		ldi r24,0
 1460 0016 0E94 0000 		call matrix_get_row
 1461               	.LVL159:
 1462 001a 80FF      		sbrs r24,0
 1463 001c 00C0      		rjmp .L94
1014:quantum/quantum.c ****     eeconfig_disable();
 1464               		.loc 1 1014 0
 1465 001e 0E94 0000 		call eeconfig_disable
 1466               	.LVL160:
1015:quantum/quantum.c ****     // Jump to bootloader.
1016:quantum/quantum.c ****     bootloader_jump();
 1467               		.loc 1 1016 0
 1468 0022 0C94 0000 		jmp bootloader_jump
 1469               	.LVL161:
 1470               	.L94:
 1471 0026 0895      		ret
 1472               		.cfi_endproc
 1473               	.LFE51:
 1475               		.section	.text.matrix_init_quantum,"ax",@progbits
 1476               	.global	matrix_init_quantum
 1478               	matrix_init_quantum:
 1479               	.LFB52:
1017:quantum/quantum.c ****   }
1018:quantum/quantum.c **** }
1019:quantum/quantum.c **** 
1020:quantum/quantum.c **** void matrix_init_quantum() {
 1480               		.loc 1 1020 0
 1481               		.cfi_startproc
 1482               	/* prologue: function */
 1483               	/* frame size = 0 */
 1484               	/* stack size = 0 */
 1485               	.L__stack_usage = 0
1021:quantum/quantum.c ****   #ifdef BOOTMAGIC_LITE
1022:quantum/quantum.c ****     bootmagic_lite();
1023:quantum/quantum.c ****   #endif
1024:quantum/quantum.c ****   if (!eeconfig_is_enabled()) {
 1486               		.loc 1 1024 0
 1487 0000 0E94 0000 		call eeconfig_is_enabled
 1488               	.LVL162:
 1489 0004 8111      		cpse r24,__zero_reg__
 1490 0006 00C0      		rjmp .L97
1025:quantum/quantum.c ****     eeconfig_init();
 1491               		.loc 1 1025 0
 1492 0008 0E94 0000 		call eeconfig_init
 1493               	.LVL163:
 1494               	.L97:
1026:quantum/quantum.c ****   }
1027:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
1028:quantum/quantum.c ****     #ifdef LED_MATRIX_ENABLE
1029:quantum/quantum.c ****         led_matrix_init();
1030:quantum/quantum.c ****     #else
1031:quantum/quantum.c ****         backlight_init_ports();
1032:quantum/quantum.c ****     #endif
1033:quantum/quantum.c ****   #endif
1034:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
1035:quantum/quantum.c ****     audio_init();
1036:quantum/quantum.c ****   #endif
1037:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
1038:quantum/quantum.c ****     rgb_matrix_init();
1039:quantum/quantum.c ****   #endif
1040:quantum/quantum.c ****   #ifdef ENCODER_ENABLE
1041:quantum/quantum.c ****     encoder_init();
1042:quantum/quantum.c ****   #endif
1043:quantum/quantum.c ****   #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
1044:quantum/quantum.c ****     unicode_input_mode_init();
1045:quantum/quantum.c ****   #endif
1046:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
1047:quantum/quantum.c ****     haptic_init();
1048:quantum/quantum.c ****   #endif
1049:quantum/quantum.c ****   matrix_init_kb();
 1495               		.loc 1 1049 0
 1496 000c 0C94 0000 		jmp matrix_init_kb
 1497               	.LVL164:
 1498               		.cfi_endproc
 1499               	.LFE52:
 1501               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1502               	.global	matrix_scan_quantum
 1504               	matrix_scan_quantum:
 1505               	.LFB53:
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
1053:quantum/quantum.c **** 
1054:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
1055:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
1056:quantum/quantum.c **** #endif
1057:quantum/quantum.c **** 
1058:quantum/quantum.c **** void matrix_scan_quantum() {
 1506               		.loc 1 1058 0
 1507               		.cfi_startproc
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 0 */
 1511               	.L__stack_usage = 0
1059:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
1060:quantum/quantum.c ****     matrix_scan_music();
1061:quantum/quantum.c ****   #endif
1062:quantum/quantum.c **** 
1063:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
1064:quantum/quantum.c ****     matrix_scan_tap_dance();
1065:quantum/quantum.c ****   #endif
1066:quantum/quantum.c **** 
1067:quantum/quantum.c ****   #ifdef COMBO_ENABLE
1068:quantum/quantum.c ****     matrix_scan_combo();
1069:quantum/quantum.c ****   #endif
1070:quantum/quantum.c **** 
1071:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE)
1072:quantum/quantum.c ****     #if defined(LED_MATRIX_ENABLE)
1073:quantum/quantum.c ****         led_matrix_task();
1074:quantum/quantum.c ****     #elif defined(BACKLIGHT_PIN)
1075:quantum/quantum.c ****         backlight_task();
1076:quantum/quantum.c ****     #endif
1077:quantum/quantum.c ****   #endif
1078:quantum/quantum.c **** 
1079:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
1080:quantum/quantum.c ****     rgb_matrix_task();
1081:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
1082:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
1083:quantum/quantum.c ****     }
1084:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
1085:quantum/quantum.c ****   #endif
1086:quantum/quantum.c **** 
1087:quantum/quantum.c ****   #ifdef ENCODER_ENABLE
1088:quantum/quantum.c ****     encoder_read();
1089:quantum/quantum.c ****   #endif
1090:quantum/quantum.c **** 
1091:quantum/quantum.c ****   #ifdef HAPTIC_ENABLE
1092:quantum/quantum.c ****     haptic_task();
1093:quantum/quantum.c ****   #endif
1094:quantum/quantum.c **** 
1095:quantum/quantum.c ****   matrix_scan_kb();
 1512               		.loc 1 1095 0
 1513 0000 0C94 0000 		jmp matrix_scan_kb
 1514               	.LVL165:
 1515               		.cfi_endproc
 1516               	.LFE53:
 1518               		.section	.text.backlight_init_ports,"ax",@progbits
 1519               		.weak	backlight_init_ports
 1521               	backlight_init_ports:
 1522               	.LFB54:
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
1098:quantum/quantum.c **** 
1099:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
1100:quantum/quantum.c **** 
1101:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
1102:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
1103:quantum/quantum.c **** #  define TCCRxA TCCR1A
1104:quantum/quantum.c **** #  define TCCRxB TCCR1B
1105:quantum/quantum.c **** #  define COMxx1 COM1C1
1106:quantum/quantum.c **** #  define OCRxx  OCR1C
1107:quantum/quantum.c **** #  define ICRx   ICR1
1108:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
1109:quantum/quantum.c **** #  define TCCRxA TCCR1A
1110:quantum/quantum.c **** #  define TCCRxB TCCR1B
1111:quantum/quantum.c **** #  define COMxx1 COM1B1
1112:quantum/quantum.c **** #  define OCRxx  OCR1B
1113:quantum/quantum.c **** #  define ICRx   ICR1
1114:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
1115:quantum/quantum.c **** #  define TCCRxA TCCR1A
1116:quantum/quantum.c **** #  define TCCRxB TCCR1B
1117:quantum/quantum.c **** #  define COMxx1 COM1A1
1118:quantum/quantum.c **** #  define OCRxx  OCR1A
1119:quantum/quantum.c **** #  define ICRx   ICR1
1120:quantum/quantum.c **** #elif BACKLIGHT_PIN == C6
1121:quantum/quantum.c **** #  define TCCRxA TCCR3A
1122:quantum/quantum.c **** #  define TCCRxB TCCR3B
1123:quantum/quantum.c **** #  define COMxx1 COM1A1
1124:quantum/quantum.c **** #  define OCRxx  OCR3A
1125:quantum/quantum.c **** #  define ICRx   ICR3
1126:quantum/quantum.c **** #else
1127:quantum/quantum.c **** #  define NO_HARDWARE_PWM
1128:quantum/quantum.c **** #endif
1129:quantum/quantum.c **** 
1130:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
1131:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
1132:quantum/quantum.c **** #endif
1133:quantum/quantum.c **** 
1134:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
1135:quantum/quantum.c **** 
1136:quantum/quantum.c **** __attribute__ ((weak))
1137:quantum/quantum.c **** void backlight_init_ports(void)
1138:quantum/quantum.c **** {
1139:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1140:quantum/quantum.c ****   // DDRx |= n
1141:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1142:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1143:quantum/quantum.c ****     // PORTx &= ~n
1144:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1145:quantum/quantum.c ****   #else
1146:quantum/quantum.c ****     // PORTx |= n
1147:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1148:quantum/quantum.c ****   #endif
1149:quantum/quantum.c **** }
1150:quantum/quantum.c **** 
1151:quantum/quantum.c **** __attribute__ ((weak))
1152:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1153:quantum/quantum.c **** 
1154:quantum/quantum.c **** uint8_t backlight_tick = 0;
1155:quantum/quantum.c **** 
1156:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1157:quantum/quantum.c **** void backlight_task(void) {
1158:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
1159:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
1160:quantum/quantum.c ****       // PORTx &= ~n
1161:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1162:quantum/quantum.c ****     #else
1163:quantum/quantum.c ****       // PORTx |= n
1164:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1165:quantum/quantum.c ****     #endif
1166:quantum/quantum.c ****   } else {
1167:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
1168:quantum/quantum.c ****       // PORTx |= n
1169:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1170:quantum/quantum.c ****     #else
1171:quantum/quantum.c ****       // PORTx &= ~n
1172:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1173:quantum/quantum.c ****     #endif
1174:quantum/quantum.c ****   }
1175:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
1176:quantum/quantum.c **** }
1177:quantum/quantum.c **** #endif
1178:quantum/quantum.c **** 
1179:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1180:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
1181:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
1182:quantum/quantum.c ****   #endif
1183:quantum/quantum.c **** #endif
1184:quantum/quantum.c **** 
1185:quantum/quantum.c **** #else // pwm through timer
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
1188:quantum/quantum.c **** 
1189:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
1190:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
1191:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
1192:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
1193:quantum/quantum.c ****   else {
1194:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
1195:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
1196:quantum/quantum.c ****     // and revert what we've done again after squaring.
1197:quantum/quantum.c ****     y = y * y * y >> 8;
1198:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
1199:quantum/quantum.c ****       return 0xFFFFU;
1200:quantum/quantum.c ****     else
1201:quantum/quantum.c ****       return (uint16_t) y;
1202:quantum/quantum.c ****   }
1203:quantum/quantum.c **** }
1204:quantum/quantum.c **** 
1205:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
1206:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
1207:quantum/quantum.c **** 	OCRxx = val;
1208:quantum/quantum.c **** }
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
1211:quantum/quantum.c **** __attribute__ ((weak))
1212:quantum/quantum.c **** void backlight_set(uint8_t level) {
1213:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
1214:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
1215:quantum/quantum.c **** 
1216:quantum/quantum.c ****   if (level == 0) {
1217:quantum/quantum.c ****     // Turn off PWM control on backlight pin
1218:quantum/quantum.c ****     TCCRxA &= ~(_BV(COMxx1));
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     // Turn on PWM control of backlight pin
1221:quantum/quantum.c ****     TCCRxA |= _BV(COMxx1);
1222:quantum/quantum.c ****   }
1223:quantum/quantum.c ****   // Set the brightness
1224:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1225:quantum/quantum.c **** }
1226:quantum/quantum.c **** 
1227:quantum/quantum.c **** void backlight_task(void) {}
1228:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1229:quantum/quantum.c **** 
1230:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1233:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1234:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1235:quantum/quantum.c **** #define BREATHING_STEPS 128
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1238:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1239:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1240:quantum/quantum.c **** 
1241:quantum/quantum.c **** bool is_breathing(void) {
1242:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1243:quantum/quantum.c **** }
1244:quantum/quantum.c **** 
1245:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1246:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1247:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1248:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1249:quantum/quantum.c **** 
1250:quantum/quantum.c **** void breathing_enable(void)
1251:quantum/quantum.c **** {
1252:quantum/quantum.c ****   breathing_counter = 0;
1253:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1254:quantum/quantum.c ****   breathing_interrupt_enable();
1255:quantum/quantum.c **** }
1256:quantum/quantum.c **** 
1257:quantum/quantum.c **** void breathing_pulse(void)
1258:quantum/quantum.c **** {
1259:quantum/quantum.c ****     if (get_backlight_level() == 0)
1260:quantum/quantum.c ****       breathing_min();
1261:quantum/quantum.c ****     else
1262:quantum/quantum.c ****       breathing_max();
1263:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1264:quantum/quantum.c ****     breathing_interrupt_enable();
1265:quantum/quantum.c **** }
1266:quantum/quantum.c **** 
1267:quantum/quantum.c **** void breathing_disable(void)
1268:quantum/quantum.c **** {
1269:quantum/quantum.c ****     breathing_interrupt_disable();
1270:quantum/quantum.c ****     // Restore backlight level
1271:quantum/quantum.c ****     backlight_set(get_backlight_level());
1272:quantum/quantum.c **** }
1273:quantum/quantum.c **** 
1274:quantum/quantum.c **** void breathing_self_disable(void)
1275:quantum/quantum.c **** {
1276:quantum/quantum.c ****   if (get_backlight_level() == 0)
1277:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1278:quantum/quantum.c ****   else
1279:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1280:quantum/quantum.c **** }
1281:quantum/quantum.c **** 
1282:quantum/quantum.c **** void breathing_toggle(void) {
1283:quantum/quantum.c ****   if (is_breathing())
1284:quantum/quantum.c ****     breathing_disable();
1285:quantum/quantum.c ****   else
1286:quantum/quantum.c ****     breathing_enable();
1287:quantum/quantum.c **** }
1288:quantum/quantum.c **** 
1289:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1290:quantum/quantum.c **** {
1291:quantum/quantum.c ****   if (!value)
1292:quantum/quantum.c ****     value = 1;
1293:quantum/quantum.c ****   breathing_period = value;
1294:quantum/quantum.c **** }
1295:quantum/quantum.c **** 
1296:quantum/quantum.c **** void breathing_period_default(void) {
1297:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1298:quantum/quantum.c **** }
1299:quantum/quantum.c **** 
1300:quantum/quantum.c **** void breathing_period_inc(void)
1301:quantum/quantum.c **** {
1302:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1303:quantum/quantum.c **** }
1304:quantum/quantum.c **** 
1305:quantum/quantum.c **** void breathing_period_dec(void)
1306:quantum/quantum.c **** {
1307:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1308:quantum/quantum.c **** }
1309:quantum/quantum.c **** 
1310:quantum/quantum.c **** /* To generate breathing curve in python:
1311:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1312:quantum/quantum.c ****  */
1313:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1314:quantum/quantum.c **** 
1315:quantum/quantum.c **** // Use this before the cie_lightness function.
1316:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1317:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1318:quantum/quantum.c **** }
1319:quantum/quantum.c **** 
1320:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1321:quantum/quantum.c ****  * about 244 times per second.
1322:quantum/quantum.c ****  */
1323:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1324:quantum/quantum.c **** {
1325:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1326:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1327:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1328:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1329:quantum/quantum.c **** 
1330:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1331:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1332:quantum/quantum.c ****   {
1333:quantum/quantum.c ****       breathing_interrupt_disable();
1334:quantum/quantum.c ****   }
1335:quantum/quantum.c **** 
1336:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1337:quantum/quantum.c **** }
1338:quantum/quantum.c **** 
1339:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1340:quantum/quantum.c **** 
1341:quantum/quantum.c **** __attribute__ ((weak))
1342:quantum/quantum.c **** void backlight_init_ports(void)
1343:quantum/quantum.c **** {
1344:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1345:quantum/quantum.c ****   // DDRx |= n
1346:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1347:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1348:quantum/quantum.c ****     // PORTx &= ~n
1349:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1350:quantum/quantum.c ****   #else
1351:quantum/quantum.c ****     // PORTx |= n
1352:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1353:quantum/quantum.c ****   #endif
1354:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1355:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1356:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1357:quantum/quantum.c **** 
1358:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1359:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1360:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1361:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1362:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1363:quantum/quantum.c **** 
1364:quantum/quantum.c ****   /*
1365:quantum/quantum.c ****   14.8.3:
1366:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1367:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1368:quantum/quantum.c ****   */
1369:quantum/quantum.c ****   TCCRxA = _BV(COMxx1) | _BV(WGM11); // = 0b00001010;
1370:quantum/quantum.c ****   TCCRxB = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1371:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1372:quantum/quantum.c ****   ICRx = TIMER_TOP;
1373:quantum/quantum.c **** 
1374:quantum/quantum.c ****   backlight_init();
1375:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1376:quantum/quantum.c ****     breathing_enable();
1377:quantum/quantum.c ****   #endif
1378:quantum/quantum.c **** }
1379:quantum/quantum.c **** 
1380:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1381:quantum/quantum.c **** 
1382:quantum/quantum.c **** #else // backlight
1383:quantum/quantum.c **** 
1384:quantum/quantum.c **** __attribute__ ((weak))
1385:quantum/quantum.c **** void backlight_init_ports(void) {}
 1523               		.loc 1 1385 0
 1524               		.cfi_startproc
 1525               	/* prologue: function */
 1526               	/* frame size = 0 */
 1527               	/* stack size = 0 */
 1528               	.L__stack_usage = 0
 1529 0000 0895      		ret
 1530               		.cfi_endproc
 1531               	.LFE54:
 1533               		.section	.text.backlight_set,"ax",@progbits
 1534               		.weak	backlight_set
 1536               	backlight_set:
 1537               	.LFB55:
1386:quantum/quantum.c **** 
1387:quantum/quantum.c **** __attribute__ ((weak))
1388:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 1538               		.loc 1 1388 0
 1539               		.cfi_startproc
 1540               	.LVL166:
 1541               	/* prologue: function */
 1542               	/* frame size = 0 */
 1543               	/* stack size = 0 */
 1544               	.L__stack_usage = 0
 1545 0000 0895      		ret
 1546               		.cfi_endproc
 1547               	.LFE55:
 1549               		.section	.text.send_nibble,"ax",@progbits
 1550               	.global	send_nibble
 1552               	send_nibble:
 1553               	.LFB59:
1389:quantum/quantum.c **** 
1390:quantum/quantum.c **** #endif // backlight
1391:quantum/quantum.c **** 
1392:quantum/quantum.c **** #ifdef HD44780_ENABLED
1393:quantum/quantum.c **** #include "hd44780.h"
1394:quantum/quantum.c **** #endif
1395:quantum/quantum.c **** 
1396:quantum/quantum.c **** 
1397:quantum/quantum.c **** // Functions for spitting out values
1398:quantum/quantum.c **** //
1399:quantum/quantum.c **** 
1400:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1401:quantum/quantum.c ****     uint16_t word = (number >> 16);
1402:quantum/quantum.c ****     send_word(word);
1403:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1404:quantum/quantum.c **** }
1405:quantum/quantum.c **** 
1406:quantum/quantum.c **** void send_word(uint16_t number) {
1407:quantum/quantum.c ****     uint8_t byte = number >> 8;
1408:quantum/quantum.c ****     send_byte(byte);
1409:quantum/quantum.c ****     send_byte(number & 0xFF);
1410:quantum/quantum.c **** }
1411:quantum/quantum.c **** 
1412:quantum/quantum.c **** void send_byte(uint8_t number) {
1413:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1414:quantum/quantum.c ****     send_nibble(nibble);
1415:quantum/quantum.c ****     send_nibble(number & 0xF);
1416:quantum/quantum.c **** }
1417:quantum/quantum.c **** 
1418:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1554               		.loc 1 1418 0
 1555               		.cfi_startproc
 1556               	.LVL167:
 1557               		.loc 1 1418 0
 1558 0000 CF93      		push r28
 1559               	.LCFI35:
 1560               		.cfi_def_cfa_offset 3
 1561               		.cfi_offset 28, -2
 1562               	/* prologue: function */
 1563               	/* frame size = 0 */
 1564               	/* stack size = 1 */
 1565               	.L__stack_usage = 1
1419:quantum/quantum.c ****     switch (number) {
 1566               		.loc 1 1419 0
 1567 0002 8A30      		cpi r24,lo8(10)
 1568 0004 00F4      		brsh .L103
 1569 0006 8130      		cpi r24,lo8(1)
 1570 0008 00F4      		brsh .L111
1420:quantum/quantum.c ****         case 0:
1421:quantum/quantum.c ****             register_code(KC_0);
 1571               		.loc 1 1421 0
 1572 000a 87E2      		ldi r24,lo8(39)
 1573               	.LVL168:
 1574 000c 0E94 0000 		call register_code
 1575               	.LVL169:
1422:quantum/quantum.c ****             unregister_code(KC_0);
 1576               		.loc 1 1422 0
 1577 0010 87E2      		ldi r24,lo8(39)
 1578 0012 00C0      		rjmp .L109
 1579               	.LVL170:
 1580               	.L103:
1419:quantum/quantum.c ****     switch (number) {
 1581               		.loc 1 1419 0
 1582 0014 8031      		cpi r24,lo8(16)
 1583 0016 00F4      		brsh .L112
1423:quantum/quantum.c ****             break;
1424:quantum/quantum.c ****         case 1 ... 9:
1425:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1426:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1427:quantum/quantum.c ****             break;
1428:quantum/quantum.c ****         case 0xA ... 0xF:
1429:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1584               		.loc 1 1429 0
 1585 0018 CAEF      		ldi r28,lo8(-6)
 1586 001a 00C0      		rjmp .L110
 1587               	.L111:
1425:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 1588               		.loc 1 1425 0
 1589 001c CDE1      		ldi r28,lo8(29)
 1590               	.L110:
 1591               		.loc 1 1429 0
 1592 001e C80F      		add r28,r24
 1593 0020 8C2F      		mov r24,r28
 1594               	.LVL171:
 1595 0022 0E94 0000 		call register_code
 1596               	.LVL172:
1430:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1597               		.loc 1 1430 0
 1598 0026 8C2F      		mov r24,r28
 1599               	.L109:
 1600               	/* epilogue start */
1431:quantum/quantum.c ****             break;
1432:quantum/quantum.c ****     }
1433:quantum/quantum.c **** }
 1601               		.loc 1 1433 0
 1602 0028 CF91      		pop r28
1430:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1603               		.loc 1 1430 0
 1604 002a 0C94 0000 		jmp unregister_code
 1605               	.LVL173:
 1606               	.L112:
 1607               	/* epilogue start */
 1608               		.loc 1 1433 0
 1609 002e CF91      		pop r28
 1610 0030 0895      		ret
 1611               		.cfi_endproc
 1612               	.LFE59:
 1614               		.section	.text.send_byte,"ax",@progbits
 1615               	.global	send_byte
 1617               	send_byte:
 1618               	.LFB58:
1412:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1619               		.loc 1 1412 0
 1620               		.cfi_startproc
 1621               	.LVL174:
 1622 0000 CF93      		push r28
 1623               	.LCFI36:
 1624               		.cfi_def_cfa_offset 3
 1625               		.cfi_offset 28, -2
 1626               	/* prologue: function */
 1627               	/* frame size = 0 */
 1628               	/* stack size = 1 */
 1629               	.L__stack_usage = 1
 1630 0002 C82F      		mov r28,r24
 1631               	.LVL175:
1414:quantum/quantum.c ****     send_nibble(number & 0xF);
 1632               		.loc 1 1414 0
 1633 0004 8295      		swap r24
 1634               	.LVL176:
 1635 0006 8F70      		andi r24,lo8(15)
 1636 0008 0E94 0000 		call send_nibble
 1637               	.LVL177:
1415:quantum/quantum.c **** }
 1638               		.loc 1 1415 0
 1639 000c 8C2F      		mov r24,r28
 1640 000e 8F70      		andi r24,lo8(15)
 1641               	/* epilogue start */
1416:quantum/quantum.c **** 
 1642               		.loc 1 1416 0
 1643 0010 CF91      		pop r28
 1644               	.LVL178:
1415:quantum/quantum.c **** }
 1645               		.loc 1 1415 0
 1646 0012 0C94 0000 		jmp send_nibble
 1647               	.LVL179:
 1648               		.cfi_endproc
 1649               	.LFE58:
 1651               		.section	.text.send_word,"ax",@progbits
 1652               	.global	send_word
 1654               	send_word:
 1655               	.LFB57:
1406:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1656               		.loc 1 1406 0
 1657               		.cfi_startproc
 1658               	.LVL180:
 1659 0000 CF93      		push r28
 1660               	.LCFI37:
 1661               		.cfi_def_cfa_offset 3
 1662               		.cfi_offset 28, -2
 1663               	/* prologue: function */
 1664               	/* frame size = 0 */
 1665               	/* stack size = 1 */
 1666               	.L__stack_usage = 1
 1667 0002 C82F      		mov r28,r24
 1668               	.LVL181:
1408:quantum/quantum.c ****     send_byte(number & 0xFF);
 1669               		.loc 1 1408 0
 1670 0004 892F      		mov r24,r25
 1671               	.LVL182:
 1672 0006 0E94 0000 		call send_byte
 1673               	.LVL183:
1409:quantum/quantum.c **** }
 1674               		.loc 1 1409 0
 1675 000a 8C2F      		mov r24,r28
 1676               	/* epilogue start */
1410:quantum/quantum.c **** 
 1677               		.loc 1 1410 0
 1678 000c CF91      		pop r28
1409:quantum/quantum.c **** }
 1679               		.loc 1 1409 0
 1680 000e 0C94 0000 		jmp send_byte
 1681               	.LVL184:
 1682               		.cfi_endproc
 1683               	.LFE57:
 1685               		.section	.text.send_dword,"ax",@progbits
 1686               	.global	send_dword
 1688               	send_dword:
 1689               	.LFB56:
1400:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1690               		.loc 1 1400 0
 1691               		.cfi_startproc
 1692               	.LVL185:
 1693 0000 CF92      		push r12
 1694               	.LCFI38:
 1695               		.cfi_def_cfa_offset 3
 1696               		.cfi_offset 12, -2
 1697 0002 DF92      		push r13
 1698               	.LCFI39:
 1699               		.cfi_def_cfa_offset 4
 1700               		.cfi_offset 13, -3
 1701 0004 EF92      		push r14
 1702               	.LCFI40:
 1703               		.cfi_def_cfa_offset 5
 1704               		.cfi_offset 14, -4
 1705 0006 FF92      		push r15
 1706               	.LCFI41:
 1707               		.cfi_def_cfa_offset 6
 1708               		.cfi_offset 15, -5
 1709               	/* prologue: function */
 1710               	/* frame size = 0 */
 1711               	/* stack size = 4 */
 1712               	.L__stack_usage = 4
 1713 0008 6B01      		movw r12,r22
 1714 000a 7C01      		movw r14,r24
 1715               	.LVL186:
1402:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1716               		.loc 1 1402 0
 1717 000c C701      		movw r24,r14
 1718 000e 0E94 0000 		call send_word
 1719               	.LVL187:
1403:quantum/quantum.c **** }
 1720               		.loc 1 1403 0
 1721 0012 C601      		movw r24,r12
 1722               	/* epilogue start */
1404:quantum/quantum.c **** 
 1723               		.loc 1 1404 0
 1724 0014 FF90      		pop r15
 1725 0016 EF90      		pop r14
 1726 0018 DF90      		pop r13
 1727 001a CF90      		pop r12
 1728               	.LVL188:
1403:quantum/quantum.c **** }
 1729               		.loc 1 1403 0
 1730 001c 0C94 0000 		jmp send_word
 1731               	.LVL189:
 1732               		.cfi_endproc
 1733               	.LFE56:
 1735               		.section	.text.hex_to_keycode,"ax",@progbits
 1736               		.weak	hex_to_keycode
 1738               	hex_to_keycode:
 1739               	.LFB60:
1434:quantum/quantum.c **** 
1435:quantum/quantum.c **** 
1436:quantum/quantum.c **** __attribute__((weak))
1437:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1438:quantum/quantum.c **** {
 1740               		.loc 1 1438 0
 1741               		.cfi_startproc
 1742               	.LVL190:
 1743               	/* prologue: function */
 1744               	/* frame size = 0 */
 1745               	/* stack size = 0 */
 1746               	.L__stack_usage = 0
1439:quantum/quantum.c ****   hex = hex & 0xF;
 1747               		.loc 1 1439 0
 1748 0000 282F      		mov r18,r24
 1749 0002 2F70      		andi r18,lo8(15)
 1750               	.LVL191:
1440:quantum/quantum.c ****   if (hex == 0x0) {
 1751               		.loc 1 1440 0
 1752 0004 01F0      		breq .L119
 1753 0006 822F      		mov r24,r18
 1754 0008 90E0      		ldi r25,0
1441:quantum/quantum.c ****     return KC_0;
1442:quantum/quantum.c ****   } else if (hex < 0xA) {
 1755               		.loc 1 1442 0
 1756 000a 2A30      		cpi r18,lo8(10)
 1757 000c 00F4      		brsh .L118
1443:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 1758               		.loc 1 1443 0
 1759 000e 4D96      		adiw r24,29
 1760 0010 0895      		ret
 1761               	.L118:
1444:quantum/quantum.c ****   } else {
1445:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 1762               		.loc 1 1445 0
 1763 0012 0697      		sbiw r24,6
 1764 0014 0895      		ret
 1765               	.L119:
1441:quantum/quantum.c ****   } else if (hex < 0xA) {
 1766               		.loc 1 1441 0
 1767 0016 87E2      		ldi r24,lo8(39)
 1768 0018 90E0      		ldi r25,0
1446:quantum/quantum.c ****   }
1447:quantum/quantum.c **** }
 1769               		.loc 1 1447 0
 1770 001a 0895      		ret
 1771               		.cfi_endproc
 1772               	.LFE60:
 1774               		.section	.text.api_send_unicode,"ax",@progbits
 1775               	.global	api_send_unicode
 1777               	api_send_unicode:
 1778               	.LFB61:
1448:quantum/quantum.c **** 
1449:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1779               		.loc 1 1449 0
 1780               		.cfi_startproc
 1781               	.LVL192:
 1782               	/* prologue: function */
 1783               	/* frame size = 0 */
 1784               	/* stack size = 0 */
 1785               	.L__stack_usage = 0
 1786 0000 0895      		ret
 1787               		.cfi_endproc
 1788               	.LFE61:
 1790               		.section	.text.led_set_user,"ax",@progbits
 1791               		.weak	led_set_user
 1793               	led_set_user:
 1794               	.LFB62:
1450:quantum/quantum.c **** #ifdef API_ENABLE
1451:quantum/quantum.c ****     uint8_t chunk[4];
1452:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1453:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1454:quantum/quantum.c **** #endif
1455:quantum/quantum.c **** }
1456:quantum/quantum.c **** 
1457:quantum/quantum.c **** __attribute__ ((weak))
1458:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 1795               		.loc 1 1458 0
 1796               		.cfi_startproc
 1797               	.LVL193:
 1798               	/* prologue: function */
 1799               	/* frame size = 0 */
 1800               	/* stack size = 0 */
 1801               	.L__stack_usage = 0
 1802 0000 0895      		ret
 1803               		.cfi_endproc
 1804               	.LFE62:
 1806               		.section	.text.led_set_kb,"ax",@progbits
 1807               		.weak	led_set_kb
 1809               	led_set_kb:
 1810               	.LFB63:
1459:quantum/quantum.c **** 
1460:quantum/quantum.c **** }
1461:quantum/quantum.c **** 
1462:quantum/quantum.c **** __attribute__ ((weak))
1463:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 1811               		.loc 1 1463 0
 1812               		.cfi_startproc
 1813               	.LVL194:
 1814               	/* prologue: function */
 1815               	/* frame size = 0 */
 1816               	/* stack size = 0 */
 1817               	.L__stack_usage = 0
1464:quantum/quantum.c ****     led_set_user(usb_led);
 1818               		.loc 1 1464 0
 1819 0000 0C94 0000 		jmp led_set_user
 1820               	.LVL195:
 1821               		.cfi_endproc
 1822               	.LFE63:
 1824               		.section	.text.led_init_ports,"ax",@progbits
 1825               		.weak	led_init_ports
 1827               	led_init_ports:
 1828               	.LFB64:
1465:quantum/quantum.c **** }
1466:quantum/quantum.c **** 
1467:quantum/quantum.c **** __attribute__ ((weak))
1468:quantum/quantum.c **** void led_init_ports(void)
1469:quantum/quantum.c **** {
 1829               		.loc 1 1469 0
 1830               		.cfi_startproc
 1831               	/* prologue: function */
 1832               	/* frame size = 0 */
 1833               	/* stack size = 0 */
 1834               	.L__stack_usage = 0
 1835 0000 0895      		ret
 1836               		.cfi_endproc
 1837               	.LFE64:
 1839               		.section	.text.led_set,"ax",@progbits
 1840               		.weak	led_set
 1842               	led_set:
 1843               	.LFB65:
1470:quantum/quantum.c **** 
1471:quantum/quantum.c **** }
1472:quantum/quantum.c **** 
1473:quantum/quantum.c **** __attribute__ ((weak))
1474:quantum/quantum.c **** void led_set(uint8_t usb_led)
1475:quantum/quantum.c **** {
 1844               		.loc 1 1475 0
 1845               		.cfi_startproc
 1846               	.LVL196:
 1847               	/* prologue: function */
 1848               	/* frame size = 0 */
 1849               	/* stack size = 0 */
 1850               	.L__stack_usage = 0
1476:quantum/quantum.c **** 
1477:quantum/quantum.c ****   // Example LED Code
1478:quantum/quantum.c ****   //
1479:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1480:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1481:quantum/quantum.c ****     // {
1482:quantum/quantum.c ****     //     // Output high.
1483:quantum/quantum.c ****     //     DDRE |= (1<<6);
1484:quantum/quantum.c ****     //     PORTE |= (1<<6);
1485:quantum/quantum.c ****     // }
1486:quantum/quantum.c ****     // else
1487:quantum/quantum.c ****     // {
1488:quantum/quantum.c ****     //     // Output low.
1489:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1490:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1491:quantum/quantum.c ****     // }
1492:quantum/quantum.c **** 
1493:quantum/quantum.c **** #if defined(BACKLIGHT_CAPS_LOCK) && defined(BACKLIGHT_ENABLE)
1494:quantum/quantum.c ****   // Use backlight as Caps Lock indicator
1495:quantum/quantum.c ****   uint8_t bl_toggle_lvl = 0;
1496:quantum/quantum.c **** 
1497:quantum/quantum.c ****   if (IS_LED_ON(usb_led, USB_LED_CAPS_LOCK) && !backlight_config.enable) {
1498:quantum/quantum.c ****     // Turning Caps Lock ON and backlight is disabled in config
1499:quantum/quantum.c ****     // Toggling backlight to the brightest level
1500:quantum/quantum.c ****     bl_toggle_lvl = BACKLIGHT_LEVELS;
1501:quantum/quantum.c ****   } else if (IS_LED_OFF(usb_led, USB_LED_CAPS_LOCK) && backlight_config.enable) {
1502:quantum/quantum.c ****     // Turning Caps Lock OFF and backlight is enabled in config
1503:quantum/quantum.c ****     // Toggling backlight and restoring config level
1504:quantum/quantum.c ****     bl_toggle_lvl = backlight_config.level;
1505:quantum/quantum.c ****   }
1506:quantum/quantum.c **** 
1507:quantum/quantum.c ****   // Set level without modify backlight_config to keep ability to restore state
1508:quantum/quantum.c ****   backlight_set(bl_toggle_lvl);
1509:quantum/quantum.c **** #endif
1510:quantum/quantum.c **** 
1511:quantum/quantum.c ****   led_set_kb(usb_led);
 1851               		.loc 1 1511 0
 1852 0000 0C94 0000 		jmp led_set_kb
 1853               	.LVL197:
 1854               		.cfi_endproc
 1855               	.LFE65:
 1857               		.section	.text.startup_user,"ax",@progbits
 1858               		.weak	startup_user
 1860               	startup_user:
 1861               	.LFB66:
1512:quantum/quantum.c **** }
1513:quantum/quantum.c **** 
1514:quantum/quantum.c **** 
1515:quantum/quantum.c **** //------------------------------------------------------------------------------
1516:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1517:quantum/quantum.c **** // different events such as startup and bootloader jump
1518:quantum/quantum.c **** 
1519:quantum/quantum.c **** __attribute__ ((weak))
1520:quantum/quantum.c **** void startup_user() {}
 1862               		.loc 1 1520 0
 1863               		.cfi_startproc
 1864               	/* prologue: function */
 1865               	/* frame size = 0 */
 1866               	/* stack size = 0 */
 1867               	.L__stack_usage = 0
 1868 0000 0895      		ret
 1869               		.cfi_endproc
 1870               	.LFE66:
 1872               		.section	.text.shutdown_user,"ax",@progbits
 1873               		.weak	shutdown_user
 1875               	shutdown_user:
 1876               	.LFB67:
1521:quantum/quantum.c **** 
1522:quantum/quantum.c **** __attribute__ ((weak))
1523:quantum/quantum.c **** void shutdown_user() {}
 1877               		.loc 1 1523 0
 1878               		.cfi_startproc
 1879               	/* prologue: function */
 1880               	/* frame size = 0 */
 1881               	/* stack size = 0 */
 1882               	.L__stack_usage = 0
 1883 0000 0895      		ret
 1884               		.cfi_endproc
 1885               	.LFE67:
 1887               		.section	.text.reset_keyboard,"ax",@progbits
 1888               	.global	reset_keyboard
 1890               	reset_keyboard:
 1891               	.LFB40:
 170:quantum/quantum.c ****   clear_keyboard();
 1892               		.loc 1 170 0
 1893               		.cfi_startproc
 1894               	/* prologue: function */
 1895               	/* frame size = 0 */
 1896               	/* stack size = 0 */
 1897               	.L__stack_usage = 0
 171:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1898               		.loc 1 171 0
 1899 0000 0E94 0000 		call clear_keyboard
 1900               	.LVL198:
 186:quantum/quantum.c ****   wait_ms(250);
 1901               		.loc 1 186 0
 1902 0004 0E94 0000 		call shutdown_user
 1903               	.LVL199:
 1904               	.LBB52:
 1905               	.LBB53:
 1906               		.loc 3 163 0
 1907 0008 2FEF      		ldi r18,lo8(799999)
 1908 000a 84E3      		ldi r24,hi8(799999)
 1909 000c 9CE0      		ldi r25,hlo8(799999)
 1910 000e 2150      	1:	subi r18,1
 1911 0010 8040      		sbci r24,0
 1912 0012 9040      		sbci r25,0
 1913 0014 01F4      		brne 1b
 1914 0016 00C0      		rjmp .
 1915 0018 0000      		nop
 1916               	.LBE53:
 1917               	.LBE52:
 194:quantum/quantum.c **** #endif
 1918               		.loc 1 194 0
 1919 001a 87E7      		ldi r24,lo8(119)
 1920 001c 97E7      		ldi r25,lo8(119)
 1921 001e 9093 0108 		sts 2048+1,r25
 1922 0022 8093 0008 		sts 2048,r24
 196:quantum/quantum.c **** }
 1923               		.loc 1 196 0
 1924 0026 0C94 0000 		jmp bootloader_jump
 1925               	.LVL200:
 1926               		.cfi_endproc
 1927               	.LFE40:
 1929               		.section	.text.process_record_quantum,"ax",@progbits
 1930               	.global	process_record_quantum
 1932               	process_record_quantum:
 1933               	.LFB41:
 228:quantum/quantum.c **** 
 1934               		.loc 1 228 0
 1935               		.cfi_startproc
 1936               	.LVL201:
 1937 0000 FF92      		push r15
 1938               	.LCFI42:
 1939               		.cfi_def_cfa_offset 3
 1940               		.cfi_offset 15, -2
 1941 0002 0F93      		push r16
 1942               	.LCFI43:
 1943               		.cfi_def_cfa_offset 4
 1944               		.cfi_offset 16, -3
 1945 0004 1F93      		push r17
 1946               	.LCFI44:
 1947               		.cfi_def_cfa_offset 5
 1948               		.cfi_offset 17, -4
 1949 0006 CF93      		push r28
 1950               	.LCFI45:
 1951               		.cfi_def_cfa_offset 6
 1952               		.cfi_offset 28, -5
 1953 0008 DF93      		push r29
 1954               	.LCFI46:
 1955               		.cfi_def_cfa_offset 7
 1956               		.cfi_offset 29, -6
 1957               	/* prologue: function */
 1958               	/* frame size = 0 */
 1959               	/* stack size = 5 */
 1960               	.L__stack_usage = 5
 1961 000a 8C01      		movw r16,r24
 231:quantum/quantum.c ****   uint16_t keycode;
 1962               		.loc 1 231 0
 1963 000c FC01      		movw r30,r24
 1964 000e C081      		ld r28,Z
 1965 0010 D181      		ldd r29,Z+1
 1966               	.LVL202:
 236:quantum/quantum.c ****       uint8_t layer;
 1967               		.loc 1 236 0
 1968 0012 8091 0000 		lds r24,disable_action_cache
 1969               	.LVL203:
 1970 0016 8111      		cpse r24,__zero_reg__
 1971 0018 00C0      		rjmp .L129
 1972               	.LBB54:
 239:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 1973               		.loc 1 239 0
 1974 001a 8281      		ldd r24,Z+2
 1975 001c 8823      		tst r24
 1976 001e 01F0      		breq .L130
 1977               	.LVL204:
 240:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 1978               		.loc 1 240 0
 1979 0020 CE01      		movw r24,r28
 1980 0022 0E94 0000 		call layer_switch_get_layer
 1981               	.LVL205:
 1982 0026 F82E      		mov r15,r24
 1983               	.LVL206:
 241:quantum/quantum.c ****       } else {
 1984               		.loc 1 241 0
 1985 0028 682F      		mov r22,r24
 1986 002a CE01      		movw r24,r28
 1987 002c 0E94 0000 		call update_source_layers_cache
 1988               	.LVL207:
 1989 0030 00C0      		rjmp .L131
 1990               	.LVL208:
 1991               	.L130:
 243:quantum/quantum.c ****       }
 1992               		.loc 1 243 0
 1993 0032 CE01      		movw r24,r28
 1994 0034 0E94 0000 		call read_source_layers_cache
 1995               	.LVL209:
 1996 0038 F82E      		mov r15,r24
 1997               	.LVL210:
 1998               	.L131:
 245:quantum/quantum.c ****     } else
 1999               		.loc 1 245 0
 2000 003a BE01      		movw r22,r28
 2001 003c 8F2D      		mov r24,r15
 2002 003e 00C0      		rjmp .L208
 2003               	.LVL211:
 2004               	.L129:
 2005               	.LBE54:
 248:quantum/quantum.c **** 
 2006               		.loc 1 248 0
 2007 0040 CE01      		movw r24,r28
 2008 0042 0E94 0000 		call layer_switch_get_layer
 2009               	.LVL212:
 2010 0046 BE01      		movw r22,r28
 2011               	.L208:
 2012 0048 0E94 0000 		call keymap_key_to_keycode
 2013               	.LVL213:
 2014 004c EC01      		movw r28,r24
 2015               	.LVL214:
 277:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 2016               		.loc 1 277 0
 2017 004e B801      		movw r22,r16
 2018 0050 0E94 0000 		call process_record_kb
 2019               	.LVL215:
 266:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 2020               		.loc 1 266 0
 2021 0054 8823      		tst r24
 2022 0056 01F4      		brne .+2
 2023 0058 00C0      		rjmp .L133
 320:quantum/quantum.c ****     case RESET:
 2024               		.loc 1 320 0
 2025 005a C73D      		cpi r28,-41
 2026 005c FCE5      		ldi r31,92
 2027 005e DF07      		cpc r29,r31
 2028 0060 01F4      		brne .+2
 2029 0062 00C0      		rjmp .L135
 2030 0064 00F4      		brsh .L136
 2031 0066 C531      		cpi r28,21
 2032 0068 ECE5      		ldi r30,92
 2033 006a DE07      		cpc r29,r30
 2034 006c 00F4      		brsh .L137
 2035 006e C230      		cpi r28,2
 2036 0070 FCE5      		ldi r31,92
 2037 0072 DF07      		cpc r29,r31
 2038 0074 00F0      		brlo .+2
 2039 0076 00C0      		rjmp .L138
 2040 0078 C115      		cp r28,__zero_reg__
 2041 007a 8CE5      		ldi r24,92
 2042 007c D807      		cpc r29,r24
 2043 007e 01F0      		breq .L139
 2044 0080 C130      		cpi r28,1
 2045 0082 DC45      		sbci r29,92
 2046 0084 01F0      		breq .L140
 2047 0086 00C0      		rjmp .L134
 2048               	.L137:
 2049 0088 C631      		cpi r28,22
 2050 008a DC45      		sbci r29,92
 2051 008c 01F4      		brne .+2
 2052 008e 00C0      		rjmp .L141
 2053 0090 00C0      		rjmp .L134
 2054               	.L136:
 2055 0092 CC3D      		cpi r28,-36
 2056 0094 8CE5      		ldi r24,92
 2057 0096 D807      		cpc r29,r24
 2058 0098 01F0      		breq .L142
 2059 009a 00F4      		brsh .L143
 2060 009c C83D      		cpi r28,-40
 2061 009e FCE5      		ldi r31,92
 2062 00a0 DF07      		cpc r29,r31
 2063 00a2 01F4      		brne .+2
 2064 00a4 00C0      		rjmp .L144
 2065 00a6 C93D      		cpi r28,-39
 2066 00a8 DC45      		sbci r29,92
 2067 00aa 01F4      		brne .+2
 2068 00ac 00C0      		rjmp .L145
 2069 00ae 00C0      		rjmp .L134
 2070               	.L143:
 2071 00b0 CD3D      		cpi r28,-35
 2072 00b2 ECE5      		ldi r30,92
 2073 00b4 DE07      		cpc r29,r30
 2074 00b6 01F0      		breq .L146
 2075 00b8 CE3D      		cpi r28,-34
 2076 00ba DC45      		sbci r29,92
 2077 00bc 01F0      		breq .L147
 2078 00be 00C0      		rjmp .L134
 2079               	.L139:
 322:quantum/quantum.c ****         reset_keyboard();
 2080               		.loc 1 322 0
 2081 00c0 F801      		movw r30,r16
 2082 00c2 8281      		ldd r24,Z+2
 2083 00c4 8823      		tst r24
 2084 00c6 01F4      		brne .+2
 2085 00c8 00C0      		rjmp .L133
 323:quantum/quantum.c ****       }
 2086               		.loc 1 323 0
 2087 00ca 0E94 0000 		call reset_keyboard
 2088               	.LVL216:
 2089 00ce 00C0      		rjmp .L133
 2090               	.L140:
 327:quantum/quantum.c ****           debug_enable = true;
 2091               		.loc 1 327 0
 2092 00d0 F801      		movw r30,r16
 2093 00d2 8281      		ldd r24,Z+2
 2094 00d4 8823      		tst r24
 2095 00d6 01F4      		brne .+2
 2096 00d8 00C0      		rjmp .L133
 328:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 2097               		.loc 1 328 0
 2098 00da 8091 0000 		lds r24,debug_config
 2099 00de 8160      		ori r24,lo8(1<<0)
 2100 00e0 8093 0000 		sts debug_config,r24
 2101 00e4 00C0      		rjmp .L133
 2102               	.L147:
 333:quantum/quantum.c ****           eeconfig_init();
 2103               		.loc 1 333 0
 2104 00e6 F801      		movw r30,r16
 2105 00e8 8281      		ldd r24,Z+2
 2106 00ea 8823      		tst r24
 2107 00ec 01F4      		brne .+2
 2108 00ee 00C0      		rjmp .L133
 334:quantum/quantum.c ****       }
 2109               		.loc 1 334 0
 2110 00f0 0E94 0000 		call eeconfig_init
 2111               	.LVL217:
 2112 00f4 00C0      		rjmp .L133
 2113               	.L142:
 558:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 2114               		.loc 1 558 0
 2115 00f6 F801      		movw r30,r16
 2116 00f8 8281      		ldd r24,Z+2
 2117 00fa 8823      		tst r24
 2118 00fc 01F4      		brne .+2
 2119 00fe 00C0      		rjmp .L133
 559:quantum/quantum.c ****       }
 2120               		.loc 1 559 0
 2121 0100 80E0      		ldi r24,0
 2122 0102 00C0      		rjmp .L210
 2123               	.L146:
 563:quantum/quantum.c ****         set_output(OUTPUT_USB);
 2124               		.loc 1 563 0
 2125 0104 F801      		movw r30,r16
 2126 0106 8281      		ldd r24,Z+2
 2127 0108 8823      		tst r24
 2128 010a 01F4      		brne .+2
 2129 010c 00C0      		rjmp .L133
 564:quantum/quantum.c ****       }
 2130               		.loc 1 564 0
 2131 010e 82E0      		ldi r24,lo8(2)
 2132               	.L210:
 2133 0110 0E94 0000 		call set_output
 2134               	.LVL218:
 2135 0114 00C0      		rjmp .L133
 2136               	.L138:
 576:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 2137               		.loc 1 576 0
 2138 0116 F801      		movw r30,r16
 2139 0118 8281      		ldd r24,Z+2
 2140 011a 8823      		tst r24
 2141 011c 01F4      		brne .+2
 2142 011e 00C0      		rjmp .L148
 578:quantum/quantum.c ****             eeconfig_init();
 2143               		.loc 1 578 0
 2144 0120 0E94 0000 		call eeconfig_is_enabled
 2145               	.LVL219:
 2146 0124 8111      		cpse r24,__zero_reg__
 2147 0126 00C0      		rjmp .L149
 579:quantum/quantum.c ****         }
 2148               		.loc 1 579 0
 2149 0128 0E94 0000 		call eeconfig_init
 2150               	.LVL220:
 2151               	.L149:
 582:quantum/quantum.c ****         switch (keycode)
 2152               		.loc 1 582 0
 2153 012c 0E94 0000 		call eeconfig_read_keymap
 2154               	.LVL221:
 2155 0130 90E0      		ldi r25,0
 2156 0132 9093 0000 		sts keymap_config+1,r25
 2157 0136 8093 0000 		sts keymap_config,r24
 583:quantum/quantum.c ****         {
 2158               		.loc 1 583 0
 2159 013a FE01      		movw r30,r28
 2160 013c E350      		subi r30,3
 2161 013e FC45      		sbci r31,92
 2162 0140 E231      		cpi r30,18
 2163 0142 F105      		cpc r31,__zero_reg__
 2164 0144 00F4      		brsh .L150
 2165 0146 E050      		subi r30,lo8(-(gs(.L152)))
 2166 0148 F040      		sbci r31,hi8(-(gs(.L152)))
 659:quantum/quantum.c ****             break;
 2167               		.loc 1 659 0
 2168 014a 8091 0000 		lds r24,keymap_config
 583:quantum/quantum.c ****         {
 2169               		.loc 1 583 0
 2170 014e 0C94 0000 		jmp __tablejump2__
 2171               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 2172               		.p2align	1
 2173               	.L152:
 2174 0000 0000      		.word gs(.L151)
 2175 0002 0000      		.word gs(.L153)
 2176 0004 0000      		.word gs(.L214)
 2177 0006 0000      		.word gs(.L155)
 2178 0008 0000      		.word gs(.L156)
 2179 000a 0000      		.word gs(.L157)
 2180 000c 0000      		.word gs(.L158)
 2181 000e 0000      		.word gs(.L159)
 2182 0010 0000      		.word gs(.L160)
 2183 0012 0000      		.word gs(.L161)
 2184 0014 0000      		.word gs(.L162)
 2185 0016 0000      		.word gs(.L213)
 2186 0018 0000      		.word gs(.L164)
 2187 001a 0000      		.word gs(.L165)
 2188 001c 0000      		.word gs(.L166)
 2189 001e 0000      		.word gs(.L167)
 2190 0020 0000      		.word gs(.L168)
 2191 0022 0000      		.word gs(.L169)
 2192               		.section	.text.process_record_quantum
 2193               	.L150:
 586:quantum/quantum.c ****             break;
 2194               		.loc 1 586 0
 2195 0152 8091 0000 		lds r24,keymap_config
 2196 0156 8160      		ori r24,lo8(1<<0)
 2197 0158 00C0      		rjmp .L209
 2198               	.L151:
 589:quantum/quantum.c ****             break;
 2199               		.loc 1 589 0
 2200 015a 8260      		ori r24,lo8(1<<1)
 2201 015c 00C0      		rjmp .L209
 2202               	.L153:
 592:quantum/quantum.c ****             break;
 2203               		.loc 1 592 0
 2204 015e 8460      		ori r24,lo8(1<<2)
 2205 0160 00C0      		rjmp .L209
 2206               	.L155:
 598:quantum/quantum.c ****             break;
 2207               		.loc 1 598 0
 2208 0162 8061      		ori r24,lo8(1<<4)
 2209 0164 00C0      		rjmp .L209
 2210               	.L156:
 601:quantum/quantum.c ****             break;
 2211               		.loc 1 601 0
 2212 0166 8062      		ori r24,lo8(1<<5)
 2213 0168 00C0      		rjmp .L209
 2214               	.L157:
 604:quantum/quantum.c ****             break;
 2215               		.loc 1 604 0
 2216 016a 8064      		ori r24,lo8(1<<6)
 2217 016c 00C0      		rjmp .L209
 2218               	.L158:
 607:quantum/quantum.c ****             break;
 2219               		.loc 1 607 0
 2220 016e 8068      		ori r24,lo8(1<<7)
 2221 0170 00C0      		rjmp .L209
 2222               	.L159:
 611:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2223               		.loc 1 611 0
 2224 0172 8460      		ori r24,lo8(4)
 2225               	.L214:
 2226 0174 8860      		ori r24,lo8(1<<3)
 2227 0176 00C0      		rjmp .L209
 2228               	.L160:
 617:quantum/quantum.c ****             break;
 2229               		.loc 1 617 0
 2230 0178 8E7F      		andi r24,lo8(~(1<<0))
 2231 017a 00C0      		rjmp .L209
 2232               	.L161:
 620:quantum/quantum.c ****             break;
 2233               		.loc 1 620 0
 2234 017c 8D7F      		andi r24,lo8(~(1<<1))
 2235 017e 00C0      		rjmp .L209
 2236               	.L162:
 623:quantum/quantum.c ****             break;
 2237               		.loc 1 623 0
 2238 0180 8B7F      		andi r24,lo8(~(1<<2))
 2239 0182 00C0      		rjmp .L209
 2240               	.L164:
 629:quantum/quantum.c ****             break;
 2241               		.loc 1 629 0
 2242 0184 8F7E      		andi r24,lo8(~(1<<4))
 2243 0186 00C0      		rjmp .L209
 2244               	.L165:
 632:quantum/quantum.c ****             break;
 2245               		.loc 1 632 0
 2246 0188 8F7D      		andi r24,lo8(~(1<<5))
 2247 018a 00C0      		rjmp .L209
 2248               	.L166:
 635:quantum/quantum.c ****             break;
 2249               		.loc 1 635 0
 2250 018c 8F7B      		andi r24,lo8(~(1<<6))
 2251 018e 00C0      		rjmp .L209
 2252               	.L167:
 638:quantum/quantum.c ****             break;
 2253               		.loc 1 638 0
 2254 0190 8F77      		andi r24,lo8(~(1<<7))
 2255 0192 00C0      		rjmp .L209
 2256               	.L168:
 642:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 2257               		.loc 1 642 0
 2258 0194 8B7F      		andi r24,lo8(-5)
 2259               	.L213:
 2260 0196 877F      		andi r24,lo8(~(1<<3))
 2261 0198 00C0      		rjmp .L209
 2262               	.L169:
 659:quantum/quantum.c ****             break;
 2263               		.loc 1 659 0
 2264 019a 87FB      		bst r24,7
 2265 019c 2227      		clr r18
 2266 019e 20F9      		bld r18,0
 2267 01a0 91E0      		ldi r25,lo8(1)
 2268 01a2 9227      		eor r25,r18
 2269 01a4 90FB      		bst r25,0
 2270 01a6 87F9      		bld r24,7
 2271               	.L209:
 2272 01a8 8093 0000 		sts keymap_config,r24
 664:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 2273               		.loc 1 664 0
 2274 01ac 8091 0000 		lds r24,keymap_config
 2275 01b0 0E94 0000 		call eeconfig_update_keymap
 2276               	.LVL222:
 665:quantum/quantum.c **** 
 2277               		.loc 1 665 0
 2278 01b4 0E94 0000 		call clear_keyboard
 2279               	.LVL223:
 667:quantum/quantum.c ****       }
 2280               		.loc 1 667 0
 2281 01b8 00C0      		rjmp .L133
 2282               	.L135:
 671:quantum/quantum.c ****         shift_interrupted[0] = false;
 2283               		.loc 1 671 0
 2284 01ba F801      		movw r30,r16
 2285 01bc 8281      		ldd r24,Z+2
 2286 01be 8823      		tst r24
 2287 01c0 01F0      		breq .L171
 672:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 2288               		.loc 1 672 0
 2289 01c2 1092 0000 		sts shift_interrupted,__zero_reg__
 673:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 2290               		.loc 1 673 0
 2291 01c6 0E94 0000 		call timer_read
 2292               	.LVL224:
 2293 01ca 9093 0000 		sts scs_timer+1,r25
 2294 01ce 8093 0000 		sts scs_timer,r24
 674:quantum/quantum.c ****       }
 2295               		.loc 1 674 0
 2296 01d2 82E0      		ldi r24,lo8(2)
 2297 01d4 00C0      		rjmp .L211
 2298               	.L171:
 683:quantum/quantum.c ****           #ifdef DISABLE_SPACE_CADET_MODIFIER
 2299               		.loc 1 683 0
 2300 01d6 8091 0000 		lds r24,shift_interrupted
 2301 01da 8111      		cpse r24,__zero_reg__
 2302 01dc 00C0      		rjmp .L173
 683:quantum/quantum.c ****           #ifdef DISABLE_SPACE_CADET_MODIFIER
 2303               		.loc 1 683 0 is_stmt 0 discriminator 1
 2304 01de 8091 0000 		lds r24,scs_timer
 2305 01e2 9091 0000 		lds r25,scs_timer+1
 2306 01e6 0E94 0000 		call timer_elapsed
 2307               	.LVL225:
 2308 01ea 8436      		cpi r24,100
 2309 01ec 9105      		cpc r25,__zero_reg__
 2310 01ee 00F4      		brsh .L173
 692:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 2311               		.loc 1 692 0 is_stmt 1
 2312 01f0 86E2      		ldi r24,lo8(38)
 2313 01f2 0E94 0000 		call register_code
 2314               	.LVL226:
 693:quantum/quantum.c ****           #ifndef DISABLE_SPACE_CADET_MODIFIER
 2315               		.loc 1 693 0
 2316 01f6 86E2      		ldi r24,lo8(38)
 2317 01f8 0E94 0000 		call unregister_code
 2318               	.LVL227:
 2319               	.L173:
 700:quantum/quantum.c ****       }
 2320               		.loc 1 700 0
 2321 01fc 82E0      		ldi r24,lo8(2)
 2322 01fe 00C0      		rjmp .L212
 2323               	.L144:
 706:quantum/quantum.c ****         shift_interrupted[1] = false;
 2324               		.loc 1 706 0
 2325 0200 F801      		movw r30,r16
 2326 0202 8281      		ldd r24,Z+2
 2327 0204 8823      		tst r24
 2328 0206 01F0      		breq .L175
 2329               	.L179:
 707:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 2330               		.loc 1 707 0
 2331 0208 1092 0000 		sts shift_interrupted+1,__zero_reg__
 708:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 2332               		.loc 1 708 0
 2333 020c 0E94 0000 		call timer_read
 2334               	.LVL228:
 2335 0210 9093 0000 		sts scs_timer+2+1,r25
 2336 0214 8093 0000 		sts scs_timer+2,r24
 709:quantum/quantum.c ****       }
 2337               		.loc 1 709 0
 2338 0218 80E2      		ldi r24,lo8(32)
 2339               	.L211:
 2340 021a 0E94 0000 		call register_mods
 2341               	.LVL229:
 2342 021e 00C0      		rjmp .L133
 2343               	.L175:
 718:quantum/quantum.c ****           #ifdef DISABLE_SPACE_CADET_MODIFIER
 2344               		.loc 1 718 0
 2345 0220 8091 0000 		lds r24,shift_interrupted+1
 2346 0224 8111      		cpse r24,__zero_reg__
 2347 0226 00C0      		rjmp .L177
 718:quantum/quantum.c ****           #ifdef DISABLE_SPACE_CADET_MODIFIER
 2348               		.loc 1 718 0 is_stmt 0 discriminator 1
 2349 0228 8091 0000 		lds r24,scs_timer+2
 2350 022c 9091 0000 		lds r25,scs_timer+2+1
 2351 0230 0E94 0000 		call timer_elapsed
 2352               	.LVL230:
 2353 0234 8436      		cpi r24,100
 2354 0236 9105      		cpc r25,__zero_reg__
 2355 0238 00F4      		brsh .L177
 727:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 2356               		.loc 1 727 0 is_stmt 1
 2357 023a 87E2      		ldi r24,lo8(39)
 2358 023c 0E94 0000 		call register_code
 2359               	.LVL231:
 728:quantum/quantum.c ****           #ifndef DISABLE_SPACE_CADET_MODIFIER
 2360               		.loc 1 728 0
 2361 0240 87E2      		ldi r24,lo8(39)
 2362 0242 0E94 0000 		call unregister_code
 2363               	.LVL232:
 2364               	.L177:
 735:quantum/quantum.c ****       }
 2365               		.loc 1 735 0
 2366 0246 80E2      		ldi r24,lo8(32)
 2367               	.L212:
 2368 0248 0E94 0000 		call unregister_mods
 2369               	.LVL233:
 2370 024c 00C0      		rjmp .L133
 2371               	.L145:
 741:quantum/quantum.c ****         shift_interrupted[1] = false;
 2372               		.loc 1 741 0
 2373 024e F801      		movw r30,r16
 2374 0250 8281      		ldd r24,Z+2
 2375 0252 8111      		cpse r24,__zero_reg__
 2376 0254 00C0      		rjmp .L179
 746:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 2377               		.loc 1 746 0
 2378 0256 8091 0000 		lds r24,shift_interrupted+1
 2379 025a 8111      		cpse r24,__zero_reg__
 2380 025c 00C0      		rjmp .L177
 746:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 2381               		.loc 1 746 0 is_stmt 0 discriminator 1
 2382 025e 8091 0000 		lds r24,scs_timer+2
 2383 0262 9091 0000 		lds r25,scs_timer+2+1
 2384 0266 0E94 0000 		call timer_elapsed
 2385               	.LVL234:
 2386 026a 8436      		cpi r24,100
 2387 026c 9105      		cpc r25,__zero_reg__
 2388 026e 00F4      		brsh .L177
 747:quantum/quantum.c ****         register_code(SFTENT_KEY);
 2389               		.loc 1 747 0 is_stmt 1
 2390 0270 80E2      		ldi r24,lo8(32)
 2391 0272 0E94 0000 		call unregister_mods
 2392               	.LVL235:
 748:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 2393               		.loc 1 748 0
 2394 0276 88E2      		ldi r24,lo8(40)
 2395 0278 0E94 0000 		call register_code
 2396               	.LVL236:
 749:quantum/quantum.c ****       }
 2397               		.loc 1 749 0
 2398 027c 88E2      		ldi r24,lo8(40)
 2399 027e 0E94 0000 		call unregister_code
 2400               	.LVL237:
 2401 0282 00C0      		rjmp .L133
 2402               	.L141:
 2403               	.LBB55:
 758:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2404               		.loc 1 758 0
 2405 0284 0E94 0000 		call get_mods
 2406               	.LVL238:
 2407 0288 282F      		mov r18,r24
 2408               	.LVL239:
 791:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 2409               		.loc 1 791 0
 2410 028a F801      		movw r30,r16
 2411 028c 8281      		ldd r24,Z+2
 2412 028e 4091 0000 		lds r20,keyboard_report
 2413 0292 5091 0000 		lds r21,keyboard_report+1
 2414 0296 8823      		tst r24
 2415 0298 01F0      		breq .L180
 758:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 2416               		.loc 1 758 0
 2417 029a 2A7A      		andi r18,lo8(-86)
 2418               	.LVL240:
 792:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 2419               		.loc 1 792 0
 2420 029c 91E0      		ldi r25,lo8(1)
 2421 029e 01F4      		brne .L181
 2422 02a0 90E0      		ldi r25,0
 2423               	.L181:
 2424 02a2 9093 0000 		sts grave_esc_was_shifted,r25
 793:quantum/quantum.c ****       }
 2425               		.loc 1 793 0
 2426 02a6 9111      		cpse r25,__zero_reg__
 2427 02a8 00C0      		rjmp .L185
 2428 02aa 69E2      		ldi r22,lo8(41)
 2429 02ac 00C0      		rjmp .L182
 2430               	.L185:
 2431 02ae 65E3      		ldi r22,lo8(53)
 2432               	.L182:
 2433               	.LVL241:
 2434               	.LBB56:
 2435               	.LBB57:
 2436               		.file 4 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 2437               		.loc 4 33 0 discriminator 4
 2438 02b0 CA01      		movw r24,r20
 2439 02b2 0E94 0000 		call add_key_to_report
 2440               	.LVL242:
 2441 02b6 00C0      		rjmp .L183
 2442               	.LVL243:
 2443               	.L180:
 2444               	.LBE57:
 2445               	.LBE56:
 796:quantum/quantum.c ****       }
 2446               		.loc 1 796 0
 2447 02b8 8091 0000 		lds r24,grave_esc_was_shifted
 2448 02bc 8111      		cpse r24,__zero_reg__
 2449 02be 00C0      		rjmp .L186
 2450 02c0 69E2      		ldi r22,lo8(41)
 2451 02c2 00C0      		rjmp .L184
 2452               	.L186:
 2453 02c4 65E3      		ldi r22,lo8(53)
 2454               	.L184:
 2455               	.LVL244:
 2456               	.LBB58:
 2457               	.LBB59:
  34:tmk_core/common/action_util.h **** }
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 2458               		.loc 4 37 0 discriminator 4
 2459 02c6 CA01      		movw r24,r20
 2460 02c8 0E94 0000 		call del_key_from_report
 2461               	.LVL245:
 2462               	.L183:
 2463               	.LBE59:
 2464               	.LBE58:
 799:quantum/quantum.c ****       return false;
 2465               		.loc 1 799 0
 2466 02cc 0E94 0000 		call send_keyboard_report
 2467               	.LVL246:
 800:quantum/quantum.c ****     }
 2468               		.loc 1 800 0
 2469 02d0 00C0      		rjmp .L133
 2470               	.L134:
 2471               	.LBE55:
 812:quantum/quantum.c ****       shift_interrupted[1] = true;
 2472               		.loc 1 812 0
 2473 02d2 81E0      		ldi r24,lo8(1)
 2474 02d4 8093 0000 		sts shift_interrupted,r24
 813:quantum/quantum.c ****       break;
 2475               		.loc 1 813 0
 2476 02d8 8093 0000 		sts shift_interrupted+1,r24
 2477               	.L148:
 818:quantum/quantum.c **** }
 2478               		.loc 1 818 0
 2479 02dc C801      		movw r24,r16
 2480               	/* epilogue start */
 819:quantum/quantum.c **** 
 2481               		.loc 1 819 0
 2482 02de DF91      		pop r29
 2483 02e0 CF91      		pop r28
 2484               	.LVL247:
 2485 02e2 1F91      		pop r17
 2486 02e4 0F91      		pop r16
 2487               	.LVL248:
 2488 02e6 FF90      		pop r15
 818:quantum/quantum.c **** }
 2489               		.loc 1 818 0
 2490 02e8 0C94 0000 		jmp process_action_kb
 2491               	.LVL249:
 2492               	.L133:
 819:quantum/quantum.c **** 
 2493               		.loc 1 819 0
 2494 02ec 80E0      		ldi r24,0
 2495               	/* epilogue start */
 2496 02ee DF91      		pop r29
 2497 02f0 CF91      		pop r28
 2498               	.LVL250:
 2499 02f2 1F91      		pop r17
 2500 02f4 0F91      		pop r16
 2501               	.LVL251:
 2502 02f6 FF90      		pop r15
 2503 02f8 0895      		ret
 2504               		.cfi_endproc
 2505               	.LFE41:
 2507               	.global	rgb_matrix_task_counter
 2508               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2511               	rgb_matrix_task_counter:
 2512 0000 00        		.zero	1
 2513               		.weak	ascii_to_keycode_lut
 2514               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2517               	ascii_to_keycode_lut:
 2518 0000 00        		.byte	0
 2519 0001 00        		.byte	0
 2520 0002 00        		.byte	0
 2521 0003 00        		.byte	0
 2522 0004 00        		.byte	0
 2523 0005 00        		.byte	0
 2524 0006 00        		.byte	0
 2525 0007 00        		.byte	0
 2526 0008 2A        		.byte	42
 2527 0009 2B        		.byte	43
 2528 000a 28        		.byte	40
 2529 000b 00        		.byte	0
 2530 000c 00        		.byte	0
 2531 000d 00        		.byte	0
 2532 000e 00        		.byte	0
 2533 000f 00        		.byte	0
 2534 0010 00        		.byte	0
 2535 0011 00        		.byte	0
 2536 0012 00        		.byte	0
 2537 0013 00        		.byte	0
 2538 0014 00        		.byte	0
 2539 0015 00        		.byte	0
 2540 0016 00        		.byte	0
 2541 0017 00        		.byte	0
 2542 0018 00        		.byte	0
 2543 0019 00        		.byte	0
 2544 001a 00        		.byte	0
 2545 001b 29        		.byte	41
 2546 001c 00        		.byte	0
 2547 001d 00        		.byte	0
 2548 001e 00        		.byte	0
 2549 001f 00        		.byte	0
 2550 0020 2C        		.byte	44
 2551 0021 1E        		.byte	30
 2552 0022 34        		.byte	52
 2553 0023 20        		.byte	32
 2554 0024 21        		.byte	33
 2555 0025 22        		.byte	34
 2556 0026 24        		.byte	36
 2557 0027 34        		.byte	52
 2558 0028 26        		.byte	38
 2559 0029 27        		.byte	39
 2560 002a 25        		.byte	37
 2561 002b 2E        		.byte	46
 2562 002c 36        		.byte	54
 2563 002d 2D        		.byte	45
 2564 002e 37        		.byte	55
 2565 002f 38        		.byte	56
 2566 0030 27        		.byte	39
 2567 0031 1E        		.byte	30
 2568 0032 1F        		.byte	31
 2569 0033 20        		.byte	32
 2570 0034 21        		.byte	33
 2571 0035 22        		.byte	34
 2572 0036 23        		.byte	35
 2573 0037 24        		.byte	36
 2574 0038 25        		.byte	37
 2575 0039 26        		.byte	38
 2576 003a 33        		.byte	51
 2577 003b 33        		.byte	51
 2578 003c 36        		.byte	54
 2579 003d 2E        		.byte	46
 2580 003e 37        		.byte	55
 2581 003f 38        		.byte	56
 2582 0040 1F        		.byte	31
 2583 0041 04        		.byte	4
 2584 0042 05        		.byte	5
 2585 0043 06        		.byte	6
 2586 0044 07        		.byte	7
 2587 0045 08        		.byte	8
 2588 0046 09        		.byte	9
 2589 0047 0A        		.byte	10
 2590 0048 0B        		.byte	11
 2591 0049 0C        		.byte	12
 2592 004a 0D        		.byte	13
 2593 004b 0E        		.byte	14
 2594 004c 0F        		.byte	15
 2595 004d 10        		.byte	16
 2596 004e 11        		.byte	17
 2597 004f 12        		.byte	18
 2598 0050 13        		.byte	19
 2599 0051 14        		.byte	20
 2600 0052 15        		.byte	21
 2601 0053 16        		.byte	22
 2602 0054 17        		.byte	23
 2603 0055 18        		.byte	24
 2604 0056 19        		.byte	25
 2605 0057 1A        		.byte	26
 2606 0058 1B        		.byte	27
 2607 0059 1C        		.byte	28
 2608 005a 1D        		.byte	29
 2609 005b 2F        		.byte	47
 2610 005c 31        		.byte	49
 2611 005d 30        		.byte	48
 2612 005e 23        		.byte	35
 2613 005f 2D        		.byte	45
 2614 0060 35        		.byte	53
 2615 0061 04        		.byte	4
 2616 0062 05        		.byte	5
 2617 0063 06        		.byte	6
 2618 0064 07        		.byte	7
 2619 0065 08        		.byte	8
 2620 0066 09        		.byte	9
 2621 0067 0A        		.byte	10
 2622 0068 0B        		.byte	11
 2623 0069 0C        		.byte	12
 2624 006a 0D        		.byte	13
 2625 006b 0E        		.byte	14
 2626 006c 0F        		.byte	15
 2627 006d 10        		.byte	16
 2628 006e 11        		.byte	17
 2629 006f 12        		.byte	18
 2630 0070 13        		.byte	19
 2631 0071 14        		.byte	20
 2632 0072 15        		.byte	21
 2633 0073 16        		.byte	22
 2634 0074 17        		.byte	23
 2635 0075 18        		.byte	24
 2636 0076 19        		.byte	25
 2637 0077 1A        		.byte	26
 2638 0078 1B        		.byte	27
 2639 0079 1C        		.byte	28
 2640 007a 1D        		.byte	29
 2641 007b 2F        		.byte	47
 2642 007c 31        		.byte	49
 2643 007d 30        		.byte	48
 2644 007e 35        		.byte	53
 2645 007f 4C        		.byte	76
 2646               		.weak	ascii_to_shift_lut
 2647               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2650               	ascii_to_shift_lut:
 2651 0000 00        		.byte	0
 2652 0001 00        		.byte	0
 2653 0002 00        		.byte	0
 2654 0003 00        		.byte	0
 2655 0004 00        		.byte	0
 2656 0005 00        		.byte	0
 2657 0006 00        		.byte	0
 2658 0007 00        		.byte	0
 2659 0008 00        		.byte	0
 2660 0009 00        		.byte	0
 2661 000a 00        		.byte	0
 2662 000b 00        		.byte	0
 2663 000c 00        		.byte	0
 2664 000d 00        		.byte	0
 2665 000e 00        		.byte	0
 2666 000f 00        		.byte	0
 2667 0010 00        		.byte	0
 2668 0011 00        		.byte	0
 2669 0012 00        		.byte	0
 2670 0013 00        		.byte	0
 2671 0014 00        		.byte	0
 2672 0015 00        		.byte	0
 2673 0016 00        		.byte	0
 2674 0017 00        		.byte	0
 2675 0018 00        		.byte	0
 2676 0019 00        		.byte	0
 2677 001a 00        		.byte	0
 2678 001b 00        		.byte	0
 2679 001c 00        		.byte	0
 2680 001d 00        		.byte	0
 2681 001e 00        		.byte	0
 2682 001f 00        		.byte	0
 2683 0020 00        		.byte	0
 2684 0021 01        		.byte	1
 2685 0022 01        		.byte	1
 2686 0023 01        		.byte	1
 2687 0024 01        		.byte	1
 2688 0025 01        		.byte	1
 2689 0026 01        		.byte	1
 2690 0027 00        		.byte	0
 2691 0028 01        		.byte	1
 2692 0029 01        		.byte	1
 2693 002a 01        		.byte	1
 2694 002b 01        		.byte	1
 2695 002c 00        		.byte	0
 2696 002d 00        		.byte	0
 2697 002e 00        		.byte	0
 2698 002f 00        		.byte	0
 2699 0030 00        		.byte	0
 2700 0031 00        		.byte	0
 2701 0032 00        		.byte	0
 2702 0033 00        		.byte	0
 2703 0034 00        		.byte	0
 2704 0035 00        		.byte	0
 2705 0036 00        		.byte	0
 2706 0037 00        		.byte	0
 2707 0038 00        		.byte	0
 2708 0039 00        		.byte	0
 2709 003a 01        		.byte	1
 2710 003b 00        		.byte	0
 2711 003c 01        		.byte	1
 2712 003d 00        		.byte	0
 2713 003e 01        		.byte	1
 2714 003f 01        		.byte	1
 2715 0040 01        		.byte	1
 2716 0041 01        		.byte	1
 2717 0042 01        		.byte	1
 2718 0043 01        		.byte	1
 2719 0044 01        		.byte	1
 2720 0045 01        		.byte	1
 2721 0046 01        		.byte	1
 2722 0047 01        		.byte	1
 2723 0048 01        		.byte	1
 2724 0049 01        		.byte	1
 2725 004a 01        		.byte	1
 2726 004b 01        		.byte	1
 2727 004c 01        		.byte	1
 2728 004d 01        		.byte	1
 2729 004e 01        		.byte	1
 2730 004f 01        		.byte	1
 2731 0050 01        		.byte	1
 2732 0051 01        		.byte	1
 2733 0052 01        		.byte	1
 2734 0053 01        		.byte	1
 2735 0054 01        		.byte	1
 2736 0055 01        		.byte	1
 2737 0056 01        		.byte	1
 2738 0057 01        		.byte	1
 2739 0058 01        		.byte	1
 2740 0059 01        		.byte	1
 2741 005a 01        		.byte	1
 2742 005b 00        		.byte	0
 2743 005c 00        		.byte	0
 2744 005d 00        		.byte	0
 2745 005e 01        		.byte	1
 2746 005f 01        		.byte	1
 2747 0060 00        		.byte	0
 2748 0061 00        		.byte	0
 2749 0062 00        		.byte	0
 2750 0063 00        		.byte	0
 2751 0064 00        		.byte	0
 2752 0065 00        		.byte	0
 2753 0066 00        		.byte	0
 2754 0067 00        		.byte	0
 2755 0068 00        		.byte	0
 2756 0069 00        		.byte	0
 2757 006a 00        		.byte	0
 2758 006b 00        		.byte	0
 2759 006c 00        		.byte	0
 2760 006d 00        		.byte	0
 2761 006e 00        		.byte	0
 2762 006f 00        		.byte	0
 2763 0070 00        		.byte	0
 2764 0071 00        		.byte	0
 2765 0072 00        		.byte	0
 2766 0073 00        		.byte	0
 2767 0074 00        		.byte	0
 2768 0075 00        		.byte	0
 2769 0076 00        		.byte	0
 2770 0077 00        		.byte	0
 2771 0078 00        		.byte	0
 2772 0079 00        		.byte	0
 2773 007a 00        		.byte	0
 2774 007b 01        		.byte	1
 2775 007c 01        		.byte	1
 2776 007d 01        		.byte	1
 2777 007e 01        		.byte	1
 2778 007f 00        		.byte	0
 2779               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2782               	grave_esc_was_shifted:
 2783 0000 00        		.zero	1
 2784               		.section	.bss.scs_timer,"aw",@nobits
 2787               	scs_timer:
 2788 0000 0000 0000 		.zero	4
 2789               		.section	.bss.shift_interrupted,"aw",@nobits
 2792               	shift_interrupted:
 2793 0000 0000      		.zero	2
 2794               		.text
 2795               	.Letext0:
 2796               		.file 5 "/usr/lib/avr/include/stdint.h"
 2797               		.file 6 "tmk_core/common/matrix.h"
 2798               		.file 7 "tmk_core/common/keyboard.h"
 2799               		.file 8 "tmk_core/common/action.h"
 2800               		.file 9 "tmk_core/common/report.h"
 2801               		.file 10 "tmk_core/common/debug.h"
 2802               		.file 11 "quantum/keycode_config.h"
 2803               		.file 12 "tmk_core/common/keycode.h"
 2804               		.file 13 "quantum/quantum_keycodes.h"
 2805               		.file 14 "tmk_core/protocol/lufa/outputselect.h"
 2806               		.file 15 "quantum/quantum.h"
 2807               		.file 16 "tmk_core/common/eeconfig.h"
 2808               		.file 17 "tmk_core/common/action_layer.h"
 2809               		.file 18 "tmk_core/common/bootloader.h"
 2810               		.file 19 "quantum/keymap.h"
 2811               		.file 20 "tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccYHBPPn.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYHBPPn.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYHBPPn.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYHBPPn.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYHBPPn.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYHBPPn.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccYHBPPn.s:129    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccYHBPPn.s:159    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccYHBPPn.s:189    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccYHBPPn.s:219    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccYHBPPn.s:250    .text.rgblight_toggle:0000000000000000 rgblight_toggle
     /tmp/ccYHBPPn.s:266    .text.rgblight_step:0000000000000000 rgblight_step
     /tmp/ccYHBPPn.s:281    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
     /tmp/ccYHBPPn.s:296    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
     /tmp/ccYHBPPn.s:311    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
     /tmp/ccYHBPPn.s:326    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
     /tmp/ccYHBPPn.s:341    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
     /tmp/ccYHBPPn.s:356    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
     /tmp/ccYHBPPn.s:371    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
     /tmp/ccYHBPPn.s:386    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
     /tmp/ccYHBPPn.s:401    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
     /tmp/ccYHBPPn.s:416    .text.register_code16:0000000000000000 register_code16
     /tmp/ccYHBPPn.s:473    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccYHBPPn.s:528    .text.tap_code16:0000000000000000 tap_code16
     /tmp/ccYHBPPn.s:565    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccYHBPPn.s:584    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccYHBPPn.s:603    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccYHBPPn.s:621    .text.send_char:0000000000000000 send_char
     /tmp/ccYHBPPn.s:2517   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccYHBPPn.s:2650   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccYHBPPn.s:707    .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccYHBPPn.s:852    .text.send_string:0000000000000000 send_string
     /tmp/ccYHBPPn.s:871    .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccYHBPPn.s:1047   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccYHBPPn.s:1066   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccYHBPPn.s:1115   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccYHBPPn.s:1267   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccYHBPPn.s:1306   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccYHBPPn.s:1433   .text.bootmagic_lite:0000000000000000 bootmagic_lite
     /tmp/ccYHBPPn.s:1478   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccYHBPPn.s:1504   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccYHBPPn.s:1521   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccYHBPPn.s:1536   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccYHBPPn.s:1552   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccYHBPPn.s:1617   .text.send_byte:0000000000000000 send_byte
     /tmp/ccYHBPPn.s:1654   .text.send_word:0000000000000000 send_word
     /tmp/ccYHBPPn.s:1688   .text.send_dword:0000000000000000 send_dword
     /tmp/ccYHBPPn.s:1738   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccYHBPPn.s:1777   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccYHBPPn.s:1793   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccYHBPPn.s:1809   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccYHBPPn.s:1827   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccYHBPPn.s:1842   .text.led_set:0000000000000000 led_set
     /tmp/ccYHBPPn.s:1860   .text.startup_user:0000000000000000 startup_user
     /tmp/ccYHBPPn.s:1875   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccYHBPPn.s:1890   .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccYHBPPn.s:1932   .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccYHBPPn.s:2792   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccYHBPPn.s:2787   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccYHBPPn.s:2782   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccYHBPPn.s:2511   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan
matrix_get_row
eeconfig_disable
bootloader_jump
eeconfig_is_enabled
eeconfig_init
matrix_init_kb
matrix_scan_kb
clear_keyboard
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
debug_config
set_output
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_read
timer_elapsed
register_mods
unregister_mods
get_mods
keyboard_report
add_key_to_report
del_key_from_report
__do_clear_bss
